=== Spin.sol ===
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.25;

import "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol";

import "../interfaces/IDateTime.sol";
import "../interfaces/ISupraRouterContract.sol";

contract Spin is
    Initializable,
    AccessControlUpgradeable,
    UUPSUpgradeable,
    PausableUpgradeable,
    ReentrancyGuardUpgradeable
{

    // Storage
    struct UserData {
        uint256 jackpotWins;
        uint256 raffleTicketsGained;
        uint256 raffleTicketsBalance;
        uint256 PPGained;
        uint256 plumeTokens;
        uint256 streakCount;
        uint256 lastSpinTimestamp;
        uint256 nothingCounts;
    }

    // Defines the probability ranges for non-jackpot rewards based on a 0-999,999 scale.
    // Jackpot probability is determined separately by the daily jackpotProbabilities array.
    struct RewardProbabilities {
        uint256 plumeTokenThreshold; // Range start depends on daily jackpot threshold, ends here.
        uint256 raffleTicketThreshold; // Starts after plumeTokenThreshold, ends here.
        uint256 ppThreshold; // Starts after raffleTicketThreshold, ends here.
            // anything above ppThreshold is "Nothing"
    }

    // Roles
    bytes32 public constant ADMIN_ROLE = keccak256("ADMIN_ROLE");
    bytes32 public constant SUPRA_ROLE = keccak256("SUPRA_ROLE");
    uint256 public constant SECONDS_PER_DAY = 86_400;

    // State variables
    address public admin;
    uint256 public lastJackpotClaimWeek;
    mapping(address => UserData) public userData;
    uint256[7] public jackpotProbabilities;
    uint256 public baseRaffleMultiplier;
    uint256 public PP_PerSpin;
    uint256[3] public plumeAmounts;
    mapping(uint256 => address payable) public userNonce;
    ISupraRouterContract public supraRouter;
    IDateTime public dateTime;
    address public raffleContract;
    uint256 public campaignStartDate;
    mapping(uint8 => uint256) public jackpotPrizes;
    mapping(address => bool) public whitelists;
    bool public enableSpin;
    RewardProbabilities public rewardProbabilities;
    mapping(address => bool) public isSpinPending;
    uint256 public spinPrice; // Price to spin in wei
    mapping(address => uint256) public pendingNonce;

    // Reserved storage gap for future upgrades
    uint256[49] private __gap;

    // Events
    event SpinRequested(uint256 indexed nonce, address indexed user);
    event SpinCompleted(address indexed walletAddress, string rewardCategory, uint256 rewardAmount);
    event RaffleTicketsSpent(address indexed walletAddress, uint256 ticketsUsed, uint256 remainingTickets);
    event NotEnoughStreak(string message);
    event JackpotAlreadyClaimed(string message);

    // Errors
    error NotAdmin();
    error AlreadySpunToday();
    error InvalidNonce();
    error CampaignNotStarted();
    error SpinRequestPending(address user);

    /**
     * @notice Initializes the Spin contract.
     * @param supraRouterAddress The address of the Supra Router contract.
     * @param dateTimeAddress The address of the DateTime contract.
     */
    function initialize(address supraRouterAddress, address dateTimeAddress) public initializer {
        __AccessControl_init();
        __UUPSUpgradeable_init();
        __Pausable_init();
        __ReentrancyGuard_init();

        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(ADMIN_ROLE, msg.sender);
        _grantRole(SUPRA_ROLE, supraRouterAddress);

        supraRouter = ISupraRouterContract(supraRouterAddress);
        dateTime = IDateTime(dateTimeAddress);
        admin = msg.sender;
        enableSpin = false; // Start disabled until explicitly enabled

        // Set default values
        jackpotProbabilities = [1, 2, 3, 5, 7, 10, 20];
        jackpotPrizes[0] = 5000;
        jackpotPrizes[1] = 5000;
        jackpotPrizes[2] = 10_000;
        jackpotPrizes[3] = 10_000;
        jackpotPrizes[4] = 20_000;
        jackpotPrizes[5] = 20_000;
        jackpotPrizes[6] = 30_000;
        jackpotPrizes[7] = 30_000;
        jackpotPrizes[8] = 40_000;
        jackpotPrizes[9] = 40_000;
        jackpotPrizes[10] = 50_000;
        jackpotPrizes[11] = 100_000;

        baseRaffleMultiplier = 8;
        PP_PerSpin = 100;
        plumeAmounts = [1, 1, 1];

        lastJackpotClaimWeek = 999; // start with arbitrary non-zero value
        spinPrice = 2 ether; // Set default spin price to 2 PLUME

        // Set default probabilities
        // Note: Jackpot probability is handled by jackpotProbabilities based on dayOfWeek
        rewardProbabilities = RewardProbabilities({
            plumeTokenThreshold: 200_000, // Up to 200,000 (Approx 20%)
            raffleTicketThreshold: 600_000, // Up to 600,000 (Approx 40%)
            ppThreshold: 900_000 // Up to 900,000 (Approx 30%)
                // Above 900,000 is "Nothing" (Approx 10%)
         });
    }

    /// @notice Ensures that the user can only spin once per day by checking their last spin date.
    modifier canSpin() {
        // Early return if the user is whitelisted
        if (whitelists[msg.sender]) {
            _;
            return;
        }

        UserData storage userDataStorage = userData[msg.sender];
        uint256 _lastSpinTimestamp = userDataStorage.lastSpinTimestamp;

        // Retrieve last spin date components
        (uint16 lastSpinYear, uint8 lastSpinMonth, uint8 lastSpinDay) = (
            dateTime.getYear(_lastSpinTimestamp),
            dateTime.getMonth(_lastSpinTimestamp),
            dateTime.getDay(_lastSpinTimestamp)
        );

        // Retrieve current date components
        (uint16 currentYear, uint8 currentMonth, uint8 currentDay) =
            (dateTime.getYear(block.timestamp), dateTime.getMonth(block.timestamp), dateTime.getDay(block.timestamp));

        // Ensure the user hasn't already spun today
        if (isSameDay(lastSpinYear, lastSpinMonth, lastSpinDay, currentYear, currentMonth, currentDay)) {
            revert AlreadySpunToday();
        }

        _;
    }

    modifier onlyRaffleContract() {
        require(msg.sender == raffleContract, "Only Raffle contract can call this");
        _;
    }

    /// @notice Starts the spin process by generating a random number and recording the spin date.
    /// @dev This function is called by the user to initiate a spin. Requires payment equal to spinPrice.
    function startSpin() external payable whenNotPaused canSpin {
        if (!enableSpin) {
            revert CampaignNotStarted();
        }
        require(msg.value == spinPrice, "Incorrect spin price sent");

        if (isSpinPending[msg.sender]) {
            revert SpinRequestPending(msg.sender);
        }
        isSpinPending[msg.sender] = true;

        string memory callbackSignature = "handleRandomness(uint256,uint256[])";
        uint8 rngCount = 1;
        uint256 numConfirmations = 1;
        uint256 clientSeed = uint256(keccak256(abi.encodePacked(admin, block.timestamp)));

        uint256 nonce = supraRouter.generateRequest(callbackSignature, rngCount, numConfirmations, clientSeed, admin);
        userNonce[nonce] = payable(msg.sender);
        pendingNonce[msg.sender] = nonce;

        emit SpinRequested(nonce, msg.sender);
    }

    function getCurrentWeek() public view returns (uint256) {
        return (block.timestamp - campaignStartDate) / 7 days;
    }

    /**
     * @notice Handles the randomness callback from the Supra Router.
     * @dev This function is called by the Supra Router to provide the random number and determine the reward.
     * @param nonce The nonce associated with the spin request.
     * @param rngList The list of random numbers generated.
     */
    function handleRandomness(uint256 nonce, uint256[] memory rngList) external onlyRole(SUPRA_ROLE) nonReentrant {
        address payable user = userNonce[nonce];
        if (user == address(0)) {
            revert InvalidNonce();
        }

        isSpinPending[user] = false;
        delete userNonce[nonce];
        delete pendingNonce[user];

        uint256 currentSpinStreak = _computeStreak(user, block.timestamp, true);
        uint256 randomness = rngList[0]; // Use full VRF range
        (string memory rewardCategory, uint256 rewardAmount) = determineReward(randomness, currentSpinStreak);

        // Apply reward logic
        UserData storage userDataStorage = userData[user];

        // ----------  Effects: update storage first  ----------
        if (keccak256(bytes(rewardCategory)) == keccak256("Jackpot")) {
            uint256 currentWeek = getCurrentWeek();
            if (currentWeek == lastJackpotClaimWeek) {
                userDataStorage.nothingCounts += 1;
                rewardCategory = "Nothing";
                rewardAmount = 0;
                emit JackpotAlreadyClaimed("Jackpot already claimed this week");
            } else if (userDataStorage.streakCount < (currentWeek + 2)) {
                userDataStorage.nothingCounts += 1;
                rewardCategory = "Nothing";
                rewardAmount = 0;
                emit NotEnoughStreak("Not enough streak count to claim Jackpot");
            } else {
                userDataStorage.jackpotWins++;
                lastJackpotClaimWeek = currentWeek;
            }
        } else if (keccak256(bytes(rewardCategory)) == keccak256("Raffle Ticket")) {
            userDataStorage.raffleTicketsGained += rewardAmount;
            userDataStorage.raffleTicketsBalance += rewardAmount;
        } else if (keccak256(bytes(rewardCategory)) == keccak256("PP")) {
            userDataStorage.PPGained += rewardAmount;
        } else if (keccak256(bytes(rewardCategory)) == keccak256("Plume Token")) {
            userDataStorage.plumeTokens += rewardAmount;
        } else {
            userDataStorage.nothingCounts += 1;
        }

        // update the streak count after their spin
        userDataStorage.streakCount = currentSpinStreak;

        userDataStorage.lastSpinTimestamp = block.timestamp;
        // ----------  Interactions: transfer Plume last ----------
        if (
            keccak256(bytes(rewardCategory)) == keccak256("Jackpot")
                || keccak256(bytes(rewardCategory)) == keccak256("Plume Token")
        ) {
            _safeTransferPlume(user, rewardAmount * 1 ether);
        }

        emit SpinCompleted(user, rewardCategory, rewardAmount);
    }

    /**
     * @notice Determines the reward based on the generated randomness and user's state.
     * @param randomness The random number from Supra VRF.
     * @param streakForReward The user's streak for the current spin.
     * @return rewardCategory The category of the reward (e.g., "Jackpot", "Plume Token").
     * @return rewardAmount The amount of the reward.
     */
    /**
     * @notice Determines the reward category based on the VRF random number.
     * @param randomness The random number generated by the Supra Router.
     */
    function determineReward(
        uint256 randomness,
        uint256 streakForReward
    ) internal view returns (string memory, uint256) {
        uint256 probability = randomness % 1_000_000; // Normalize VRF range to 1M

        // Determine the current week in the 12-week campaign
        uint256 daysSinceStart = (block.timestamp - campaignStartDate) / 1 days;
        uint8 weekNumber = uint8(getCurrentWeek());
        uint8 dayOfWeek = uint8(daysSinceStart % 7);

        // Get jackpot threshold for the day of week
        uint256 jackpotThreshold = jackpotProbabilities[dayOfWeek];

        if (probability < jackpotThreshold) {
            return ("Jackpot", jackpotPrizes[weekNumber]);
        } else if (probability <= rewardProbabilities.plumeTokenThreshold) {
            uint256 plumeAmount = plumeAmounts[probability % 3];
            return ("Plume Token", plumeAmount);
        } else if (probability <= rewardProbabilities.raffleTicketThreshold) {
            return ("Raffle Ticket", baseRaffleMultiplier * streakForReward);
        } else if (probability <= rewardProbabilities.ppThreshold) {
            return ("PP", PP_PerSpin);
        }

        return ("Nothing", 0); // Default case
    }

    // ----------  Unified streak calculation ----------
    function _computeStreak(address user, uint256 nowTs, bool justSpun) internal view returns (uint256) {
        // if a user just spun, we need to increment the streak its a new day or a broken streak
        uint256 streakAdjustment = justSpun ? 1 : 0;

        uint256 lastSpinTs = userData[user].lastSpinTimestamp;

        if (lastSpinTs == 0) {
            return 0 + streakAdjustment;
        }
        uint256 lastDaySpun = lastSpinTs / SECONDS_PER_DAY;
        uint256 today = nowTs / SECONDS_PER_DAY;
        if (today == lastDaySpun) {
            return userData[user].streakCount;
        } // same day
        if (today == lastDaySpun + 1) {
            return userData[user].streakCount + streakAdjustment;
        } // streak not broken yet
        return 0 + streakAdjustment; // broken streak
    }

    /// @notice Returns the user's current streak count based on their last spin date.
    function currentStreak(
        address user
    ) public view returns (uint256) {
        return _computeStreak(user, block.timestamp, false);
    }

    /// @notice Allows the raffle contract to deduct tickets from a user's balance.
    function spendRaffleTickets(address user, uint256 amount) external onlyRaffleContract {
        UserData storage userDataStorage = userData[user];
        require(userDataStorage.raffleTicketsBalance >= amount, "Insufficient raffle tickets");
        userDataStorage.raffleTicketsBalance -= amount;
        emit RaffleTicketsSpent(user, amount, userDataStorage.raffleTicketsBalance);
    }

    /// @notice Allows the admin to withdraw PLUME tokens from the contract.
    function adminWithdraw(address payable recipient, uint256 amount) external onlyRole(ADMIN_ROLE) {
        require(recipient != address(0), "Invalid recipient address");
        _safeTransferPlume(recipient, amount);
    }

    /// @notice Pauses the contract, preventing spins.
    function pause() external onlyRole(ADMIN_ROLE) {
        _pause();
    }

    /// @dev Allows the admin to unpause the contract, resuming normal operations.
    function unpause() external onlyRole(ADMIN_ROLE) {
        _unpause();
    }

    // Utility Functions
    /**
     * @notice Checks if two dates are the same day.
     * @param year1 The year of the first date.
     * @param month1 The month of the first date.
     * @param day1 The day of the first date.
     * @param year2 The year of the second date.
     * @param month2 The month of the second date.
     * @param day2 The day of the second date.
     */
    function isSameDay(
        uint16 year1,
        uint8 month1,
        uint8 day1,
        uint16 year2,
        uint8 month2,
        uint8 day2
    ) internal pure returns (bool) {
        return (year1 == year2 && month1 == month2 && day1 == day2);
    }

    // View Functions
    /**
     * @notice Gets the data for a user.
     * @param user The address of the wallet.
     */
    function getUserData(
        address user
    )
        external
        view
        returns (
            uint256 dailyStreak,
            uint256 lastSpinTimestamp,
            uint256 jackpotWins,
            uint256 raffleTicketsGained,
            uint256 raffleTicketsBalance,
            uint256 ppGained,
            uint256 smallPlumeTokens
        )
    {
        UserData storage userDataStorage = userData[user];

        return (
            currentStreak(user),
            userDataStorage.lastSpinTimestamp,
            userDataStorage.jackpotWins,
            userDataStorage.raffleTicketsGained,
            userDataStorage.raffleTicketsBalance,
            userDataStorage.PPGained,
            userDataStorage.plumeTokens
        );
    }

    /**
     * @notice Returns the current week's jackpot prize and required streak count
     */
    function getWeeklyJackpot()
        external
        view
        returns (uint256 weekNumber, uint256 jackpotPrize, uint256 requiredStreak)
    {
        require(campaignStartDate > 0, "Campaign not started");

        uint256 daysSinceStart = (block.timestamp - campaignStartDate) / 1 days;
        weekNumber = daysSinceStart / 7;

        if (weekNumber > 11) {
            return (weekNumber, 0, 0);
        }

        jackpotPrize = jackpotPrizes[uint8(weekNumber)];
        requiredStreak = weekNumber + 2;
    }

    function getCampaignStartDate() external view returns (uint256) {
        return campaignStartDate;
    }

    function getContractBalance() external view returns (uint256) {
        return address(this).balance;
    }

    // Setters
    /// @notice Sets the jackpot probabilities for each day of the week.
    /// @param _jackpotProbabilities An array of 7 integers representing the jackpot vrf range for each day.
    function setJackpotProbabilities(
        uint8[7] memory _jackpotProbabilities
    ) external onlyRole(ADMIN_ROLE) {
        jackpotProbabilities = _jackpotProbabilities;
    }

    /// @notice Sets the jackpot prize for a specific week.
    /// @param week The week number (0-11).
    /// @param prize The jackpot prize amount.
    function setJackpotPrizes(uint8 week, uint256 prize) external onlyRole(ADMIN_ROLE) {
        jackpotPrizes[week] = prize;
    }

    function setCampaignStartDate(
        uint256 start
    ) external onlyRole(ADMIN_ROLE) {
        campaignStartDate = start == 0 ? block.timestamp : start;
    }

    /// @notice Sets the base value for raffle.
    /// @param _baseRaffleMultiplier The base value for raffle.
    function setBaseRaffleMultiplier(
        uint256 _baseRaffleMultiplier
    ) external onlyRole(ADMIN_ROLE) {
        baseRaffleMultiplier = _baseRaffleMultiplier;
    }

    /// @notice Sets the PP gained per spin.
    /// @param _PP_PerSpin The PP gained per spin.
    function setPP_PerSpin(
        uint256 _PP_PerSpin
    ) external onlyRole(ADMIN_ROLE) {
        PP_PerSpin = _PP_PerSpin;
    }

    /// @notice Sets the Plume Token amounts.
    /// @param _plumeAmounts An array of 3 integers representing the Plume Token amounts.
    function setPlumeAmounts(
        uint256[3] memory _plumeAmounts
    ) external onlyRole(ADMIN_ROLE) {
        plumeAmounts = _plumeAmounts;
    }

    /// @notice Sets the Raffle contract address.
    /// @param _raffleContract The address of the Raffle contract.
    function setRaffleContract(
        address _raffleContract
    ) external onlyRole(ADMIN_ROLE) {
        raffleContract = _raffleContract;
    }

    /// @notice Whitelist address to bypass cooldown period.
    /// @param user The address of the user to whitelist.
    function whitelist(
        address user
    ) external onlyRole(ADMIN_ROLE) {
        whitelists[user] = true;
    }

    /// @notice Remove address from whitelist, restoring the daily spin limit.
    /// @param user The address of the user to remove from the whitelist.
    function removeWhitelist(
        address user
    ) external onlyRole(ADMIN_ROLE) {
        whitelists[user] = false;
    }

    /// @notice Enable or disable spinning
    /// @param _enableSpin The flag to enable/disable spinning
    function setEnableSpin(
        bool _enableSpin
    ) external onlyRole(ADMIN_ROLE) {
        enableSpin = _enableSpin;
    }

    /**
     * @notice Updates the reward probabilities.
     * @param _plumeTokenThreshold The upper threshold for Plume Token rewards.
     * @param _raffleTicketThreshold The upper threshold for Raffle Ticket rewards.
     * @param _ppThreshold The upper threshold for PP rewards.
     */
    function setRewardProbabilities(
        uint256 _plumeTokenThreshold,
        uint256 _raffleTicketThreshold,
        uint256 _ppThreshold
    ) external onlyRole(ADMIN_ROLE) {
        require(_plumeTokenThreshold < _raffleTicketThreshold, "Invalid thresholds order");
        require(_raffleTicketThreshold < _ppThreshold, "Invalid thresholds order");
        require(_ppThreshold <= 1_000_000, "Threshold exceeds maximum");

        rewardProbabilities.plumeTokenThreshold = _plumeTokenThreshold;
        rewardProbabilities.raffleTicketThreshold = _raffleTicketThreshold;
        rewardProbabilities.ppThreshold = _ppThreshold;
    }

    /**
     * @notice Returns the current price required to spin.
     * @return The price in wei.
     */
    function getSpinPrice() external view returns (uint256) {
        return spinPrice;
    }

    /**
     * @notice Allows the admin to set the price required to spin.
     * @param _newPrice The new price in wei.
     */
    function setSpinPrice(
        uint256 _newPrice
    ) external onlyRole(ADMIN_ROLE) {
        spinPrice = _newPrice;
    }

    /**
     * @notice Allows an admin to cancel a pending spin request for a user.
     * @dev This is an escape hatch in case the oracle callback fails or gets stuck,
     * which would otherwise leave the user's spin in a permanently pending state.
     * @param user The address of the user whose pending spin should be canceled.
     */
    function cancelPendingSpin(address user) external onlyRole(ADMIN_ROLE) {
        require(isSpinPending[user], "No spin pending for this user");

        uint256 nonce = pendingNonce[user];
        if (nonce != 0) {
            delete userNonce[nonce];
        }

        delete pendingNonce[user];
        isSpinPending[user] = false;
        
        // Note: The spin fee is NOT refunded. This is to prevent gaming the system,
        // as the oracle request may have already been sent and incurred costs.
    }

    /// @notice Transfers Plume tokens safely, reverting if the contract has insufficient balance.
    function _safeTransferPlume(address payable _to, uint256 _amount) internal {
        require(address(this).balance >= _amount, "insufficient Plume in the Spin contract");
        (bool success,) = _to.call{ value: _amount }("");
        require(success, "Plume transfer failed");
    }

    // UUPS Authorization
    /**
     * @notice Authorizes the upgrade of the contract.
     * @param newImplementation The address of the new implementation.
     */
    function _authorizeUpgrade(
        address newImplementation
    ) internal override onlyRole(ADMIN_ROLE) { }

    /// @notice Fallback function to receive ether
    receive() external payable { }

}

// @auditounts += 1;
                rewardCategory = "Nothing";
                rewardAmount = 0;
                emit JackpotAlreadyClaimed("Jackpot already claimed this week");
            } else if (userDataStorage.streakCount < (currentWeek + 2)) {
                userDataStorage.nothingCounts += 1;
                rewardCategory = "Nothing";
                rewardAmount = 0;
                emit NotEnoughStreak("Not enough streak count to claim Jackpot");
            } else {
                userDataStorage.jackpotWins++;
                lastJackpotClaimWeek = currentWeek;
            }
        } else if (keccak256(bytes(rewardCategory)) == keccak256("Raffle Ticket")) {
            userDataStorage.raffleTicketsGained += rewardAmount;
            userDataStorage.raffleTicketsBalance += rewardAmount;
        } else if (keccak256(bytes(rewardCategory)) == keccak256("PP")) {
            userDataStorage.PPGained += rewardAmount;
        } else if (keccak256(bytes(rewardCategory)) == keccak256("Plume Token")) {
            userDataStorage.plumeTokens += rewardAmount;
        } else {
            userDataStorage.nothingCounts += 1;
        }

        // update the streak count after their spin
        userDataStorage.streakCount = currentSpinStreak;

        userDataStorage.lastSpinTimestamp = block.timestamp;
        // ----------  Interactions: transfer Plume last ----------
        if (
            keccak256(bytes(rewardCategory)) == keccak256("Jackpot")
                || keccak256(bytes(rewardCategory)) == keccak256("Plume Token")
        ) {
            _safeTransferPlume(user, rewardAmount * 1 ether);
        }

        emit SpinCompleted(user, rewardCategory, rewardAmount);
    }

    /**
     * @notice Determines the reward based on the generated randomness and user's state.
     * @param randomness The random number from Supra VRF.
     * @param streakForReward The user's streak for the current spin.
     * @return rewardCategory The category of the reward (e.g., "Jackpot", "Plume Token").
     * @return rewardAmount The amount of the reward.
     */
    /**
     * @notice Determines the reward category based on the VRF random number.
     * @param randomness The random number generated by the Supra Router.
     */
    function determineReward(
        uint256 randomness,
        uint256 streakForReward
    ) internal view returns (string memory, uint256) {
        uint256 probability = randomness % 1_000_000; // Normalize VRF range to 1M

        // Determine the current week in the 12-week campaign
        uint256 daysSinceStart = (block.timestamp - campaignStartDate) / 1 days;
        uint8 weekNumber = uint8(getCurrentWeek());
        uint8 dayOfWeek = uint8(daysSinceStart % 7);

        // Get jackpot threshold for the day of week
        uint256 jackpotThreshold = jackpotProbabilities[dayOfWeek];

        if (probability < jackpotThreshold) {
            return ("Jackpot", jackpotPrizes[weekNumber]);
        } else if (probability <= rewardProbabilities.plumeTokenThreshold) {
            uint256 plumeAmount = plumeAmounts[probability % 3];
            return ("Plume Token", plumeAmount);
        } else if (probability <= rewardProbabilities.raffleTicketThreshold) {
            return ("Raffle Ticket", baseRaffleMultiplier * streakForReward);
        } else if (probability <= rewardProbabilities.ppThreshold) {
            return ("PP", PP_PerSpin);
        }

        return ("Nothing", 0); // Default case
    }

    // ----------  Unified streak calculation ----------
    function _computeStreak(address user, uint256 nowTs, bool justSpun) internal view returns (uint256) {
        // if a user just spun, we need to increment the streak its a new day or a broken streak
        uint256 streakAdjustment = justSpun ? 1 : 0;

        uint256 lastSpinTs = userData[user].lastSpinTimestamp;

        if (lastSpinTs == 0) {
            return 0 + streakAdjustment;
        }
        uint256 lastDaySpun = lastSpinTs / SECONDS_PER_DAY;
        uint256 today = nowTs / SECONDS_PER_DAY;
        if (today == lastDaySpun) {
            return userData[user].streakCount;
        } // same day
        if (today == lastDaySpun + 1) {
            return userData[user].streakCount + streakAdjustment;
        } // streak not broken yet
        return 0 + streakAdjustment; // broken streak
    }

    /// @notice Returns the user's current streak count based on their last spin date.
    function currentStreak(
        address user
    ) public view returns (uint256) {
        return _computeStreak(user, block.timestamp, false);
    }

    /// @notice Allows the raffle contract to deduct tickets from a user's balance.
    function spendRaffleTickets(address user, uint256 amount) external onlyRaffleContract {
        UserData storage userDataStorage = userData[user];
        require(userDataStorage.raffleTicketsBalance >= amount, "Insufficient raffle tickets");
        userDataStorage.raffleTicketsBalance -= amount;
        emit RaffleTicketsSpent(user, amount, userDataStorage.raffleTicketsBalance);
    }

    /// @notice Allows the admin to withdraw PLUME tokens from the contract.
    function adminWithdraw(address payable recipient, uint256 amount) external onlyRole(ADMIN_ROLE) {
        require(recipient != address(0), "Invalid recipient address");
        _safeTransferPlume(recipient, amount);
    }

    /// @notice Pauses the contract, preventing spins.
    function pause() external onlyRole(ADMIN_ROLE) {
        _pause();
    }

    /// @dev Allows the admin to unpause the contract, resuming normal operations.
    function unpause() external onlyRole(ADMIN_ROLE) {
        _unpause();
    }

    // Utility Functions
    /**
     * @notice Checks if two dates are the same day.
     * @param year1 The year of the first date.
     * @param month1 The month of the first date.
     * @param day1 The day of the first date.
     * @param year2 The year of the second date.
     * @param month2 The month of the second date.
     * @param day2 The day of the second date.
     */
    function isSameDay(
        uint16 year1,
        uint8 month1,
        uint8 day1,
        uint16 year2,
        uint8 month2,
        uint8 day2
    ) internal pure returns (bool) {
        return (year1 == year2 && month1 == month2 && day1 == day2);
    }

    // View Functions
    /**
     * @notice Gets the data for a user.
     * @param user The address of the wallet.
     */
    function getUserData(
        address user
    )
        external
        view
        returns (
            uint256 dailyStreak,
            uint256 lastSpinTimestamp,
            uint256 jackpotWins,
            uint256 raffleTicketsGained,
            uint256 raffleTicketsBalance,
            uint256 ppGained,
            uint256 smallPlumeTokens
        )
    {
        UserData storage userDataStorage = userData[user];

        return (
            currentStreak(user),
            userDataStorage.lastSpinTimestamp,
            userDataStorage.jackpotWins,
            userDataStorage.raffleTicketsGained,
            userDataStorage.raffleTicketsBalance,
            userDataStorage.PPGained,
            userDataStorage.plumeTokens
        );
    }

    /**
     * @notice Returns the current week's jackpot prize and required streak count
     */
    function getWeeklyJackpot()
        external
        view
        returns (uint256 weekNumber, uint256 jackpotPrize, uint256 requiredStreak)
    {
        require(campaignStartDate > 0, "Campaign not started");

        uint256 daysSinceStart = (block.timestamp - campaignStartDate) / 1 days;
        weekNumber = daysSinceStart / 7;

        if (weekNumber > 11) {
            return (weekNumber, 0, 0);
        }

        jackpotPrize = jackpotPrizes[uint8(weekNumber)];
        requiredStreak = weekNumber + 2;
    }

    function getCampaignStartDate() external view returns (uint256) {
        return campaignStartDate;
    }

    function getContractBalance() external view returns (uint256) {
        return address(this).balance;
    }

    // Setters
    /// @notice Sets the jackpot probabilities for each day of the week.
    /// @param _jackpotProbabilities An array of 7 integers representing the jackpot vrf range for each day.
    function setJackpotProbabilities(
        uint8[7] memory _jackpotProbabilities
    ) external onlyRole(ADMIN_ROLE) {
        jackpotProbabilities = _jackpotProbabilities;
    }

    /// @notice Sets the jackpot prize for a specific week.
    /// @param week The week number (0-11).
    /// @param prize The jackpot prize amount.
    function setJackpotPrizes(uint8 week, uint256 prize) external onlyRole(ADMIN_ROLE) {
        jackpotPrizes[week] = prize;
    }

    function setCampaignStartDate(
        uint256 start
    ) external onlyRole(ADMIN_ROLE) {
        campaignStartDate = start == 0 ? block.timestamp : start;
    }

    /// @notice Sets the base value for raffle.
    /// @param _baseRaffleMultiplier The base value for raffle.
    function setBaseRaffleMultiplier(
        uint256 _baseRaffleMultiplier
    ) external onlyRole(ADMIN_ROLE) {
        baseRaffleMultiplier = _baseRaffleMultiplier;
    }

    /// @notice Sets the PP gained per spin.
    /// @param _PP_PerSpin The PP gained per spin.
    function setPP_PerSpin(
        uint256 _PP_PerSpin
    ) external onlyRole(ADMIN_ROLE) {
        PP_PerSpin = _PP_PerSpin;
    }

    /// @notice Sets the Plume Token amounts.
    /// @param _plumeAmounts An array of 3 integers representing the Plume Token amounts.
    function setPlumeAmounts(
        uint256[3] memory _plumeAmounts
    ) external onlyRole(ADMIN_ROLE) {
        plumeAmounts = _plumeAmounts;
    }

    /// @notice Sets the Raffle contract address.
    /// @param _raffleContract The address of the Raffle contract.
    function setRaffleContract(
        address _raffleContract
    ) external onlyRole(ADMIN_ROLE) {
        raffleContract = _raffleContract;
    }

    /// @notice Whitelist address to bypass cooldown period.
    /// @param user The address of the user to whitelist.
    function whitelist(
        address user
    ) external onlyRole(ADMIN_ROLE) {
        whitelists[user] = true;
    }

    /// @notice Remove address from whitelist, restoring the daily spin limit.
    /// @param user The address of the user to remove from the whitelist.
    function removeWhitelist(
        address user
    ) external onlyRole(ADMIN_ROLE) {
        whitelists[user] = false;
    }

    /// @notice Enable or disable spinning
    /// @param _enableSpin The flag to enable/disable spinning
    function setEnableSpin(
        bool _enableSpin
    ) external onlyRole(ADMIN_ROLE) {
        enableSpin = _enableSpin;
    }

    /**
     * @notice Updates the reward probabilities.
     * @param _plumeTokenThreshold The upper threshold for Plume Token rewards.
     * @param _raffleTicketThreshold The upper threshold for Raffle Ticket rewards.
     * @param _ppThreshold The upper threshold for PP rewards.
     */
    function setRewardProbabilities(
        uint256 _plumeTokenThreshold,
        uint256 _raffleTicketThreshold,
        uint256 _ppThreshold
    ) external onlyRole(ADMIN_ROLE) {
        require(_plumeTokenThreshold < _raffleTicketThreshold, "Invalid thresholds order");
        require(_raffleTicketThreshold < _ppThreshold, "Invalid thresholds order");
        require(_ppThreshold <= 1_000_000, "Threshold exceeds maximum");

        rewardProbabilities.plumeTokenThreshold = _plumeTokenThreshold;
        rewardProbabilities.raffleTicketThreshold = _raffleTicketThreshold;
        rewardProbabilities.ppThreshold = _ppThreshold;
    }

    /**
     * @notice Returns the current price required to spin.
     * @return The price in wei.
     */
    function getSpinPrice() external view returns (uint256) {
        return spinPrice;
    }

    /**
     * @notice Allows the admin to set the price required to spin.
     * @param _newPrice The new price in wei.
     */
    function setSpinPrice(
        uint256 _newPrice
    ) external onlyRole(ADMIN_ROLE) {
        spinPrice = _newPrice;
    }

    /**
     * @notice Allows an admin to cancel a pending spin request for a user.
     * @dev This is an escape hatch in case the oracle callback fails or gets stuck,
     * which would otherwise leave the user's spin in a permanently pending state.
     * @param user The address of the user whose pending spin should be canceled.
     */
    function cancelPendingSpin(address user) external onlyRole(ADMIN_ROLE) {
        require(isSpinPending[user], "No spin pending for this user");

        uint256 nonce = pendingNonce[user];
        if (nonce != 0) {
            delete userNonce[nonce];
        }

        delete pendingNonce[user];
        isSpinPending[user] = false;
        
        // Note: The spin fee is NOT refunded. This is to prevent gaming the system,
        // as the oracle request may have already been sent and incurred costs.
    }

    /// @notice Transfers Plume tokens safely, reverting if the contract has insufficient balance.
    function _safeTransferPlume(address payable _to, uint256 _amount) internal {
        require(address(this).balance >= _amount, "insufficient Plume in the Spin contract");
        (bool success,) = _to.call{ value: _amount }("");
        require(success, "Plume transfer failed");
    }

    // UUPS Authorization
    /**
     * @notice Authorizes the upgrade of the contract.
     * @param newImplementation The address of the new implementation.
     */
    function _authorizeUpgrade(
        address newImplementation
    ) internal override onlyRole(ADMIN_ROLE) { }

    /// @notice Fallback function to receive ether
    receive() external payable { }

}

// @audit
=== Raffle.sol ===
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.25;

import "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";

import "../interfaces/ISupraRouterContract.sol";

interface ISpin {
    function spendRaffleTickets(address _user, uint256 _amount) external;
    function getUserData(
        address _user
    ) external view returns (uint256, uint256, uint256, uint256, uint256, uint256, uint256);
}

contract Raffle is Initializable, AccessControlUpgradeable, UUPSUpgradeable {
    struct Prize {
        string name;
        string description;
        uint256 value;
        uint256 endTimestamp;
        bool isActive;
        address winner; // @deprecated
        uint256 winnerIndex; // @deprecated
        bool claimed; // @deprecated
        uint256 quantity;
    }

    struct Range {
        address user;
        uint256 cumulativeEnd;
    }

    struct Winner {
        address winnerAddress;
        uint256 winningTicketIndex;
        uint256 drawnAt;
        bool claimed;
    }

    // Roles
    bytes32 public constant ADMIN_ROLE = keccak256("ADMIN_ROLE");
    bytes32 public constant SUPRA_ROLE = keccak256("SUPRA_ROLE");

    // State variables
    address public admin;
    ISpin public spinContract;
    ISupraRouterContract public supraRouter;
    
    // Prize storage
    mapping(uint256 => Prize) public prizes;
    uint256[] public prizeIds;
    
    // Ticket tracking
    mapping(uint256 => Range[]) public prizeRanges;
    mapping(uint256 => uint256) public totalTickets;
    
    // User tracking
    mapping(uint256 => mapping(address => bool)) public userHasEnteredPrize;
    mapping(uint256 => uint256) public totalUniqueUsers;
    mapping(address => uint256[]) public winnings;
    
    // VRF
    mapping(uint256 => uint256) public pendingVRFRequests;
    mapping(uint256 => bool) public isWinnerRequestPending;

    // --- NEW STATE FOR MULTI-WINNER ---
    mapping(uint256 => Winner[]) public prizeWinners;
    mapping(uint256 => uint256) public winnersDrawn;
    mapping(uint256 => mapping(address => uint256)) public userWinCount;

    // Migration tracking
    bool private _migrationComplete;

    // Reserved storage gap for future upgrades
    uint256[50] private __gap;

    // Events
    event PrizeAdded(uint256 indexed prizeId, string name);
    event PrizeRemoved(uint256 indexed prizeId);
    event TicketSpent(address indexed user, uint256 indexed prizeId, uint256 tickets);
    event WinnerRequested(uint256 indexed prizeId, uint256 indexed requestId);
    event WinnerSelected(uint256 indexed prizeId, address indexed winner, uint256 winningTicketIndex);
    event PrizeClaimed(address indexed user, uint256 indexed prizeId, uint256 winnerIndex);
    event PrizeMigrated(uint256 indexed prizeId, uint256 migratedEntries, uint256 totalTickets);
    event PrizeEdited(uint256 indexed prizeId, string name, string description, uint256 value, uint256 quantity);
    event WinnerSet(uint256 indexed prizeId, address indexed winner); // @deprecated

    // Errors
    error EmptyTicketPool();
    error WinnerDrawn(address winner); // @deprecated
    error AllWinnersDrawn();
    error NoMoreWinners();
    error WinnerClaimed();
    error PrizeInactive();
    error InsufficientTickets();
    error WinnerNotDrawn();
    error NotAWinner();
    error WinnerRequestPending(uint256 prizeId);

    // Track the next prize ID so even if some are deleted we know it
    uint256 private nextPrizeId;

    // Initialize function
    function initialize(address _spinContract, address _supraRouter) public initializer {
        __AccessControl_init();
        __UUPSUpgradeable_init();
        
        spinContract = ISpin(_spinContract);
        supraRouter = ISupraRouterContract(_supraRouter);
        admin = msg.sender;
        nextPrizeId = 1; // 1-based indexing for prizes

        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(ADMIN_ROLE, msg.sender);
        _grantRole(SUPRA_ROLE, _supraRouter);
    }

    // Modifiers
    
    modifier prizeIsActive(uint256 prizeId) {
        require(prizes[prizeId].isActive, "Prize not available");
        _;
    }

    // Prize management
    function addPrize(
        string calldata name,
        string calldata description,
        uint256 value,
        uint256 quantity
    ) external onlyRole(ADMIN_ROLE) {
        uint256 prizeId = nextPrizeId++;
        prizeIds.push(prizeId);

        require(bytes(prizes[prizeId].name).length == 0, "Prize ID already in use");
        require(quantity > 0, "Quantity must be greater than 0");

        prizes[prizeId] = Prize({
            name: name,
            description: description,
            value: value,
            endTimestamp: 0,
            isActive: true,
            winner: address(0), // deprecated
            winnerIndex: 0, // deprecated
            claimed: false, // deprecated
            quantity: quantity
        });

        emit PrizeAdded(prizeId, name);
    }

    function editPrize(
        uint256 prizeId,
        string calldata name,
        string calldata description,
        uint256 value,
        uint256 quantity
    ) external onlyRole(ADMIN_ROLE) prizeIsActive(prizeId) {
        // Update prize details without affecting tickets or active status
        Prize storage prize = prizes[prizeId];
        prize.name = name;
        prize.description = description;
        prize.value = value;
        prize.quantity = quantity;
        
        emit PrizeEdited(prizeId, name, description, value, quantity);
    }

    function removePrize(uint256 prizeId) external onlyRole(ADMIN_ROLE) prizeIsActive(prizeId) {
        prizes[prizeId].isActive = false;
        
        // Remove from prizeIds array
        uint256 len = prizeIds.length;
        for (uint256 i = 0; i < len; i++) {
            if (prizeIds[i] == prizeId) {
                prizeIds[i] = prizeIds[len - 1];
                prizeIds.pop();
                break;
            }
        }
        
        emit PrizeRemoved(prizeId);
    }

    // User is spending raffle tickets to enter a prize
    function spendRaffle(uint256 prizeId, uint256 ticketAmount) external prizeIsActive(prizeId) {
        require(ticketAmount > 0, "Must spend at least 1 ticket");

        // Verify and deduct tickets from user balance
        (,,,, uint256 userRaffleTickets,,) = spinContract.getUserData(msg.sender);
        if (userRaffleTickets < ticketAmount) revert InsufficientTickets();
        spinContract.spendRaffleTickets(msg.sender, ticketAmount);

        // Append range
        uint256 newTotal = totalTickets[prizeId] + ticketAmount;
        prizeRanges[prizeId].push(
            Range({ user: msg.sender, cumulativeEnd: newTotal })
        );
        totalTickets[prizeId] = newTotal;

        // Track unique users
        if (!userHasEnteredPrize[prizeId][msg.sender]) {
            userHasEnteredPrize[prizeId][msg.sender] = true;
            totalUniqueUsers[prizeId]++;
        }

        emit TicketSpent(msg.sender, prizeId, ticketAmount);
    }

    // Admin requests a winner to be selected by VRF
    function requestWinner(uint256 prizeId) external onlyRole(ADMIN_ROLE) {
        if (winnersDrawn[prizeId] >= prizes[prizeId].quantity) revert AllWinnersDrawn();
        if (prizeRanges[prizeId].length == 0) revert EmptyTicketPool();
        require(prizes[prizeId].isActive, "Prize not available");

        if (isWinnerRequestPending[prizeId]) {
            revert WinnerRequestPending(prizeId);
        }
        isWinnerRequestPending[prizeId] = true;

        string memory callbackSig = "handleWinnerSelection(uint256,uint256[])";
        uint256 requestId = supraRouter.generateRequest(
            callbackSig,
            1,
            1,
            uint256(keccak256(abi.encodePacked(prizeId, block.timestamp))),
            msg.sender
        );
        
        pendingVRFRequests[requestId] = prizeId;
        emit WinnerRequested(prizeId, requestId);
    }

    // Callback from VRF to set the winning ticket number and determine the winner
    function handleWinnerSelection(uint256 requestId, uint256[] memory rng) external onlyRole(SUPRA_ROLE) {
        uint256 prizeId = pendingVRFRequests[requestId];
        
        isWinnerRequestPending[prizeId] = false;
        delete pendingVRFRequests[requestId];

        if (!prizes[prizeId].isActive) revert PrizeInactive();
        if (winnersDrawn[prizeId] >= prizes[prizeId].quantity) revert NoMoreWinners();

        uint256 winningTicketIndex = (rng[0] % totalTickets[prizeId]) + 1;

        // Binary search for the winner
        Range[] storage ranges = prizeRanges[prizeId];
        address winnerAddress;
        
        if (ranges.length > 0) {
            uint256 lo = 0;
            uint256 hi = ranges.length - 1;
            while (lo < hi) {
                uint256 mid = (lo + hi) >> 1;
                if (winningTicketIndex <= ranges[mid].cumulativeEnd) {
                    hi = mid;
                } else {
                    lo = mid + 1;
                }
            }
            winnerAddress = ranges[lo].user;
        }

        // Store winner details
        prizeWinners[prizeId].push(Winner({
            winnerAddress: winnerAddress,
            winningTicketIndex: winningTicketIndex,
            drawnAt: block.timestamp,
            claimed: false
        }));

        winnersDrawn[prizeId]++;
        userWinCount[prizeId][winnerAddress]++;

        // Deactivate prize if all winners have been drawn
        if (winnersDrawn[prizeId] == prizes[prizeId].quantity) {
            prizes[prizeId].isActive = false;
        }
    
        emit WinnerSelected(prizeId, winnerAddress, winningTicketIndex);
    }

    // Admin function called immediately after VRF callback to set the winner in contract storage
    // Executes a binary search to find the winner but only called once
    function setWinner(uint256 prizeId) external onlyRole(ADMIN_ROLE) {
        revert("setWinner is deprecated, winner is set in handleWinnerSelection");
    }

    // read function to get the winner of a prize by direct read
    function getWinner(uint256 prizeId, uint256 index) public view returns (address) {
        return prizeWinners[prizeId][index].winnerAddress;
    }

    // User claims their prize, we mark it as claimed and deactivate the prize
    function claimPrize(uint256 prizeId, uint256 winnerIndex) external {
        if (prizes[prizeId].isActive && winnersDrawn[prizeId] < prizes[prizeId].quantity) {
            revert WinnerNotDrawn();
        }

        Winner storage individualWin = prizeWinners[prizeId][winnerIndex];

        if (individualWin.claimed) revert WinnerClaimed();
        if (msg.sender != individualWin.winnerAddress) revert NotAWinner();

        individualWin.claimed = true;
        winnings[msg.sender].push(prizeId);
        
        emit PrizeClaimed(msg.sender, prizeId, winnerIndex);
    }

    /**
     * @notice Allows an admin to cancel a pending VRF winner request.
     * @dev This is an escape hatch in case the oracle callback fails,
     * which would otherwise leave the prize in a permanently pending state.
     * @param prizeId The ID of the prize with the pending request.
     */
    function cancelWinnerRequest(uint256 prizeId) external onlyRole(ADMIN_ROLE) {
        require(isWinnerRequestPending[prizeId], "No request pending for this prize");
        isWinnerRequestPending[prizeId] = false;
    }


    function getPrizeIds() external view returns (uint256[] memory) {
        return prizeIds;
    }

    struct PrizeWithTickets {
        string name;
        string description;
        uint256 value;
        uint256 endTimestamp;
        bool isActive;
        uint256 quantity;
        uint256 winnersDrawn;
        uint256 totalTickets;
        uint256 totalUsers;
    }


    function getPrizeDetails(uint256 prizeId) external view returns (
        string memory name,
        string memory description,
        uint256 ticketCost,
        bool isActive,
        address winner, // @deprecated
        uint256 winnerIndex, // @deprecated
        uint256 totalUsers,
        bool claimed, // @deprecated
        uint256 quantity,
        uint256 numWinnersDrawn
    ) {
        Prize storage p = prizes[prizeId];
        
        return (
            p.name,
            p.description,
            totalTickets[prizeId],
            p.isActive,
            p.winner,
            p.winnerIndex,
            totalUniqueUsers[prizeId],
            p.claimed,
            p.quantity,
            winnersDrawn[prizeId]
        );
    }

    function getPrizeDetails() external view returns (PrizeWithTickets[] memory) {
        uint256 prizeCount = prizeIds.length;
        PrizeWithTickets[] memory prizeArray = new PrizeWithTickets[](prizeCount);
        
        for (uint256 i = 0; i < prizeCount; i++) {
            uint256 currentPrizeId = prizeIds[i];
            Prize storage currentPrize = prizes[currentPrizeId];
            
            prizeArray[i] = PrizeWithTickets({
                name: currentPrize.name,
                description: currentPrize.description,
                value: currentPrize.value,
                endTimestamp: currentPrize.endTimestamp,
                isActive: currentPrize.isActive,
                quantity: currentPrize.quantity,
                winnersDrawn: winnersDrawn[currentPrizeId],
                totalTickets: totalTickets[currentPrizeId],
                totalUsers: totalUniqueUsers[currentPrizeId]
            });
        }
        
        return prizeArray;
    }
    
    function getPrizeWinners(uint256 prizeId) external view returns (Winner[] memory) {
        return prizeWinners[prizeId];
    }

    function getUserWinnings(address user) external view returns (uint256[] memory) {
        return winnings[user];
    }

    // Timestamp update for prizes
    function updatePrizeEndTimestamp(uint256 prizeId, uint256 endTimestamp) external onlyRole(ADMIN_ROLE) prizeIsActive(prizeId) {
        prizes[prizeId].endTimestamp = endTimestamp;
    }

    /**
     * @notice Set the active status of a prize manually
     * @dev This function is primarily intended for testing and administrative purposes
     * @param prizeId The ID of the prize to modify
     * @param active The new active status to set
     */
    function setPrizeActive(uint256 prizeId, bool active) external onlyRole(ADMIN_ROLE) {
        Prize storage prize = prizes[prizeId];
        require(bytes(prize.name).length != 0, "Prize does not exist");
        if (active) {
            require(winnersDrawn[prizeId] < prize.quantity, "All winners already selected");
        }
        prizes[prizeId].isActive = active;
    }

    // UUPS Authorization
    function _authorizeUpgrade(address newImplementation) internal override onlyRole(ADMIN_ROLE) {}
    
    // Allow contract to receive ETH
    receive() external payable {}
}

// @audit

=== DateTime.sol ===
// SPDX-License-Identifier: UNLICENSED
// github -  https://github.com/pipermerriam/ethereum-datetime
pragma solidity ^0.8.14;

contract DateTime {

    /*
         *  Date and Time utilities for ethereum contracts
         *
         */
    struct _DateTime {
        uint16 year;
        uint8 month;
        uint8 day;
        uint8 hour;
        uint8 minute;
        uint8 second;
        uint8 weekday;
    }

    uint256 constant DAY_IN_SECONDS = 86_400;
    uint256 constant YEAR_IN_SECONDS = 31_536_000;
    uint256 constant LEAP_YEAR_IN_SECONDS = 31_622_400;

    uint256 constant HOUR_IN_SECONDS = 3600;
    uint256 constant MINUTE_IN_SECONDS = 60;

    uint16 constant ORIGIN_YEAR = 1970;

    function isLeapYear(
        uint16 year
    ) public pure returns (bool) {
        if (year % 4 != 0) {
            return false;
        }
        if (year % 100 != 0) {
            return true;
        }
        if (year % 400 != 0) {
            return false;
        }
        return true;
    }

    function leapYearsBefore(
        uint256 year
    ) public pure returns (uint256) {
        year -= 1;
        return year / 4 - year / 100 + year / 400;
    }

    function getDaysInMonth(uint8 month, uint16 year) public pure returns (uint8) {
        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {
            return 31;
        } else if (month == 4 || month == 6 || month == 9 || month == 11) {
            return 30;
        } else if (isLeapYear(year)) {
            return 29;
        } else {
            return 28;
        }
    }

    function parseTimestamp(
        uint256 timestamp
    ) internal pure returns (_DateTime memory dt) {
        uint256 secondsAccountedFor = 0;
        uint256 buf;
        uint8 i;

        // Year
        dt.year = getYear(timestamp);
        buf = leapYearsBefore(dt.year) - leapYearsBefore(ORIGIN_YEAR);

        secondsAccountedFor += LEAP_YEAR_IN_SECONDS * buf;
        secondsAccountedFor += YEAR_IN_SECONDS * (dt.year - ORIGIN_YEAR - buf);

        // Month
        uint256 secondsInMonth;
        for (i = 1; i <= 12; i++) {
            secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, dt.year);
            if (secondsInMonth + secondsAccountedFor > timestamp) {
                dt.month = i;
                break;
            }
            secondsAccountedFor += secondsInMonth;
        }

        // Day
        for (i = 1; i <= getDaysInMonth(dt.month, dt.year); i++) {
            if (DAY_IN_SECONDS + secondsAccountedFor > timestamp) {
                dt.day = i;
                break;
            }
            secondsAccountedFor += DAY_IN_SECONDS;
        }

        // Hour
        dt.hour = getHour(timestamp);

        // Minute
        dt.minute = getMinute(timestamp);

        // Second
        dt.second = getSecond(timestamp);

        // Day of week.
        dt.weekday = getWeekday(timestamp);
    }

    function getYear(
        uint256 timestamp
    ) public pure returns (uint16) {
        uint256 secondsAccountedFor = 0;
        uint16 year;
        uint256 numLeapYears;

        // Year
        year = uint16(ORIGIN_YEAR + timestamp / YEAR_IN_SECONDS);
        numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);

        secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears;
        secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - numLeapYears);

        while (secondsAccountedFor > timestamp) {
            if (isLeapYear(uint16(year - 1))) {
                secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;
            } else {
                secondsAccountedFor -= YEAR_IN_SECONDS;
            }
            year -= 1;
        }
        return year;
    }

    function getMonth(
        uint256 timestamp
    ) public pure returns (uint8) {
        return parseTimestamp(timestamp).month;
    }

    function getDay(
        uint256 timestamp
    ) public pure returns (uint8) {
        return parseTimestamp(timestamp).day;
    }

    function getHour(
        uint256 timestamp
    ) public pure returns (uint8) {
        return uint8((timestamp / 60 / 60) % 24);
    }

    function getMinute(
        uint256 timestamp
    ) public pure returns (uint8) {
        return uint8((timestamp / 60) % 60);
    }

    function getSecond(
        uint256 timestamp
    ) public pure returns (uint8) {
        return uint8(timestamp % 60);
    }

    function getWeekday(
        uint256 timestamp
    ) public pure returns (uint8) {
        return uint8((timestamp / DAY_IN_SECONDS + 4) % 7);
    }

    function toTimestamp(uint16 year, uint8 month, uint8 day) public pure returns (uint256 timestamp) {
        return toTimestamp(year, month, day, 0, 0, 0);
    }

    function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour) public pure returns (uint256 timestamp) {
        return toTimestamp(year, month, day, hour, 0, 0);
    }

    function toTimestamp(
        uint16 year,
        uint8 month,
        uint8 day,
        uint8 hour,
        uint8 minute
    ) public pure returns (uint256 timestamp) {
        return toTimestamp(year, month, day, hour, minute, 0);
    }

    function toTimestamp(
        uint16 year,
        uint8 month,
        uint8 day,
        uint8 hour,
        uint8 minute,
        uint8 second
    ) public pure returns (uint256 timestamp) {
        uint16 i;

        // Year
        for (i = ORIGIN_YEAR; i < year; i++) {
            if (isLeapYear(i)) {
                timestamp += LEAP_YEAR_IN_SECONDS;
            } else {
                timestamp += YEAR_IN_SECONDS;
            }
        }

        // Month
        uint8[12] memory monthDayCounts;
        monthDayCounts[0] = 31;
        if (isLeapYear(year)) {
            monthDayCounts[1] = 29;
        } else {
            monthDayCounts[1] = 28;
        }
        monthDayCounts[2] = 31;
        monthDayCounts[3] = 30;
        monthDayCounts[4] = 31;
        monthDayCounts[5] = 30;
        monthDayCounts[6] = 31;
        monthDayCounts[7] = 31;
        monthDayCounts[8] = 30;
        monthDayCounts[9] = 31;
        monthDayCounts[10] = 30;
        monthDayCounts[11] = 31;

        for (i = 1; i < month; i++) {
            timestamp += DAY_IN_SECONDS * monthDayCounts[i - 1];
        }

        // Day
        timestamp += DAY_IN_SECONDS * (day - 1);

        // Hour
        timestamp += HOUR_IN_SECONDS * (hour);

        // Minute
        timestamp += MINUTE_IN_SECONDS * (minute);

        // Second
        timestamp += second;

        return timestamp;
    }

    function getWeekNumber(
        uint256 timestamp
    ) public pure returns (uint8) {
        _DateTime memory dt = parseTimestamp(timestamp);
        uint16 year = dt.year;
        uint8 month = dt.month;
        uint8 day = dt.day;
        uint8 weekday = getWeekday(timestamp);

        if (weekday == 0) {
            weekday = 7; // Make Sunday (0) as 7
        }

        uint256 daysSinceYearStart = getDaysSinceYearStart(year, month, day);
        uint256 weekNumber = (daysSinceYearStart + 7 - weekday) / 7;

        return uint8(weekNumber);
    }

    function getDaysSinceYearStart(uint16 year, uint8 month, uint8 day) internal pure returns (uint256) {
        uint256 days_ = day;
        for (uint8 m = 1; m < month; m++) {
            days_ += getDaysInMonth(m, year);
        }
        return days_;
    }

}

// @audit

=== PlumeValidatorLogic.sol ===
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.25;

import { PlumeStakingStorage } from "./PlumeStakingStorage.sol";

/**
 * @title PlumeValidatorLogic
 * @author Eugene Y. Q. Shen, Alp Guneysel
 * @notice Internal library containing shared logic for validator management and checks.
 */
library PlumeValidatorLogic {

    using PlumeStakingStorage for PlumeStakingStorage.Layout;

    /**
     * @notice Get validator info from storage
     * @param $ The storage layout reference
     * @param validatorId The ID of the validator to get info for
     * @return The validator info struct
     */
    function getValidatorInfo(
        PlumeStakingStorage.Layout storage $,
        uint16 validatorId
    ) internal view returns (PlumeStakingStorage.ValidatorInfo storage) {
        return $.validators[validatorId];
    }

    /**
     * @notice Check if a validator is active
     * @param $ The storage layout reference
     * @param validatorId The ID of the validator to check
     * @return True if the validator is active, false otherwise
     */
    function isValidatorActive(PlumeStakingStorage.Layout storage $, uint16 validatorId) internal view returns (bool) {
        return $.validators[validatorId].active;
    }

    /**
     * @notice Get the total amount staked with a validator
     * @param $ The storage layout reference
     * @param validatorId The ID of the validator
     * @return The total amount staked with the validator
     */
    function getValidatorTotalStaked(
        PlumeStakingStorage.Layout storage $,
        uint16 validatorId
    ) internal view returns (uint256) {
        return $.validatorTotalStaked[validatorId];
    }

    /**
     * @notice Adds a staker to the validator's list and the user's validator list if not already present.
     * @dev Also ensures the staker is added to the global stakers list if they are new.
     * @param $ The PlumeStaking storage layout.
     * @param staker The address of the staker.
     * @param validatorId The ID of the validator.
     */
    function addStakerToValidator(PlumeStakingStorage.Layout storage $, address staker, uint16 validatorId) internal {
        if (!$.userHasStakedWithValidator[staker][validatorId]) {
            $.userValidators[staker].push(validatorId);
            $.userHasStakedWithValidator[staker][validatorId] = true;
        }

        if (!$.isStakerForValidator[validatorId][staker]) {
            // === Store index before pushing ===
            uint256 index = $.validatorStakers[validatorId].length;
            $.validatorStakers[validatorId].push(staker);
            $.isStakerForValidator[validatorId][staker] = true;
            $.userIndexInValidatorStakers[staker][validatorId] = index; // <<< Store the index
        }
    }

    /**
     * @notice Removes a staker from the validator's list if they have no stake left with this validator.
     * @dev This should be called after unstaking when a user's stake with a validator reaches zero.
     * @param $ The PlumeStaking storage layout.
     * @param staker The address of the staker.
     * @param validatorId The ID of the validator.
     */
    function removeStakerFromValidator(
        PlumeStakingStorage.Layout storage $,
        address staker,
        uint16 validatorId
    ) internal {
        // Part 1: Manage $.validatorStakers list (validator's list of its ACTIVE stakers)
        // This runs if active stake with this validator becomes zero AND they were previously listed as an active
        // staker for it.
        if ($.userValidatorStakes[staker][validatorId].staked == 0 && $.isStakerForValidator[validatorId][staker]) {
            address[] storage stakersList = $.validatorStakers[validatorId];
            uint256 listLength = stakersList.length;
            if (listLength > 0) {
                uint256 indexToRemove = $.userIndexInValidatorStakers[staker][validatorId];
                if (indexToRemove < listLength && stakersList[indexToRemove] == staker) {
                    address lastStaker = stakersList[listLength - 1];
                    if (indexToRemove != listLength - 1) {
                        stakersList[indexToRemove] = lastStaker;
                        $.userIndexInValidatorStakers[lastStaker][validatorId] = indexToRemove;
                    }
                    stakersList.pop();
                }
            }
            $.isStakerForValidator[validatorId][staker] = false; // Correctly marks they are no longer an ACTIVE staker
                // for this validator
            delete $.userIndexInValidatorStakers[staker][validatorId];
        }

        // Part 2: Manage $.userValidators list (user's list of ANY association with a validator)
        // This runs if active stake for this validator is zero AND their cooldown amount for this validator is zero
        // AND they have no pending rewards for this validator.
        bool hasActiveStakeForThisVal = $.userValidatorStakes[staker][validatorId].staked > 0;
        bool hasActiveCooldownForThisVal = $.userValidatorCooldowns[staker][validatorId].amount > 0;

        // Use the pending rewards flag which handles both current and removed tokens
        bool hasPendingRewardsForThisVal = $.userHasPendingRewards[staker][validatorId];


        if (!hasActiveStakeForThisVal && !hasActiveCooldownForThisVal && !hasPendingRewardsForThisVal) {
            if ($.userHasStakedWithValidator[staker][validatorId]) {
                // Check if they are currently in the userValidators list (via this mapping)
                uint16[] storage userValidators_ = $.userValidators[staker];

                bool removed = false;
                for (uint256 i = 0; i < userValidators_.length; i++) {
                    if (userValidators_[i] == validatorId) {
                        // Swap with last and pop
                        userValidators_[i] = userValidators_[userValidators_.length - 1];
                        userValidators_.pop();
                        removed = true;

                        break;
                    }
                }
                // Only set userHasStakedWithValidator to false if it was actually removed or if the list is now empty
                // for this validator
                // This mapping essentially tracks if the validatorId should be in $.userValidators[staker]
                if (removed) {
                    // Or if after potential pop, the validator is no longer findable.
                    $.userHasStakedWithValidator[staker][validatorId] = false;
                } else { }
            } else { }
        }
    }

    /**
     * @notice Removes a staker from all validators where they have no remaining involvement
     * @dev This checks all validators the user has ever staked with and cleans up relationships
     *      where they have no active stake, cooldown, or pending rewards
     * @param $ The PlumeStaking storage layout.
     * @param staker The address of the staker.
     */
    function removeStakerFromAllValidators(PlumeStakingStorage.Layout storage $, address staker) internal {
        // Make a copy to avoid iteration issues when removeStakerFromValidator is called
        uint16[] memory userAssociatedValidators = $.userValidators[staker];

        for (uint256 i = 0; i < userAssociatedValidators.length; i++) {
            uint16 validatorId = userAssociatedValidators[i];
            if ($.userValidatorStakes[staker][validatorId].staked == 0) {
                removeStakerFromValidator($, staker, validatorId);
            }
        }
    }

}

// @audit