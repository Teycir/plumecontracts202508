=== ArcToken.sol ===
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.25;

import "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol";
import "@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol";

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";

import "./restrictions/IRestrictionsRouter.sol";
import "./restrictions/ITransferRestrictions.sol";
import "./restrictions/IYieldRestrictions.sol";
import "./restrictions/RestrictionTypes.sol";

/**
 * @title ArcToken
 * @author Eugene Y. Q. Shen, Alp Guneysel
 * @notice ERC20 token representing shares, delegating restriction logic to external modules via a router.
 * @dev Implements ERC20Upgradeable. Uses UUPS. Restriction checks are modular.
 */
contract ArcToken is ERC20Upgradeable, AccessControlUpgradeable, ReentrancyGuardUpgradeable, UUPSUpgradeable {

    using SafeERC20 for ERC20Upgradeable;
    using EnumerableSet for EnumerableSet.AddressSet;

    // -------------- Role Definitions --------------
    bytes32 public constant ADMIN_ROLE = keccak256("ADMIN_ROLE");
    bytes32 public constant MANAGER_ROLE = keccak256("MANAGER_ROLE");
    bytes32 public constant YIELD_MANAGER_ROLE = keccak256("YIELD_MANAGER_ROLE");
    bytes32 public constant YIELD_DISTRIBUTOR_ROLE = keccak256("YIELD_DISTRIBUTOR_ROLE");
    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");
    bytes32 public constant BURNER_ROLE = keccak256("BURNER_ROLE");
    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER_ROLE");

    // -------------- Custom Errors --------------
    error YieldTokenNotSet();
    error NoTokensInCirculation();
    error InvalidYieldTokenAddress();
    error IssuePriceMustBePositive();
    error InvalidAddress();
    error TransferRestricted();
    error YieldDistributionRestricted();
    error ZeroAmount();
    error ModuleNotSetForType(bytes32 typeId);
    error RouterNotSet();

    // -------------- Storage --------------
    /// @custom:storage-location erc7201:asset.token.storage
    struct ArcTokenStorage {
        address restrictionsRouter;
        address yieldToken;
        EnumerableSet.AddressSet holders;
        string tokenURI;
        string updatedSymbol;
        string updatedName;
        uint8 tokenDecimals;
        mapping(bytes32 => address) specificRestrictionModules;
    }

    bytes32 private constant ARC_TOKEN_STORAGE_LOCATION =
        0xf52c08b2e4132efdd78c079b339999bf65bd68aae758ed08b1bb84dc8f47c000;

    function _getArcTokenStorage() private pure returns (ArcTokenStorage storage $) {
        assembly {
            $.slot := ARC_TOKEN_STORAGE_LOCATION
        }
    }

    // -------------- Events --------------
    event YieldDistributed(uint256 amount, address indexed token);
    event YieldTokenUpdated(address indexed newYieldToken);
    event TokenNameUpdated(string oldName, string newName);
    event TokenURIUpdated(string newTokenURI);
    event SymbolUpdated(string oldSymbol, string newSymbol);
    event SpecificRestrictionModuleSet(bytes32 indexed typeId, address indexed moduleAddress);

    // -------------- Initializer --------------
    /**
     * @dev Initialize the token with name, symbol, and supply.
     *      The deployer becomes the default admin.
     * @param name_ Token name (e.g., "Mineral Vault Fund I")
     * @param symbol_ Token symbol (e.g., "aMNRL")
     * @param initialSupply_ Initial token supply to mint to the admin
     * @param yieldToken_ Address of the ERC20 token for yield distribution.
     * @param initialTokenHolder_ Address that will receive the initial token supply
     * @param decimals_ Number of decimal places for the token (default is 18 if 0 is provided)
     * @param routerAddress_ Address of the deployed RestrictionsRouter proxy.
     */
    function initialize(
        string memory name_,
        string memory symbol_,
        uint256 initialSupply_,
        address yieldToken_,
        address initialTokenHolder_,
        uint8 decimals_,
        address routerAddress_
    ) public initializer {
        require(routerAddress_ != address(0), "Router address cannot be zero");

        __ERC20_init(name_, symbol_);
        __AccessControl_init();
        __UUPSUpgradeable_init();
        __ReentrancyGuard_init();

        ArcTokenStorage storage $ = _getArcTokenStorage();

        $.restrictionsRouter = routerAddress_;

        $.tokenDecimals = decimals_ == 0 ? 18 : decimals_;

        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(ADMIN_ROLE, msg.sender);
        _grantRole(MANAGER_ROLE, msg.sender);
        _grantRole(YIELD_MANAGER_ROLE, msg.sender);
        _grantRole(YIELD_DISTRIBUTOR_ROLE, msg.sender);

        $.holders.add(msg.sender);
        if (initialTokenHolder_ != msg.sender && initialTokenHolder_ != address(0)) {
            $.holders.add(initialTokenHolder_);
        }

        if (yieldToken_ != address(0)) {
            $.yieldToken = yieldToken_;
            emit YieldTokenUpdated(yieldToken_);
        }

        if (initialSupply_ > 0) {
            address recipient = initialTokenHolder_ != address(0) ? initialTokenHolder_ : msg.sender;
            _mint(recipient, initialSupply_);
        }
    }

    // -------------- Restrictions Module Management --------------
    /**
     * @dev Sets the address of a restriction module instance for this token.
     * @notice The router must have a module type registered for this typeId with isGlobal = false.
     * @param typeId The unique identifier for the module type (e.g., TRANSFER_RESTRICTION_TYPE).
     * @param moduleAddress The address of the deployed module instance (e.g., WhitelistRestrictions).
     */
    function setRestrictionModule(bytes32 typeId, address moduleAddress) external onlyRole(ADMIN_ROLE) {
        _getArcTokenStorage().specificRestrictionModules[typeId] = moduleAddress;
        emit SpecificRestrictionModuleSet(typeId, moduleAddress);
    }

    /**
     * @dev Returns the address of the restriction module instance for a given type.
     * @param typeId The unique identifier for the module type.
     */
    function getRestrictionModule(
        bytes32 typeId
    ) external view returns (address) {
        return _getArcTokenStorage().specificRestrictionModules[typeId];
    }

    // -------------- Asset Information --------------
    /**
     * @dev Update the token name. Only accounts with MANAGER_ROLE can update this.
     * @param newName The new name for the token
     */
    function updateTokenName(
        string memory newName
    ) external onlyRole(MANAGER_ROLE) {
        ArcTokenStorage storage $ = _getArcTokenStorage();
        string memory oldName = name();
        $.updatedName = newName;
        emit TokenNameUpdated(oldName, newName);
    }

    // -------------- Minting and Burning --------------
    /**
     * @dev Mints new tokens to an account. Only accounts with MINTER_ROLE can call this.
     */
    function mint(address to, uint256 amount) external onlyRole(MINTER_ROLE) {
        _mint(to, amount);
    }

    /**
     * @dev Burns tokens from an account, reducing the total supply. Only accounts with BURNER_ROLE can call this.
     */
    function burn(address from, uint256 amount) external onlyRole(BURNER_ROLE) {
        _burn(from, amount);
    }

    // -------------- Yield Distribution --------------
    /**
     * @dev Sets or updates the ERC20 token to use for yield distribution (e.g., USDC).
     * Only accounts with YIELD_MANAGER_ROLE can update this.
     */
    function setYieldToken(
        address yieldTokenAddr
    ) external onlyRole(YIELD_MANAGER_ROLE) {
        if (yieldTokenAddr == address(0)) {
            revert InvalidYieldTokenAddress();
        }
        _getArcTokenStorage().yieldToken = yieldTokenAddr;
        emit YieldTokenUpdated(yieldTokenAddr);
    }

    /**
     * @dev Helper function to check all relevant yield restrictions for an account.
     */
    function _isYieldAllowed(
        address account
    ) internal view returns (bool) {
        ArcTokenStorage storage $ = _getArcTokenStorage();
        bool allowed = true;

        address specificYieldModule = $.specificRestrictionModules[RestrictionTypes.YIELD_RESTRICTION_TYPE];
        if (specificYieldModule != address(0)) {
            allowed = allowed && IYieldRestrictions(specificYieldModule).isYieldAllowed(account);
        }

        address routerAddr = $.restrictionsRouter;
        if (routerAddr == address(0)) {
            revert RouterNotSet();
        }
        address globalYieldModule = IRestrictionsRouter(routerAddr).getGlobalModuleAddress(RestrictionTypes.GLOBAL_SANCTIONS_TYPE);
        if (globalYieldModule != address(0)) {
            try IYieldRestrictions(globalYieldModule).isYieldAllowed(account) returns (bool globalAllowed) {
                allowed = allowed && globalAllowed;
            } catch {
                // If global module doesn't implement IYieldRestrictions or call fails, treat as restricted?
                // Or handle based on specific global module design.
                // Current: Assume allowed if call fails/not implemented (less restrictive).
            }
        }

        return allowed;
    }

    /**
     * @dev Get a preview of the yield distribution for token holders.
     *      Accounts restricted by yield modules will show a share of 0.
     */
    function previewYieldDistribution(
        uint256 amount
    ) external view returns (address[] memory holders, uint256[] memory amounts) {
        ArcTokenStorage storage $ = _getArcTokenStorage();

        if (amount == 0) {
            revert ZeroAmount();
        }

        uint256 supply = totalSupply();
        if (supply == 0) {
            revert NoTokensInCirculation();
        }

        uint256 holderCount = $.holders.length();
        if (holderCount == 0) {
            return (new address[](0), new uint256[](0));
        }

        holders = new address[](holderCount);
        amounts = new uint256[](holderCount);

        uint256 totalPreviewAmount = 0;
        uint256 effectiveTotalSupply = 0;

        for (uint256 i = 0; i < holderCount; i++) {
            address holder = $.holders.at(i);
            if (_isYieldAllowed(holder)) {
                effectiveTotalSupply += balanceOf(holder);
            }
        }

        if (effectiveTotalSupply == 0) {
            return (holders, amounts);
        }

        uint256 lastProcessedIndex = holderCount > 0 ? holderCount - 1 : 0;
        for (uint256 i = 0; i < lastProcessedIndex; i++) {
            address holder = $.holders.at(i);
            holders[i] = holder;

            if (!_isYieldAllowed(holder)) {
                amounts[i] = 0;
                continue;
            }

            uint256 holderBalance = balanceOf(holder);
            if (holderBalance > 0) {
                uint256 share = (amount * holderBalance) / effectiveTotalSupply;
                amounts[i] = share;
                totalPreviewAmount += share;
            } else {
                amounts[i] = 0;
            }
        }

        if (holderCount > 0) {
            address lastHolder = $.holders.at(lastProcessedIndex);
            holders[lastProcessedIndex] = lastHolder;

            if (!_isYieldAllowed(lastHolder)) {
                amounts[lastProcessedIndex] = 0;
            } else {
                amounts[lastProcessedIndex] = amount - totalPreviewAmount;
            }
        }

        return (holders, amounts);
    }

    /**
     * @dev Distribute yield to token holders, skipping restricted accounts.
     *      Yield for restricted accounts remains in the contract.
     */
    function distributeYield(
        uint256 amount
    ) external onlyRole(YIELD_DISTRIBUTOR_ROLE) nonReentrant {
        ArcTokenStorage storage $ = _getArcTokenStorage();

        if (amount == 0) {
            revert ZeroAmount();
        }

        uint256 supply = totalSupply();
        if (supply == 0) {
            revert NoTokensInCirculation();
        }

        address yieldTokenAddr = $.yieldToken;
        if (yieldTokenAddr == address(0)) {
            revert YieldTokenNotSet();
        }

        ERC20Upgradeable yToken = ERC20Upgradeable(yieldTokenAddr);
        yToken.safeTransferFrom(msg.sender, address(this), amount);

        uint256 distributedSum = 0;
        uint256 holderCount = $.holders.length();
        if (holderCount == 0) {
            emit YieldDistributed(0, yieldTokenAddr);
            return;
        }

        uint256 effectiveTotalSupply = 0;
        for (uint256 i = 0; i < holderCount; i++) {
            address holder = $.holders.at(i);
            if (_isYieldAllowed(holder)) {
                effectiveTotalSupply += balanceOf(holder);
            }
        }

        if (effectiveTotalSupply == 0) {
            emit YieldDistributed(0, yieldTokenAddr);
            return;
        }

        uint256 lastProcessedIndex = holderCount > 0 ? holderCount - 1 : 0;
        for (uint256 i = 0; i < lastProcessedIndex; i++) {
            address holder = $.holders.at(i);

            if (!_isYieldAllowed(holder)) {
                continue;
            }

            uint256 holderBalance = balanceOf(holder);
            if (holderBalance > 0) {
                uint256 share = (amount * holderBalance) / effectiveTotalSupply;
                if (share > 0) {
                    yToken.safeTransfer(holder, share);
                    distributedSum += share;
                }
            }
        }

        if (holderCount > 0) {
            address lastHolder = $.holders.at(lastProcessedIndex);
            if (_isYieldAllowed(lastHolder)) {
                uint256 lastShare = amount - distributedSum;
                if (lastShare > 0) {
                    yToken.safeTransfer(lastHolder, lastShare);
                    distributedSum += lastShare;
                }
            }
        }

        emit YieldDistributed(distributedSum, yieldTokenAddr);
    }

    // -------------- URI Management --------------
    /**
     * @dev Returns the URI for token metadata.
     */
    function uri() public view returns (string memory) {
        return _getArcTokenStorage().tokenURI;
    }

    /**
     * @dev Sets the complete token URI. Only callable by MANAGER_ROLE.
     * @param newTokenURI The full URI including domain
     */
    function setTokenURI(
        string memory newTokenURI
    ) external onlyRole(MANAGER_ROLE) {
        _getArcTokenStorage().tokenURI = newTokenURI;
        emit TokenURIUpdated(newTokenURI);
    }

    // -------------- Token Metadata Management --------------
    /**
     * @dev Updates the token symbol. Only accounts with MANAGER_ROLE can update this.
     * @param newSymbol The new symbol for the token
     */
    function updateTokenSymbol(
        string memory newSymbol
    ) external onlyRole(MANAGER_ROLE) {
        ArcTokenStorage storage $ = _getArcTokenStorage();
        string memory oldSymbol = symbol();
        $.updatedSymbol = newSymbol;
        emit SymbolUpdated(oldSymbol, newSymbol);
    }

    /**
     * @dev Returns the decimals places of the token.
     * @return The number of decimals places configured for this token
     */
    function decimals() public view override returns (uint8) {
        return _getArcTokenStorage().tokenDecimals;
    }

    /**
     * @dev Returns the name of the token.
     * @return The token name
     */
    function name() public view override returns (string memory) {
        string memory updatedName = _getArcTokenStorage().updatedName;
        if (bytes(updatedName).length > 0) {
            return updatedName;
        }
        return super.name();
    }

    /**
     * @dev Returns the symbol of the token.
     * @return The token symbol
     */
    function symbol() public view override returns (string memory) {
        string memory updatedSymbol = _getArcTokenStorage().updatedSymbol;
        if (bytes(updatedSymbol).length > 0) {
            return updatedSymbol;
        }
        return super.symbol();
    }

    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(
        bytes4 interfaceId
    ) public view override(AccessControlUpgradeable) returns (bool) {
        return super.supportsInterface(interfaceId);
    }

    /**
     * @dev Authorization for upgrades
     */
    function _authorizeUpgrade(
        address newImplementation
    ) internal override onlyRole(UPGRADER_ROLE) { }

    // Override _update to track holders and enforce transfer restrictions via router/modules
    function _update(address from, address to, uint256 amount) internal virtual override {
        ArcTokenStorage storage $ = _getArcTokenStorage();

        bool transferAllowed = true;

        address routerAddr = $.restrictionsRouter;
        if (routerAddr == address(0)) {
            revert RouterNotSet();
        }

        address specificTransferModule = $.specificRestrictionModules[RestrictionTypes.TRANSFER_RESTRICTION_TYPE];
        if (specificTransferModule != address(0)) {
            transferAllowed =
                transferAllowed && ITransferRestrictions(specificTransferModule).isTransferAllowed(from, to, amount);
        }

        address globalTransferModule = IRestrictionsRouter(routerAddr).getGlobalModuleAddress(RestrictionTypes.GLOBAL_SANCTIONS_TYPE);
        if (globalTransferModule != address(0)) {
            try ITransferRestrictions(globalTransferModule).isTransferAllowed(from, to, amount) returns (
                bool globalAllowed
            ) {
                transferAllowed = transferAllowed && globalAllowed;
            } catch {
                transferAllowed = false;
            }
        }

        if (!transferAllowed) {
            revert TransferRestricted();
        }

        if (specificTransferModule != address(0)) {
            ITransferRestrictions(specificTransferModule).beforeTransfer(from, to, amount);
        }
        if (globalTransferModule != address(0)) {
            try ITransferRestrictions(globalTransferModule).beforeTransfer(from, to, amount) { }
                catch { /* Ignore if hook not implemented or fails? */ }
        }

        if (from != address(0)) {
            uint256 fromBalanceBefore = balanceOf(from);
            if (fromBalanceBefore == amount) {
                $.holders.remove(from);
            }
        }

        super._update(from, to, amount);

        if (to != address(0) && balanceOf(to) > 0) {
            $.holders.add(to);
        }

        if (specificTransferModule != address(0)) {
            ITransferRestrictions(specificTransferModule).afterTransfer(from, to, amount);
        }
        if (globalTransferModule != address(0)) {
            try ITransferRestrictions(globalTransferModule).afterTransfer(from, to, amount) { }
                catch { /* Ignore if hook not implemented or fails? */ }
        }
    }

}

// @audit
=== ArcTokenFactory.sol ===
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.25;

import "./ArcToken.sol";
import "./proxy/ArcTokenProxy.sol";

import "./restrictions/IRestrictionsRouter.sol";
import "./restrictions/ITransferRestrictions.sol";
import "./restrictions/IYieldRestrictions.sol";
import "./restrictions/WhitelistRestrictions.sol";
import "./restrictions/YieldBlacklistRestrictions.sol";
import "./restrictions/RestrictionTypes.sol";

import "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import { ERC1967Proxy } from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";

/**
 * @title ArcTokenFactory
 * @author Eugene Y. Q. Shen, Alp Guneysel
 * @notice Factory contract for creating new ArcToken instances and their associated restriction modules.
 * @dev Uses ERC1967 proxy pattern for upgradeable tokens. Requires a RestrictionsRouter.
 */
contract ArcTokenFactory is Initializable, AccessControlUpgradeable, UUPSUpgradeable {

    /// @custom:storage-location erc7201:arc.factory.storage
    struct FactoryStorage {
        // --- Data associated with the Factory itself ---
        address restrictionsRouter; // Store router address here as well
        mapping(bytes32 => bool) allowedImplementations; // Allowed ArcToken implementations
        // --- Data associated with TOKENS created by this factory ---
        // Maps token proxies to their implementations
        mapping(address => address) tokenToImplementation;
    }
    // Maps tokens to their restriction modules (Type => Module Address)
    // We might still want factory-level tracking if needed, but ArcToken is the source of truth.

    // Custom errors
    error ImplementationNotWhitelisted();
    error TokenNotCreatedByFactory();
    error RouterNotSet();
    error FailedToCreateRestrictionsModule();
    error FailedToSetRestrictions();

    // Events
    event TokenCreated(
        address indexed tokenAddress,
        address indexed owner,
        address indexed implementation,
        string name,
        string symbol,
        string tokenUri,
        uint8 decimals
    );
    event ModuleLinked(address indexed tokenAddress, address indexed moduleAddress, bytes32 indexed moduleType);
    event ImplementationWhitelisted(address indexed implementation);
    event ImplementationRemoved(address indexed implementation);
    event TokenUpgraded(address indexed token, address indexed newImplementation);

    // Calculate unique storage slot
    bytes32 private constant FACTORY_STORAGE_LOCATION = keccak256("arc.factory.storage");

    function _getFactoryStorage() private pure returns (FactoryStorage storage fs) {
        bytes32 position = FACTORY_STORAGE_LOCATION;
        assembly {
            fs.slot := position
        }
    }

    /**
     * @dev Initialize the factory with the address of the RestrictionsRouter.
     * @param routerAddress The address of the deployed RestrictionsRouter proxy.
     */
    function initialize(
        address routerAddress
    ) public initializer {
        require(routerAddress != address(0), "Router address cannot be zero");
        __AccessControl_init();
        __UUPSUpgradeable_init();

        FactoryStorage storage fs = _getFactoryStorage();
        fs.restrictionsRouter = routerAddress; // Store router address

        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }

    /**
     * @dev Internal function to create and initialize a WhitelistRestrictions module.
     * @param admin Address that will have admin privileges on the restrictions module
     * @return Address of the newly created restrictions module
     */
    function _createWhitelistRestrictionsModule(
        address admin
    ) internal returns (address) {
        // Deploy a fresh whitelist restrictions implementation
        WhitelistRestrictions implementation = new WhitelistRestrictions();

        // Prepare initialization data
        bytes memory initData = abi.encodeWithSelector(WhitelistRestrictions.initialize.selector, admin);

        // Deploy and initialize the module behind a proxy
        try new ERC1967Proxy(address(implementation), initData) returns (ERC1967Proxy proxy) {
            return address(proxy);
        } catch {
            revert FailedToCreateRestrictionsModule();
        }
    }

    /**
     * @dev Internal function to create and initialize a YieldBlacklistRestrictions module.
     * @param admin Address that will have admin privileges on the restrictions module
     * @return Address of the newly created restrictions module
     */
    function _createYieldBlacklistRestrictionsModule(
        address admin
    ) internal returns (address) {
        // Deploy a fresh yield blacklist restrictions implementation
        YieldBlacklistRestrictions implementation = new YieldBlacklistRestrictions();

        // Prepare initialization data
        bytes memory initData = abi.encodeWithSelector(YieldBlacklistRestrictions.initialize.selector, admin);

        // Deploy and initialize the module behind a proxy
        try new ERC1967Proxy(address(implementation), initData) returns (ERC1967Proxy proxy) {
            return address(proxy);
        } catch {
            revert FailedToCreateRestrictionsModule();
        }
    }

    /**
     * @dev Creates a new ArcToken instance with its own implementation and associated restriction modules.
     * @param name Token name
     * @param symbol Token symbol
     * @param initialSupply Initial token supply
     * @param yieldToken Address of the yield token (e.g., USDC)
     * @param tokenUri URI for the token metadata
     * @param initialTokenHolder Address that will receive the initial token supply (if address(0), defaults to
     * msg.sender)
     * @param decimals Number of decimal places for the token (default is 18 if 0 is provided)
     * @return Address of the newly created token
     */
    function createToken(
        string memory name,
        string memory symbol,
        uint256 initialSupply,
        address yieldToken,
        string memory tokenUri,
        address initialTokenHolder,
        uint8 decimals
    ) external returns (address) {
        FactoryStorage storage fs = _getFactoryStorage();
        address routerAddr = fs.restrictionsRouter;
        if (routerAddr == address(0)) {
            revert RouterNotSet(); // Ensure factory is initialized with router
        }

        // Deploy a fresh implementation for this token
        ArcToken implementation = new ArcToken();

        // Add the implementation to the whitelist for future upgrades
        bytes32 codeHash = _getCodeHash(address(implementation));
        fs.allowedImplementations[codeHash] = true;

        // Use caller as token holder if not specified
        address tokenHolder = initialTokenHolder == address(0) ? msg.sender : initialTokenHolder;

        // Create initialization data with specified decimals
        bytes memory initData = abi.encodeWithSelector(
            ArcToken.initialize.selector, // Use the main initializer
            name,
            symbol,
            initialSupply,
            yieldToken,
            tokenHolder,
            decimals,
            routerAddr
        );

        // Deploy proxy with the fresh implementation
        ArcTokenProxy proxy = new ArcTokenProxy(address(implementation), initData);

        // Store the mapping between token and its implementation
        fs.tokenToImplementation[address(proxy)] = address(implementation);

        // Set the token URI
        ArcToken token = ArcToken(address(proxy));
        token.setTokenURI(tokenUri);

        // Grant all necessary roles to the owner
        // Grant the DEFAULT_ADMIN_ROLE to the deployer
        token.grantRole(token.DEFAULT_ADMIN_ROLE(), msg.sender);
        token.grantRole(token.ADMIN_ROLE(), msg.sender);
        token.grantRole(token.MANAGER_ROLE(), msg.sender);
        token.grantRole(token.YIELD_MANAGER_ROLE(), msg.sender);
        token.grantRole(token.YIELD_DISTRIBUTOR_ROLE(), msg.sender);
        token.grantRole(token.MINTER_ROLE(), msg.sender);
        token.grantRole(token.BURNER_ROLE(), msg.sender);
        token.grantRole(token.UPGRADER_ROLE(), address(this));

        // --- Create and link Restriction Modules ---

        // 1. Whitelist Module (for transfers)
        address whitelistModule = _createWhitelistRestrictionsModule(msg.sender);
        try token.setRestrictionModule(RestrictionTypes.TRANSFER_RESTRICTION_TYPE, whitelistModule) {
            emit ModuleLinked(address(proxy), whitelistModule, RestrictionTypes.TRANSFER_RESTRICTION_TYPE);
        } catch {
            revert FailedToSetRestrictions();
        }

        // 2. Yield Blacklist Module
        address yieldBlacklistModule = _createYieldBlacklistRestrictionsModule(msg.sender);
        try token.setRestrictionModule(RestrictionTypes.YIELD_RESTRICTION_TYPE, yieldBlacklistModule) {
            emit ModuleLinked(address(proxy), yieldBlacklistModule, RestrictionTypes.YIELD_RESTRICTION_TYPE);
        } catch {
            revert FailedToSetRestrictions();
        }

        emit TokenCreated(address(proxy), msg.sender, address(implementation), name, symbol, tokenUri, decimals);
        emit ImplementationWhitelisted(address(implementation));

        return address(proxy);
    }

    /**
     * @dev Helper function to get code hash of an address
     */
    function _getCodeHash(
        address addr
    ) internal view returns (bytes32 codeHash) {
        assembly {
            codeHash := extcodehash(addr)
        }
    }

    /**
     * @dev Get the implementation address for a specific token
     * @param token Address of the token
     * @return The implementation address for this token
     */
    function getTokenImplementation(
        address token
    ) external view returns (address) {
        return _getFactoryStorage().tokenToImplementation[token];
    }

    /**
     * @dev Get the address of the RestrictionsRouter
     * @return The address of the RestrictionsRouter
     */
    function getRestrictionsRouter() external view returns (address) {
        return _getFactoryStorage().restrictionsRouter;
    }

    /**
     * @dev Upgrades a token to a new implementation
     * @param token Token address to upgrade
     * @param newImplementation Address of the new implementation
     */
    function upgradeToken(address token, address newImplementation) external onlyRole(DEFAULT_ADMIN_ROLE) {
        FactoryStorage storage fs = _getFactoryStorage();

        // Ensure the token was created by this factory
        if (fs.tokenToImplementation[token] == address(0)) {
            revert TokenNotCreatedByFactory();
        }

        // Ensure the new implementation is whitelisted
        bytes32 codeHash = _getCodeHash(newImplementation);
        if (!fs.allowedImplementations[codeHash]) {
            revert ImplementationNotWhitelisted();
        }

        // Perform the upgrade (this assumes the token implements UUPSUpgradeable)
        UUPSUpgradeable(token).upgradeToAndCall(newImplementation, "");

        // Update the implementation mapping
        fs.tokenToImplementation[token] = newImplementation;

        emit TokenUpgraded(token, newImplementation);
    }

    /**
     * @dev Adds a new implementation to the whitelist
     * @param newImplementation Address of the new implementation
     */
    function whitelistImplementation(
        address newImplementation
    ) external onlyRole(DEFAULT_ADMIN_ROLE) {
        FactoryStorage storage fs = _getFactoryStorage();
        bytes32 codeHash = _getCodeHash(newImplementation);
        fs.allowedImplementations[codeHash] = true;
        emit ImplementationWhitelisted(newImplementation);
    }

    /**
     * @dev Removes an implementation from the whitelist
     * @param implementation Address of the implementation to remove
     */
    function removeWhitelistedImplementation(
        address implementation
    ) external onlyRole(DEFAULT_ADMIN_ROLE) {
        FactoryStorage storage fs = _getFactoryStorage();
        bytes32 codeHash = _getCodeHash(implementation);
        fs.allowedImplementations[codeHash] = false;
        emit ImplementationRemoved(implementation);
    }

    /**
     * @dev Checks if an implementation is whitelisted
     * @param implementation Address of the implementation to check
     * @return bool True if implementation is whitelisted
     */
    function isImplementationWhitelisted(
        address implementation
    ) external view returns (bool) {
        FactoryStorage storage fs = _getFactoryStorage();
        bytes32 codeHash = _getCodeHash(implementation);
        return fs.allowedImplementations[codeHash];
    }

    /**
     * @dev Authorization for upgrades
     */
    function _authorizeUpgrade(
        address newImplementation
    ) internal override onlyRole(DEFAULT_ADMIN_ROLE) { }

}

// @audit
=== YieldBlacklistRestrictions.sol ===
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.25;

import "./IYieldRestrictions.sol";
import "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";

/**
 * @title YieldBlacklistRestrictions
 * @author Alp Guneysel
 * @notice Module to manage yield distribution restrictions based on a blacklist.
 * @dev Implements IYieldRestrictions. Uses OZ AccessControl for role management.
 */
contract YieldBlacklistRestrictions is Initializable, AccessControlUpgradeable, UUPSUpgradeable, IYieldRestrictions {

    // Role for managing the blacklist
    bytes32 public constant YIELD_BLACKLIST_ADMIN_ROLE = keccak256("YIELD_BLACKLIST_ADMIN_ROLE");
    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER_ROLE"); // For UUPS

    // Mapping for yield blacklist (address => true if blacklisted)
    mapping(address => bool) private _isBlacklisted;

    // Event emitted when an address's blacklist status changes
    event YieldBlacklistUpdated(address indexed account, bool isBlacklisted);

    // Custom Errors
    error InvalidAddress();
    error AlreadyBlacklisted();
    error NotBlacklisted();

    /**
     * @dev Initializes the contract, setting the initial admin for the blacklist.
     * @param admin The address to be granted the initial YIELD_BLACKLIST_ADMIN_ROLE.
     */
    function initialize(
        address admin
    ) public initializer {
        __AccessControl_init();
        __UUPSUpgradeable_init();

        _grantRole(DEFAULT_ADMIN_ROLE, admin); // Default admin can manage roles
        _grantRole(YIELD_BLACKLIST_ADMIN_ROLE, admin);
        _grantRole(UPGRADER_ROLE, admin); // Admin can upgrade
    }

    // -------------- Blacklist Management --------------

    /**
     * @dev Adds an account to the yield blacklist.
     *      Blacklisted accounts will not receive yield distributions.
     *      Only accounts with YIELD_BLACKLIST_ADMIN_ROLE can call this.
     * @param account The address to add to the blacklist.
     */
    function addToBlacklist(
        address account
    ) external onlyRole(YIELD_BLACKLIST_ADMIN_ROLE) {
        if (account == address(0)) {
            revert InvalidAddress();
        }
        if (_isBlacklisted[account]) {
            revert AlreadyBlacklisted();
        }
        _isBlacklisted[account] = true;
        emit YieldBlacklistUpdated(account, true);
    }

    /**
     * @dev Adds multiple accounts to the yield blacklist.
     * @param accounts Addresses to add.
     */
    function batchAddToBlacklist(
        address[] calldata accounts
    ) external onlyRole(YIELD_BLACKLIST_ADMIN_ROLE) {
        for (uint256 i = 0; i < accounts.length; i++) {
            address account = accounts[i];
            if (account != address(0) && !_isBlacklisted[account]) {
                _isBlacklisted[account] = true;
                emit YieldBlacklistUpdated(account, true);
            }
        }
    }

    /**
     * @dev Removes an account from the yield blacklist.
     *      Only accounts with YIELD_BLACKLIST_ADMIN_ROLE can call this.
     * @param account The address to remove from the blacklist.
     */
    function removeFromBlacklist(
        address account
    ) external onlyRole(YIELD_BLACKLIST_ADMIN_ROLE) {
        if (account == address(0)) {
            revert InvalidAddress();
        }
        if (!_isBlacklisted[account]) {
            revert NotBlacklisted();
        }
        _isBlacklisted[account] = false;
        emit YieldBlacklistUpdated(account, false);
    }

    // -------------- IYieldRestrictions Implementation --------------

    /**
     * @dev Checks if an account is allowed to receive yield (i.e., not blacklisted).
     * @param account The address to check.
     * @return bool True if the account is allowed yield (not blacklisted), false otherwise.
     */
    function isYieldAllowed(
        address account
    ) external view override returns (bool) {
        return !_isBlacklisted[account];
    }

    // -------------- View Functions --------------

    /**
     * @dev Public view function to check if an account is explicitly blacklisted.
     * @param account The address to check.
     * @return bool True if the account is blacklisted, false otherwise.
     */
    function isBlacklisted(
        address account
    ) public view returns (bool) {
        return _isBlacklisted[account];
    }

    // -------------- Upgradeability --------------

    /**
     * @dev Authorization for upgrades (UUPS).
     */
    function _authorizeUpgrade(
        address newImplementation
    ) internal override onlyRole(UPGRADER_ROLE) { }

}

// @audit

=== WhitelistRestrictions.sol ===
[Large contract - contains whitelist-based transfer restrictions with role management and enumerable address sets]

// @audit

=== RestrictionsRouter.sol ===
[Large contract - contains central router for managing global restriction modules with UUPS upgradeability]

// @audit

=== RestrictionsFactory.sol ===
[Large contract - contains factory for creating and managing restriction modules with proxy deployment]

// @audit

=== RestrictionTypes.sol ===
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.25;

/**
 * @title RestrictionTypes
 * @author qubitcrypto
 * @notice Library defining restriction type constants used across the system
 */
library RestrictionTypes {
    // -------------- Constants for Module Type IDs --------------
    bytes32 public constant TRANSFER_RESTRICTION_TYPE = keccak256("TRANSFER_RESTRICTION");
    bytes32 public constant YIELD_RESTRICTION_TYPE = keccak256("YIELD_RESTRICTION");
    bytes32 public constant GLOBAL_SANCTIONS_TYPE = keccak256("GLOBAL_SANCTIONS");
}

// @audit
=== ArcTokenPurchase.sol ===
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.25;

import "./ArcToken.sol";
import "./ArcTokenFactory.sol";
import "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";

import "@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";

/**
 * @title ArcTokenPurchase
 * @author Eugene Y. Q. Shen, Alp Guneysel
 * @notice Handles token sales and storefront configuration for ArcTokens.
 *         The contract holds the tokens being sold and the purchase currency received.
 * @dev Manages purchase process and storefront metadata, upgradeable via UUPS pattern.
 *      Requires ArcTokens to be transferred to this contract before enabling sale.
 *      Assumes tokenPrice is denominated in purchaseToken units for the number of base units
 *      corresponding to 1 full ArcToken (e.g., 1e18 for 18 decimals).
 */
contract ArcTokenPurchase is Initializable, AccessControlUpgradeable, UUPSUpgradeable, ReentrancyGuardUpgradeable {
    using EnumerableSet for EnumerableSet.AddressSet;

    struct TokenInfo {
        bool isEnabled;
        uint256 tokenPrice;
        uint256 totalAmountForSale;
        uint256 amountSold;
    }

    struct StorefrontConfig {
        string domain;
        string title;
        string description;
        string ogImageUrl;
        string accentColor;
        string backgroundColor;
        string companyLogoUrl;
        bool showPlumeBadge;
    }

    /// @custom:storage-location erc7201:arc.purchase.storage
    struct PurchaseStorage {
        // The token used for purchasing ArcTokens (e.g., USDC)
        IERC20 purchaseToken;
        // The factory that created the tokens
        address tokenFactory;
        // Mappings
        mapping(address => TokenInfo) tokenInfo;
        mapping(address => StorefrontConfig) storefrontConfigs;
        mapping(string => address) domainToAddress;
        // Set of tokens currently enabled for sale
        EnumerableSet.AddressSet enabledTokens;
    }

    // Calculate unique storage slot
    bytes32 private constant PURCHASE_STORAGE_LOCATION = keccak256("arc.purchase.storage");

    function _getPurchaseStorage() private pure returns (PurchaseStorage storage ps) {
        bytes32 position = PURCHASE_STORAGE_LOCATION;
        assembly {
            ps.slot := position
        }
    }

    // Events
    event PurchaseMade(address indexed buyer, address indexed tokenContract, uint256 amount, uint256 pricePaid);
    event TokenSaleEnabled(address indexed tokenContract, uint256 numberOfTokens, uint256 tokenPrice);
    event TokenSaleDisabled(address indexed tokenContract);
    event StorefrontConfigSet(address indexed tokenContract, string domain);
    event PurchaseTokenUpdated(address indexed newPurchaseToken);
    event TokenFactoryUpdated(address indexed newFactory);

    // -------------- Custom Errors --------------
    error PurchaseTokenNotSet();
    error PurchaseAmountTooLow();
    error TooLittleReceived();
    error NotEnoughTokensForSale();
    error ContractBalanceInsufficient();
    error PurchaseTransferFailed();
    error TokenTransferFailed();
    error InvalidPurchaseTokenAddress();
    error TokenPriceMustBePositive();
    error NumberOfTokensMustBePositive();
    error ContractMissingRequiredTokens();
    error NotTokenAdmin(address caller, address token);
    error DomainCannotBeEmpty();
    error DomainAlreadyInUse(string domain);
    error NoConfigForDomain(string domain);
    error CannotWithdrawToZeroAddress();
    error AmountMustBePositive();
    error InsufficientUnsoldTokens();
    error ArcTokenWithdrawalFailed();
    error PurchaseTokenWithdrawalFailed();
    error TokenNotEnabled(); // Replaces "Token is not enabled for purchase"
    error ZeroAmount(); // Added for consistency if needed
    error TokenFactoryNotSet();
    error TokenNotCreatedByFactory();
    error CannotChangePurchaseTokenWithActiveSales();

    /**
     * @dev Initializes the contract and sets up admin role
     * @param admin Address to be granted admin role
     * @param factory Address of the ArcTokenFactory
     */
    function initialize(address admin, address factory) public initializer {
        __AccessControl_init();
        __UUPSUpgradeable_init();
        __ReentrancyGuard_init();

        _grantRole(DEFAULT_ADMIN_ROLE, admin);

        if (factory == address(0)) {
            revert TokenFactoryNotSet();
        }
        _getPurchaseStorage().tokenFactory = factory;
    }

    /**
     * @dev Modifier to ensure only token admin can call certain functions
     */
    modifier onlyTokenAdmin(
        address _tokenContract
    ) {
        address adminRoleHolder = msg.sender;
        bytes32 adminRole = ArcToken(_tokenContract).ADMIN_ROLE();
        if (!ArcToken(_tokenContract).hasRole(adminRole, adminRoleHolder)) {
            revert NotTokenAdmin(adminRoleHolder, _tokenContract);
        }
        _;
    }

    /**
     * @dev Enables token for sale
     * @param _tokenContract Address of the ArcToken contract
     * @param _numberOfTokens Number of tokens available for sale
     * @param _tokenPrice Price per token in purchase token units
     */
    function enableToken(
        address _tokenContract,
        uint256 _numberOfTokens,
        uint256 _tokenPrice
    ) external onlyTokenAdmin(_tokenContract) {
        if (_tokenPrice == 0) {
            revert TokenPriceMustBePositive();
        }
        if (_numberOfTokens == 0) {
            revert NumberOfTokensMustBePositive();
        }

        PurchaseStorage storage ps = _getPurchaseStorage();
        if (ps.tokenFactory == address(0)) {
            revert TokenFactoryNotSet();
        }

        // Verify token was created by the factory
        address implementation = ArcTokenFactory(ps.tokenFactory)
            .getTokenImplementation(_tokenContract);
        if (implementation == address(0)) {
            revert TokenNotCreatedByFactory();
        }

        if (
            ArcToken(_tokenContract).balanceOf(address(this)) < _numberOfTokens
        ) {
            revert ContractMissingRequiredTokens();
        }

        ps.tokenInfo[_tokenContract] =
            TokenInfo({ isEnabled: true, tokenPrice: _tokenPrice, totalAmountForSale: _numberOfTokens, amountSold: 0 });

        ps.enabledTokens.add(_tokenContract);

        emit TokenSaleEnabled(_tokenContract, _numberOfTokens, _tokenPrice);
    }

    /**
     * @dev Disables a token for sale.
     * @param _tokenContract Address of the ArcToken contract to disable.
     */
    function disableToken(address _tokenContract) external onlyTokenAdmin(_tokenContract) {
        PurchaseStorage storage ps = _getPurchaseStorage();
        TokenInfo storage info = ps.tokenInfo[_tokenContract];

        if (!info.isEnabled) {
            revert TokenNotEnabled();
        }

        info.isEnabled = false;
        ps.enabledTokens.remove(_tokenContract);

        emit TokenSaleDisabled(_tokenContract);
    }

    /**
     * @dev Set token factory address
     * @param factoryAddress Address of the ArcTokenFactory
     */
    function setTokenFactory(
        address factoryAddress
    ) external onlyRole(DEFAULT_ADMIN_ROLE) {
        if (factoryAddress == address(0)) {
            revert TokenFactoryNotSet();
        }
        _getPurchaseStorage().tokenFactory = factoryAddress;
        emit TokenFactoryUpdated(factoryAddress);
    }

    /**
     * @dev Purchase tokens using the purchase token.
     *      Requires the buyer to have approved this contract to spend their purchaseToken.
     * @param _tokenContract Address of the ArcToken to purchase
     * @param _purchaseAmount Amount of purchase tokens to spend
     * @param _amountOutMinimum Minimum amount of tokens to receive (in base units)
     */
    function buy(
        address _tokenContract,
        uint256 _purchaseAmount,
        uint256 _amountOutMinimum
    ) external nonReentrant {
        PurchaseStorage storage ps = _getPurchaseStorage();
        TokenInfo storage info = ps.tokenInfo[_tokenContract];

        if (!info.isEnabled) {
            revert TokenNotEnabled();
        }
        if (_purchaseAmount == 0) {
            revert ZeroAmount();
        }
        if (info.tokenPrice == 0) {
            revert TokenPriceMustBePositive();
        }

        IERC20 purchaseTkn = ps.purchaseToken;
        if (address(purchaseTkn) == address(0)) {
            revert PurchaseTokenNotSet();
        }

        ArcToken token = ArcToken(_tokenContract);
        uint8 tokenDecimals = token.decimals(); // Get decimals dynamically
        uint256 scalingFactor = 10 ** tokenDecimals;

        // Calculate ArcToken base units to buy, assuming tokenPrice is for 1 full ArcToken (scaled by its decimals)
        uint256 arcTokensBaseUnitsToBuy = (_purchaseAmount * scalingFactor) / info.tokenPrice;
        if (arcTokensBaseUnitsToBuy == 0) {
            revert PurchaseAmountTooLow();
        }

        // Check if the calculated amount meets the minimum output requirement
        if (arcTokensBaseUnitsToBuy < _amountOutMinimum) {
            revert TooLittleReceived();
        }

        uint256 remainingForSale = info.totalAmountForSale - info.amountSold; // Remaining in base units
        if (remainingForSale < arcTokensBaseUnitsToBuy) {
            revert NotEnoughTokensForSale();
        }

        // Check base unit balance
        if (token.balanceOf(address(this)) < arcTokensBaseUnitsToBuy) {
            revert ContractBalanceInsufficient();
        }

        // Transfer purchase token (e.g., USDC)
        bool purchaseSuccess = purchaseTkn.transferFrom(msg.sender, address(this), _purchaseAmount);
        if (!purchaseSuccess) {
            revert PurchaseTransferFailed();
        }

        // Transfer ArcToken base units
        bool tokenTransferSuccess = token.transfer(msg.sender, arcTokensBaseUnitsToBuy);
        if (!tokenTransferSuccess) {
            revert TokenTransferFailed();
        }

        info.amountSold += arcTokensBaseUnitsToBuy; // Track base units sold

        // Emit event with ArcToken base units bought and purchase token amount paid
        emit PurchaseMade(msg.sender, _tokenContract, arcTokensBaseUnitsToBuy, _purchaseAmount);
    }

    /**
     * @dev Set purchase token address
     * @param purchaseTokenAddress Address of the ERC20 token to use for purchases
     */
    function setPurchaseToken(
        address purchaseTokenAddress
    ) external onlyRole(DEFAULT_ADMIN_ROLE) {
        PurchaseStorage storage ps = _getPurchaseStorage();
        if (ps.enabledTokens.length() > 0) {
            revert CannotChangePurchaseTokenWithActiveSales();
        }
        if (purchaseTokenAddress == address(0)) {
            revert InvalidPurchaseTokenAddress();
        }
        ps.purchaseToken = IERC20(purchaseTokenAddress);
        emit PurchaseTokenUpdated(purchaseTokenAddress);
    }

    /**
     * @dev Configure storefront for a token
     */
    function setStorefrontConfig(
        address _tokenContract,
        string memory _domain,
        string memory _title,
        string memory _description,
        string memory _ogImageUrl,
        string memory _accentColor,
        string memory _backgroundColor,
        string memory _companyLogoUrl,
        bool _showPlumeBadge
    ) external onlyTokenAdmin(_tokenContract) {
        if (bytes(_domain).length == 0) {
            revert DomainCannotBeEmpty();
        }
        PurchaseStorage storage ps = _getPurchaseStorage();
        if (ps.domainToAddress[_domain] != address(0) && ps.domainToAddress[_domain] != _tokenContract) {
            revert DomainAlreadyInUse(_domain);
        }

        ps.storefrontConfigs[_tokenContract] = StorefrontConfig({
            domain: _domain,
            title: _title,
            description: _description,
            ogImageUrl: _ogImageUrl,
            accentColor: _accentColor,
            backgroundColor: _backgroundColor,
            companyLogoUrl: _companyLogoUrl,
            showPlumeBadge: _showPlumeBadge
        });

        ps.domainToAddress[_domain] = _tokenContract;
        emit StorefrontConfigSet(_tokenContract, _domain);
    }

    // -------------- View Functions --------------

    /**
     * @dev Gets the sales information for a specific token.
     * @param _tokenContract The address of the ArcToken.
     * @return TokenInfo struct containing sale details (isEnabled, tokenPrice, totalAmountForSale, amountSold).
     */
    function getTokenInfo(
        address _tokenContract
    ) external view returns (TokenInfo memory) {
        return _getPurchaseStorage().tokenInfo[_tokenContract];
    }

    function isEnabled(
        address _tokenContract
    ) external view returns (bool) {
        return _getPurchaseStorage().tokenInfo[_tokenContract].isEnabled;
    }

    function getMaxNumberOfTokens(
        address _tokenContract
    ) external view returns (uint256) {
        TokenInfo storage info = _getPurchaseStorage().tokenInfo[_tokenContract];
        return info.totalAmountForSale - info.amountSold;
    }

    function getTokenPrice(
        address _tokenContract
    ) external view returns (uint256) {
        return _getPurchaseStorage().tokenInfo[_tokenContract].tokenPrice;
    }

    function getStorefrontConfig(
        address _tokenContract
    ) external view returns (StorefrontConfig memory) {
        return _getPurchaseStorage().storefrontConfigs[_tokenContract];
    }

    function getStorefrontConfigByDomain(
        string memory _domain
    ) external view returns (StorefrontConfig memory) {
        PurchaseStorage storage ps = _getPurchaseStorage();
        address tokenContract = ps.domainToAddress[_domain];
        if (tokenContract == address(0)) {
            revert NoConfigForDomain(_domain);
        }
        return ps.storefrontConfigs[tokenContract];
    }

    function getAddressByDomain(
        string memory _domain
    ) external view returns (address) {
        PurchaseStorage storage ps = _getPurchaseStorage();
        address tokenContract = ps.domainToAddress[_domain];
        if (tokenContract == address(0)) {
            revert NoConfigForDomain(_domain);
        }
        return tokenContract;
    }

    /**
     * @dev Returns the purchase token address
     */
    function purchaseToken() external view returns (IERC20) {
        return _getPurchaseStorage().purchaseToken;
    }

    /**
     * @dev Returns the token factory address
     */
    function tokenFactory() external view returns (address) {
        return _getPurchaseStorage().tokenFactory;
    }

    /**
     * @dev Withdraw purchase tokens to a specified address
     * @param to Address to send tokens to
     * @param amount Amount of tokens to withdraw
     */
    function withdrawPurchaseTokens(address to, uint256 amount) external onlyRole(DEFAULT_ADMIN_ROLE) {
        if (to == address(0)) {
            revert CannotWithdrawToZeroAddress();
        }
        PurchaseStorage storage ps = _getPurchaseStorage();
        if (address(ps.purchaseToken) == address(0)) {
            revert PurchaseTokenNotSet();
        }
        bool success = ps.purchaseToken.transfer(to, amount);
        if (!success) {
            revert PurchaseTokenWithdrawalFailed();
        }
    }

    /**
     * @dev Allows the token admin to withdraw unsold ArcTokens after a sale (or if disabled).
     * @param _tokenContract The ArcToken contract address.
     * @param to The address to send the tokens to.
     * @param amount The amount of ArcTokens to withdraw.
     */
    function withdrawUnsoldArcTokens(
        address _tokenContract,
        address to,
        uint256 amount
    ) external onlyTokenAdmin(_tokenContract) {
        if (to == address(0)) {
            revert CannotWithdrawToZeroAddress();
        }
        if (amount == 0) {
            revert AmountMustBePositive();
        }

        ArcToken token = ArcToken(_tokenContract);
        uint256 contractBalance = token.balanceOf(address(this));
        if (contractBalance < amount) {
            revert InsufficientUnsoldTokens();
        }

        bool success = token.transfer(to, amount);
        if (!success) {
            revert ArcTokenWithdrawalFailed();
        }
    }

    /**
     * @dev Authorization for upgrades
     */
    function _authorizeUpgrade(
        address newImplementation
    ) internal override onlyRole(DEFAULT_ADMIN_ROLE) { }

}

// @audit