=== PlumeRewardLogic.sol ===
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.25;

import { InternalInconsistency, MaxCommissionCheckpointsExceeded } from "./PlumeErrors.sol";
import { RewardRateCheckpointCreated, ValidatorCommissionCheckpointCreated } from "./PlumeEvents.sol";
import { PlumeStakingStorage } from "./PlumeStakingStorage.sol";
import { PlumeValidatorLogic } from "./PlumeValidatorLogic.sol";

/**
 * @title PlumeRewardLogic
 * @author Eugene Y. Q. Shen, Alp Guneysel
 * @notice Internal library containing shared logic for reward calculation and updates.
 */
library PlumeRewardLogic {

    using PlumeStakingStorage for PlumeStakingStorage.Layout;

    /**
     * @notice Finds the index of the checkpoint active at or just before a given timestamp.
     * @dev Uses binary search. Assumes checkpoints are sorted by timestamp.
     * @param checkpoints The array of RateCheckpoint structs.
     * @param timestamp The target timestamp.
     * @return index The index of the relevant checkpoint.
     */
    function findCheckpointIndex(
        PlumeStakingStorage.RateCheckpoint[] storage checkpoints,
        uint64 timestamp
    ) internal view returns (uint256 index) {
        uint256 len = checkpoints.length;
        if (len == 0) {
            return 0; // Or revert, depending on desired behavior for uninitialized rates
        }
        uint256 low = 0;
        uint256 high = len - 1;
        uint256 mid;
        while (low <= high) {
            mid = (low + high) / 2;
            if (checkpoints[mid].timestamp <= timestamp) {
                index = mid;
                // Check if it's the last element or the next element's timestamp is greater
                if (mid == len - 1 || checkpoints[mid + 1].timestamp > timestamp) {
                    return index;
                }
                low = mid + 1; // Search in the right half
            } else {
                // Check if it's the first element
                if (mid == 0) {
                    return 0;
                }
                high = mid - 1; // Search in the left half
            }
        }
        return 0;
    }

    /**
     * @notice Updates rewards for a specific user on a specific validator by iterating through all reward tokens.
     * @dev Calculates pending rewards since the last update and stores them.
     * @param $ The PlumeStaking storage layout.
     * @param user The address of the user whose rewards are being updated.
     * @param validatorId The ID of the validator.
     */
    function updateRewardsForValidator(
        PlumeStakingStorage.Layout storage $,
        address user,
        uint16 validatorId
    ) internal {
        address[] storage historicalTokens = $.historicalRewardTokens;
        for (uint256 i = 0; i < historicalTokens.length; i++) {
            address token = historicalTokens[i];
            updateRewardsForValidatorAndToken($, user, validatorId, token);
        }
    }

     /**
     * @notice Updates rewards for a specific user, validator, and token by settling pending rewards into storage.
     * @dev This is the granular settlement function. It updates the user's stored rewards and the global
     *      totalClaimableByToken.
     * @param $ The PlumeStaking storage layout.
     * @param user The address of the user whose rewards are being updated.
     * @param validatorId The ID of the validator.
     * @param token The address of the reward token.
     */
    function updateRewardsForValidatorAndToken(
        PlumeStakingStorage.Layout storage $,
        address user,
        uint16 validatorId,
        address token
    ) internal {
        // NOTE: The call to updateRewardPerTokenForValidator was removed from here. It is correctly and
        // conditionally called inside calculateRewardsWithCheckpoints.

        uint256 userStakedAmount = $.userValidatorStakes[user][validatorId].staked;

        if (userStakedAmount == 0) {
            // If user has no stake, there's nothing to calculate. We still need to update the user's "paid" pointers
            // to the latest global state to prevent incorrect future calculations.
            // First, ensure the validator's state is up-to-date.
            if (!$.validators[validatorId].slashed) {
                updateRewardPerTokenForValidator($, token, validatorId);
            }
            $.userValidatorRewardPerTokenPaid[user][validatorId][token] =
                $.validatorRewardPerTokenCumulative[validatorId][token];
            $.userValidatorRewardPerTokenPaidTimestamp[user][validatorId][token] = block.timestamp;
            return;
        }

        if ($.userValidatorStakeStartTime[user][validatorId] == 0) {
            $.userValidatorStakeStartTime[user][validatorId] = block.timestamp;
        }

        (uint256 userRewardDelta,,) =
            calculateRewardsWithCheckpoints($, user, validatorId, token, userStakedAmount);

        if (userRewardDelta > 0) {
            $.userRewards[user][validatorId][token] += userRewardDelta;
            $.totalClaimableByToken[token] += userRewardDelta;
            $.userHasPendingRewards[user][validatorId] = true;
        }

        // Update paid pointers AFTER calculating delta to correctly checkpoint the user's state.
        $.userValidatorRewardPerTokenPaid[user][validatorId][token] =
            $.validatorRewardPerTokenCumulative[validatorId][token];
        $.userValidatorRewardPerTokenPaidTimestamp[user][validatorId][token] = block.timestamp;
    }

    /**
     * @notice Updates the cumulative reward per token for a specific token and validator.
     * @dev Calculates reward accrued since the last update based on time delta and rate.
     *      Also calculates and accrues commission for the validator for this segment.
     * @param $ The PlumeStaking storage layout.
     * @param token The reward token address.
     * @param validatorId The ID of the validator.
     */
    function updateRewardPerTokenForValidator(
        PlumeStakingStorage.Layout storage $,
        address token,
        uint16 validatorId
    ) internal {
        PlumeStakingStorage.ValidatorInfo storage validator = $.validators[validatorId]; // Get validator info

        // --- REORDERED SLASHED/INACTIVE CHECKS ---
        // Check for slashed state FIRST since slashed validators are also inactive
        if (validator.slashed) {
            // For slashed validators, no further rewards or commission accrue.
            // We just update the timestamp to the current time to mark that the state is "settled" up to now.
            $.validatorLastUpdateTimes[validatorId][token] = block.timestamp;

            // Add a defensive check: A slashed validator should never have any stake. If it does, something is
            // wrong with the slashing logic itself.
            if ($.validatorTotalStaked[validatorId] > 0) {
                revert InternalInconsistency("Slashed validator has non-zero totalStaked");
            }
            return;
        } else if (!validator.active) {
            // For inactive (but not slashed) validators, no further rewards or commission accrue.
            // We just update the timestamp to the current time to mark that the state is "settled" up to now.
            $.validatorLastUpdateTimes[validatorId][token] = block.timestamp;
            return;
        }
        // --- END REORDERED CHECKS ---

        uint256 totalStaked = $.validatorTotalStaked[validatorId];
        uint256 oldLastUpdateTime = $.validatorLastUpdateTimes[validatorId][token];

        if (block.timestamp > oldLastUpdateTime) {
            if (totalStaked > 0) {
                uint256 timeDelta = block.timestamp - oldLastUpdateTime;
                // Get the reward rate effective for the segment ending at block.timestamp
                PlumeStakingStorage.RateCheckpoint memory effectiveRewardRateChk =
                    getEffectiveRewardRateAt($, token, validatorId, block.timestamp);
                uint256 effectiveRewardRate = effectiveRewardRateChk.rate;

                if (effectiveRewardRate > 0) {
                    uint256 rewardPerTokenIncrease = timeDelta * effectiveRewardRate;
                    $.validatorRewardPerTokenCumulative[validatorId][token] += rewardPerTokenIncrease;

                    // Accrue commission for the validator for this segment
                    // The commission rate should be the one effective at the START of this segment (oldLastUpdateTime)
                    uint256 commissionRateForSegment = getEffectiveCommissionRateAt($, validatorId, oldLastUpdateTime);
                    uint256 grossRewardForValidatorThisSegment =
                        (totalStaked * rewardPerTokenIncrease) / PlumeStakingStorage.REWARD_PRECISION;

                    // Use regular division (floor) for validator's accrued commission
                    uint256 commissionDeltaForValidator = (
                        grossRewardForValidatorThisSegment * commissionRateForSegment
                    ) / PlumeStakingStorage.REWARD_PRECISION;

                    if (commissionDeltaForValidator > 0) {
                        $.validatorAccruedCommission[validatorId][token] += commissionDeltaForValidator;
                    }
                }
            }
        }
        // Update last global update time for this validator/token AFTER all calculations for the segment
        $.validatorLastUpdateTimes[validatorId][token] = block.timestamp;
    }

    /**
     * @notice Core reward calculation logic used by both modifying and view functions
     * @dev Calculates rewards using segmented approach for accurate commission handling
     * @param $ The PlumeStaking storage layout.
     * @param user The user address.
     * @param validatorId The validator ID.
     * @param token The reward token address.
     * @param userStakedAmount The user's current staked amount with this validator.
     * @param currentCumulativeRewardPerToken The current cumulative reward per token to use
     * @return totalUserRewardDelta The calculated reward amount for the user (after commission).
     * @return totalCommissionAmountDelta The calculated commission amount for the validator.
     * @return effectiveTimeDelta The effective time delta for the calculation.
     */
    function _calculateRewardsCore(
        PlumeStakingStorage.Layout storage $,
        address user,
        uint16 validatorId,
        address token,
        uint256 userStakedAmount,
        uint256 currentCumulativeRewardPerToken
    )
        internal
        view
        returns (uint256 totalUserRewardDelta, uint256 totalCommissionAmountDelta, uint256 effectiveTimeDelta)
    {
        uint256 lastUserPaidCumulativeRewardPerToken = $.userValidatorRewardPerTokenPaid[user][validatorId][token];
        uint256 lastUserRewardUpdateTime = $.userValidatorRewardPerTokenPaidTimestamp[user][validatorId][token];

        if (lastUserRewardUpdateTime == 0) {
            // This is the first reward calculation for this user/validator/token.
            // Start the calculation from when the user's stake began.
            // The checkpoint system will correctly apply a zero rate for any period before the token was added.
            lastUserRewardUpdateTime = $.userValidatorStakeStartTime[user][validatorId];

            if (lastUserRewardUpdateTime == 0 && $.userValidatorStakes[user][validatorId].staked > 0) {
                
                uint256 fallbackTime = block.timestamp;

                // If validator is slashed, cap fallback time at slash timestamp
                PlumeStakingStorage.ValidatorInfo storage validator = $.validators[validatorId];
                if (validator.slashedAtTimestamp > 0 && validator.slashedAtTimestamp < fallbackTime) {
                    fallbackTime = validator.slashedAtTimestamp;
                }

                lastUserRewardUpdateTime = fallbackTime;
            }
        }

        // For recently reactivated validators, don't calculate rewards
        // from before the reactivation time to prevent retroactive accrual
        uint256 validatorLastUpdateTime = $.validatorLastUpdateTimes[validatorId][token];

        // For slashed/inactive validators, cap the calculation period at the timestamp
        PlumeStakingStorage.ValidatorInfo storage validator = $.validators[validatorId];
        uint256 effectiveEndTime = block.timestamp;

        // Check token removal timestamp
        uint256 tokenRemovalTime = $.tokenRemovalTimestamps[token];
        if (tokenRemovalTime > 0 && tokenRemovalTime < effectiveEndTime) {
            effectiveEndTime = tokenRemovalTime;
        }

        // Then check validator slash/inactive timestamp
        if (validator.slashedAtTimestamp > 0) {
            if (validator.slashedAtTimestamp < effectiveEndTime) {
                effectiveEndTime = validator.slashedAtTimestamp;
            }
        }

        // If no time has passed or user hasn't earned anything yet (e.g. paid index is already current)
        if (
            effectiveEndTime <= lastUserRewardUpdateTime
                || currentCumulativeRewardPerToken <= lastUserPaidCumulativeRewardPerToken
        ) {
            return (0, 0, 0);
        }

        effectiveTimeDelta = effectiveEndTime - lastUserRewardUpdateTime; // This is the total duration of interest

        uint256[] memory distinctTimestamps =
            getDistinctTimestamps($, validatorId, token, lastUserRewardUpdateTime, effectiveEndTime);

        // If only start and end (or fewer), means no intermediate checkpoints relevant to this user's period.
        // The simple delta calculation using final - initial cumulative should work, but it's already part of the loop.
        // The loop needs at least two points to form a segment.
        if (distinctTimestamps.length < 2) {
            // This can happen if lastUserRewardUpdateTime == effectiveEndTime or no checkpoints exist.
            // The check above (effectiveEndTime <= lastUserRewardUpdateTime) should catch the first case.
            // If no checkpoints, getDistinctTimestamps returns [lastUserRewardUpdateTime, effectiveEndTime].
            // So length should be 2. If less than 2, something is off, or it's a zero-duration.
            return (0, 0, 0); // Should be caught by initial checks.
        }

        uint256 rptTracker = lastUserPaidCumulativeRewardPerToken;

        for (uint256 k = 0; k < distinctTimestamps.length - 1; ++k) {
            uint256 segmentStartTime = distinctTimestamps[k];
            uint256 segmentEndTime = distinctTimestamps[k + 1];

            if (segmentEndTime <= segmentStartTime) {
                // Should not happen with sorted distinct timestamps
                continue;
            }

            // The RPT for the validator at the START of this segment.
            // This needs to be carefully determined. It's not necessarily rptTracker if there were prior segments.
            // It's the validator's cumulative RPT as of segmentStartTime.
            // For the *first* segment (k=0), segmentStartTime is lastUserRewardUpdateTime, and
            // rptAtSegmentStart IS lastUserPaidCumulativeRewardPerToken (or rptTracker).
            // For subsequent segments, rptAtSegmentStart is the rptAtSegmentEnd of the previous segment.
            uint256 rptAtSegmentStart;
            if (k == 0) {
                rptAtSegmentStart = lastUserPaidCumulativeRewardPerToken;
            } else {
                // For k > 0, rptAtSegmentStart is the cumulative value at distinctTimestamps[k]
                // This implies we need a way to get the validator's cumulative RPT at ANY timestamp,
                // not just by stepping through.
                // The current logic correctly uses rptTracker which IS the rptAtSegmentEnd of the previous segment.
                rptAtSegmentStart = rptTracker;
            }

            // What is the validator's RPT at segmentEndTime?
            // This requires calculating the RPT increase *within this specific segment*.
            PlumeStakingStorage.RateCheckpoint memory rewardRateInfoForSegment =
                getEffectiveRewardRateAt($, token, validatorId, segmentStartTime); // Rate at START of segment
            uint256 effectiveRewardRate = rewardRateInfoForSegment.rate;
            uint256 segmentDuration = segmentEndTime - segmentStartTime;

            uint256 rptIncreaseInSegment = 0;
            if (effectiveRewardRate > 0 && segmentDuration > 0) {
                rptIncreaseInSegment = segmentDuration * effectiveRewardRate;
            }

            uint256 rptAtSegmentEnd = rptAtSegmentStart + rptIncreaseInSegment;

            // The actual RPT delta for the user in this segment.
            // The user "catches up" from rptAtSegmentStart to rptAtSegmentEnd.
            // Note: This is the same as rptIncreaseInSegment for this specific case
            uint256 rewardPerTokenDeltaForUserInSegment = rptAtSegmentEnd - rptAtSegmentStart;

            if (rewardPerTokenDeltaForUserInSegment > 0 && userStakedAmount > 0) {
                uint256 grossRewardForSegment =
                    (userStakedAmount * rewardPerTokenDeltaForUserInSegment) / PlumeStakingStorage.REWARD_PRECISION;

                // Commission rate effective at the START of this segment
                uint256 effectiveCommissionRate = getEffectiveCommissionRateAt($, validatorId, segmentStartTime);

                // Use ceiling division for commission charged to user to ensure rounding up
                uint256 commissionForThisSegment =
                    _ceilDiv(grossRewardForSegment * effectiveCommissionRate, PlumeStakingStorage.REWARD_PRECISION);

                if (grossRewardForSegment >= commissionForThisSegment) {
                    totalUserRewardDelta += (grossRewardForSegment - commissionForThisSegment);
                } // else, net reward is 0 for this segment for the user.
                // Commission is still generated for the validator based on gross.
                // This was previously missing, commission should always be based on gross.
                totalCommissionAmountDelta += commissionForThisSegment;
            }
            rptTracker = rptAtSegmentEnd; // Update tracker for the next segment's start
        }
        return (totalUserRewardDelta, totalCommissionAmountDelta, effectiveTimeDelta);
    }

     /**
     * @notice Calculates the reward delta for a user, applying commission rates from checkpoints.
     * @dev This function iterates through time segments defined by reward and commission rate changes.
     * @param $ The PlumeStaking storage layout.
     * @param user The user address.
     * @param validatorId The validator ID.
     * @param token The reward token address.
     * @param userStakedAmount The user's current staked amount with this validator.
     * @return totalUserRewardDelta The calculated reward amount for the user (after commission).
     * @return totalCommissionAmountDelta The calculated commission amount for the validator.
     * @return effectiveTimeDelta The effective time delta for the calculation.
     */
    function calculateRewardsWithCheckpoints(
        PlumeStakingStorage.Layout storage $,
        address user,
        uint16 validatorId,
        address token,
        uint256 userStakedAmount
    ) internal returns (uint256 totalUserRewardDelta, uint256 totalCommissionAmountDelta, uint256 effectiveTimeDelta) {
        PlumeStakingStorage.ValidatorInfo storage validator = $.validators[validatorId];

        if (!validator.slashed) {
            // Normal case: update and use the updated cumulative.
            updateRewardPerTokenForValidator($, token, validatorId);
            uint256 finalCumulativeRewardPerToken = $.validatorRewardPerTokenCumulative[validatorId][token];
            return _calculateRewardsCore($, user, validatorId, token, userStakedAmount, finalCumulativeRewardPerToken);
        } else {
            // Slashed validator case: calculate what cumulative should be up to the slash timestamp.
            // We DO NOT call updateRewardPerTokenForValidator here because its logic is incorrect for slashed validators.
            uint256 currentCumulativeRewardPerToken = $.validatorRewardPerTokenCumulative[validatorId][token];
            uint256 effectiveEndTime = validator.slashedAtTimestamp;

            uint256 tokenRemovalTime = $.tokenRemovalTimestamps[token];
            if (tokenRemovalTime > 0 && tokenRemovalTime < effectiveEndTime) {
                effectiveEndTime = tokenRemovalTime;
            }

            uint256 validatorLastUpdateTime = $.validatorLastUpdateTimes[validatorId][token];

            if (effectiveEndTime > validatorLastUpdateTime) {
                uint256 timeSinceLastUpdate = effectiveEndTime - validatorLastUpdateTime;

                if (userStakedAmount > 0) {
                    PlumeStakingStorage.RateCheckpoint memory effectiveRewardRateChk =
                        getEffectiveRewardRateAt($, token, validatorId, validatorLastUpdateTime); // Use rate at start of segment
                    uint256 effectiveRewardRate = effectiveRewardRateChk.rate;

                    if (effectiveRewardRate > 0) {
                        uint256 rewardPerTokenIncrease = timeSinceLastUpdate * effectiveRewardRate;
                        currentCumulativeRewardPerToken += rewardPerTokenIncrease;
                    }
                }
            }

            return _calculateRewardsCore($, user, validatorId, token, userStakedAmount, currentCumulativeRewardPerToken);
        }
    }

    /**
     * @notice Helper function for ceiling division to ensure rounding up
     * @dev Used for commission calculations charged to users to ensure sum of user commissions >= validator accrued
     * commission
     * @param a Numerator
     * @param b Denominator
     * @return result The ceiling of a/b
     */
    function _ceilDiv(uint256 a, uint256 b) internal pure returns (uint256 result) {
        if (b == 0) {
            return 0;
        }
        return (a + b - 1) / b;
    }

    /**
     * @notice Helper to get a sorted list of unique timestamps relevant for a claim period.
     * Includes period start, period end, and all reward/commission checkpoints in between.
     * Uses a merge-style approach for efficiency, assuming checkpoint arrays are sorted.
     */
    function getDistinctTimestamps(
        PlumeStakingStorage.Layout storage $,
        uint16 validatorId,
        address token,
        uint256 periodStart,
        uint256 periodEnd
    ) internal view returns (uint256[] memory) {
        PlumeStakingStorage.RateCheckpoint[] storage rewardCheckpoints =
            $.validatorRewardRateCheckpoints[validatorId][token];
        PlumeStakingStorage.RateCheckpoint[] storage commissionCheckpoints =
            $.validatorCommissionCheckpoints[validatorId];

        uint256 len1 = rewardCheckpoints.length;
        uint256 len2 = commissionCheckpoints.length;

        if (periodStart > periodEnd) {
            // Invalid period
            return new uint256[](0);
        }
        if (periodStart == periodEnd) {
            // Zero-duration period
            uint256[] memory singlePoint = new uint256[](1);
            singlePoint[0] = periodStart;
            return singlePoint;
        }

        // Max possible output length = len1 + len2 + 2 (start, end, all unique checkpoints)
        uint256[] memory result = new uint256[](len1 + len2 + 2);
        uint256 i = 0; // Pointer for rewardCheckpoints
        uint256 j = 0; // Pointer for commissionCheckpoints
        uint256 k = 0; // Pointer for result array

        result[k++] = periodStart;
        uint256 lastAddedTimestamp = periodStart;

        // Skip checkpoints BEFORE periodStart (but include checkpoints AT periodStart)
        // This ensures commission/reward rate changes exactly at period boundary are included
        while (i < len1 && rewardCheckpoints[i].timestamp < periodStart) {
            i++;
        }
        while (j < len2 && commissionCheckpoints[j].timestamp < periodStart) {
            j++;
        }

        // Merge the two arrays, adding distinct timestamps strictly between periodStart and periodEnd
        while (i < len1 || j < len2) {
            uint256 t1 = (i < len1) ? rewardCheckpoints[i].timestamp : type(uint256).max;
            uint256 t2 = (j < len2) ? commissionCheckpoints[j].timestamp : type(uint256).max;
            uint256 currentTimestampToAdd;

            bool advanceI = false;
            bool advanceJ = false;

            if (t1 < t2) {
                currentTimestampToAdd = t1;
                advanceI = true;
            } else if (t2 < t1) {
                currentTimestampToAdd = t2;
                advanceJ = true;
            } else if (t1 != type(uint256).max) {
                // t1 == t2 and not max_value (both arrays exhausted)
                currentTimestampToAdd = t1; // or t2
                advanceI = true;
                advanceJ = true;
            } else {
                // Both t1 and t2 are type(uint256).max, meaning both arrays are exhausted
                break;
            }

            if (currentTimestampToAdd >= periodEnd) {
                // Stop if we reach or exceed periodEnd
                break;
            }

            // Add if it's a new distinct timestamp that is > lastAddedTimestamp (which was periodStart initially)
            if (currentTimestampToAdd > lastAddedTimestamp) {
                result[k++] = currentTimestampToAdd;
                lastAddedTimestamp = currentTimestampToAdd;
            }

            if (advanceI) {
                i++;
            }
            if (advanceJ) {
                j++;
            }
        }

        // Add periodEnd if it's not already the last element added and is greater
        if (lastAddedTimestamp < periodEnd) {
            result[k++] = periodEnd;
        }

        assembly {
            mstore(result, k)
        }
        return result;
    }

    /**
     * @notice Gets the effective reward rate for a validator and token at a given timestamp.
     * Looks up the validator-specific reward rate checkpoint. If none, uses global reward rate.
     * @dev Returns the reward rate that was active at the given timestamp, regardless of current token status
     */
    function getEffectiveRewardRateAt(
        PlumeStakingStorage.Layout storage $,
        address token,
        uint16 validatorId,
        uint256 timestamp
    ) internal view returns (PlumeStakingStorage.RateCheckpoint memory effectiveCheckpoint) {
        // For historical reward calculations, we should use the rate that was active at that time
        // regardless of whether the token is currently valid or the validator is currently slashed

        PlumeStakingStorage.RateCheckpoint[] storage checkpoints = $.validatorRewardRateCheckpoints[validatorId][token];
        uint256 chkCount = checkpoints.length;

        if (chkCount > 0) {
            uint256 idx = findRewardRateCheckpointIndexAtOrBefore($, validatorId, token, timestamp);

            // Check if checkpoints[idx] is actually valid for this timestamp.
            if (idx < chkCount && checkpoints[idx].timestamp <= timestamp) {
                // Additionally, ensure that if there's a *next* checkpoint, its timestamp is > current query timestamp
                // This ensures we pick the one *immediately* at or before.
                if (idx + 1 < chkCount && checkpoints[idx + 1].timestamp <= timestamp) {
                    // This means a later checkpoint (idx+1) is also <= timestamp.
                    // The binary search should ideally give the *latest* one.
                    // Let's reverify findRewardRateCheckpointIndexAtOrBefore.
                    // For now, assume `idx` is the correct one.
                }
                return checkpoints[idx];
            }
        }
        // Fallback: No validator-specific checkpoint found that is <= timestamp, or no checkpoints exist.
        // The global rate itself doesn't have a cumulative index in the same way here.
        // We need to construct a checkpoint-like struct.
        // The cumulative index part is tricky for global fallbacks if we expect it to be accurate globally.
        // For rate, this is fine. For cumulativeIndex, it should reflect
        // $.validatorRewardPerTokenCumulative[validatorId][token]
        // if we are at "now" or need to calculate up to "now" for a segment ending at "now".
        // However, getEffectiveRewardRateAt is used to find the *rate* for a segment.
        // The cumulative index for the *start* of the segment is taken from the previous segment's end or initial user
        // state.
        // So, for rate calculation, this is okay.

        effectiveCheckpoint.rate = 0; // Global rate
        effectiveCheckpoint.timestamp = timestamp; // Timestamp of query

        // If falling back to global rate, what should cumulativeIndex be?
        // If the query timestamp is for the *current* live segment (ending at block.timestamp),
        // then the "live" cumulative index for the validator is relevant.
        // If it's for a historical segment, this fallback is more about just getting the rate.
        // The calculateRewardsWithCheckpoints uses this to find the *rate* for a segment.
        // The cumulative index for the *start* of the segment is taken from the previous segment's end or initial user
        // state.
        // So, for rate calculation, this is okay.
        effectiveCheckpoint.cumulativeIndex = 0; // Or perhaps the validator's current cumulative if timestamp ==
            // block.timestamp?
            // Let's assume 0 is fine for rate-finding purpose. The loop handles accumulation.
        return effectiveCheckpoint;
    }

    /**
     * @notice Gets the effective commission rate for a validator at a given timestamp.
     * Looks up the validator-specific commission rate checkpoint.
     */
    function getEffectiveCommissionRateAt(
        PlumeStakingStorage.Layout storage $,
        uint16 validatorId,
        uint256 timestamp
    ) internal view returns (uint256) {
        PlumeStakingStorage.RateCheckpoint[] storage checkpoints = $.validatorCommissionCheckpoints[validatorId];
        uint256 chkCount = checkpoints.length;

        if (chkCount > 0) {
            uint256 idx = findCommissionCheckpointIndexAtOrBefore($, validatorId, timestamp);
            if (idx < chkCount && checkpoints[idx].timestamp <= timestamp) {
                // Similar to above, ensure this is the latest one.
                return checkpoints[idx].rate;
            }
        }
        // Fallback to the current commission rate stored directly in ValidatorInfo
        // This is important if no checkpoints exist or all are in the future.
        uint256 fallbackComm = $.validators[validatorId].commission;
        return fallbackComm;
    }

    /**
     * @notice Finds the index of the reward rate checkpoint active at or just before a given timestamp for a validator.
     */
    function findRewardRateCheckpointIndexAtOrBefore(
        PlumeStakingStorage.Layout storage $,
        uint16 validatorId,
        address token,
        uint256 timestamp
    ) internal view returns (uint256) {
        PlumeStakingStorage.RateCheckpoint[] storage checkpoints = $.validatorRewardRateCheckpoints[validatorId][token];
        uint256 len = checkpoints.length;

        if (len == 0) {
            return 0; // Indicates no checkpoints, caller might use global rate.
        }

        uint256 low = 0;
        uint256 high = len - 1;
        uint256 ans = 0;
        // If all checkpoints are in the future, ans remains 0.
        // The caller (getEffectiveRewardRateAt) should check if checkpoints[0].timestamp > timestamp.
        // If so, it correctly falls back to global. If not, checkpoints[0] is a candidate.

        bool foundSuitable = false;

        while (low <= high) {
            uint256 mid = low + (high - low) / 2;
            if (checkpoints[mid].timestamp <= timestamp) {
                ans = mid; // This checkpoint is a candidate
                foundSuitable = true;
                low = mid + 1; // Try to find a later one
            } else {
                // checkpoints[mid].timestamp > timestamp
                if (mid == 0) {
                    // If even the first is too new
                    break;
                }
                high = mid - 1;
            }
        }
        // If !foundSuitable, it means all checkpoints were > timestamp.
        // `ans` would be 0. getEffectiveRewardRateAt will then check checkpoints[0].timestamp.
        // If foundSuitable, `ans` is the index of the latest checkpoint with .timestamp <= query_timestamp.
        return ans;
    }

    /**
     * @notice Finds the index of the commission checkpoint active at or just before a given timestamp for a validator.
     */
    function findCommissionCheckpointIndexAtOrBefore(
        PlumeStakingStorage.Layout storage $,
        uint16 validatorId,
        uint256 timestamp
    ) internal view returns (uint256) {
        PlumeStakingStorage.RateCheckpoint[] storage checkpoints = $.validatorCommissionCheckpoints[validatorId];
        uint256 len = checkpoints.length;
        if (len == 0) {
            return 0; // No checkpoints, caller uses current validator.commission
        }

        uint256 low = 0;
        uint256 high = len - 1;
        uint256 ans = 0;
        bool foundSuitable = false;

        while (low <= high) {
            uint256 mid = low + (high - low) / 2;

            if (checkpoints[mid].timestamp <= timestamp) {
                ans = mid;
                foundSuitable = true;
                low = mid + 1;
            } else {
                if (mid == 0) {
                    break;
                }
                high = mid - 1;
            }
        }
        return ans;
    }

    /**
     * @notice Creates a new reward rate checkpoint for a specific validator and token.
     * @param $ The PlumeStaking storage layout.
     * @param token The reward token address.
     * @param validatorId The validator ID.
     * @param rate The new reward rate.
     */
    function createRewardRateCheckpoint(
        PlumeStakingStorage.Layout storage $,
        address token,
        uint16 validatorId,
        uint256 rate
    ) internal {
        updateRewardPerTokenForValidator($, token, validatorId); // Settle up to now with old rate
        uint256 currentCumulativeIndex = $.validatorRewardPerTokenCumulative[validatorId][token];

        PlumeStakingStorage.RateCheckpoint[] storage checkpoints = $.validatorRewardRateCheckpoints[validatorId][token];
        uint256 len = checkpoints.length;

        PlumeStakingStorage.RateCheckpoint memory checkpoint = PlumeStakingStorage.RateCheckpoint({
            timestamp: block.timestamp, // New rate effective from now
            rate: rate, // The new rate
            cumulativeIndex: currentCumulativeIndex // Cumulative index *before* this new rate applies
         });

        uint256 checkpointIndex;

        if (len > 0 && checkpoints[len - 1].timestamp == block.timestamp) {
            // Overwrite the last checkpoint if it's from the same block
            checkpoints[len - 1] = checkpoint;
            checkpointIndex = len - 1;
        } else {
            // Otherwise, add a new one
            checkpoints.push(checkpoint);
            checkpointIndex = len;
        }

        emit RewardRateCheckpointCreated(
            token, validatorId, rate, block.timestamp, checkpointIndex, currentCumulativeIndex
        );
    }

    /**
     * @notice Creates a new commission rate checkpoint for a specific validator.
     * @dev Analogous to createRewardRateCheckpoint but for commission.
     * @param $ The PlumeStaking storage layout.
     * @param validatorId The validator ID.
     * @param commissionRate The new commission rate.
     */
    function createCommissionRateCheckpoint(
        PlumeStakingStorage.Layout storage $,
        uint16 validatorId,
        uint256 commissionRate
    ) internal {
        // This function records the *new* commission rate, effective from block.timestamp.
        // It overwrites any previous checkpoint from the same block to prevent duplicates.
        PlumeStakingStorage.RateCheckpoint[] storage checkpoints = $.validatorCommissionCheckpoints[validatorId];
        uint256 len = checkpoints.length;

        PlumeStakingStorage.RateCheckpoint memory checkpoint = PlumeStakingStorage.RateCheckpoint({
            timestamp: block.timestamp,
            rate: commissionRate,
            cumulativeIndex: 0 // Not used for commission
         });

        if (len > 0 && checkpoints[len - 1].timestamp == block.timestamp) {
            // Overwrite the last checkpoint if it's from the same block
            checkpoints[len - 1] = checkpoint;
        } else {
            // Enforce maximum checkpoint limit before adding a new one.
            if ($.maxCommissionCheckpoints > 0 && len >= $.maxCommissionCheckpoints) {
                revert MaxCommissionCheckpointsExceeded(validatorId, $.maxCommissionCheckpoints);
            }
            // Otherwise, add a new one
            checkpoints.push(checkpoint);
        }

        emit ValidatorCommissionCheckpointCreated(validatorId, commissionRate, block.timestamp);
    }

    /**
     * @notice Settles the accrued commission for a validator for all reward tokens up to the current block.timestamp,
     *         by calling `updateRewardPerTokenForValidator` which now handles commission accrual directly.
     * @param $ The PlumeStaking storage layout.
     * @param validatorId The ID of the validator.
     */
    function _settleCommissionForValidatorUpToNow(PlumeStakingStorage.Layout storage $, uint16 validatorId) internal {
        address[] memory rewardTokens = $.rewardTokens;

        for (uint256 i = 0; i < rewardTokens.length; i++) {
            address token = rewardTokens[i];
            // Calling updateRewardPerTokenForValidator will now also handle accruing commission.
            updateRewardPerTokenForValidator($, token, validatorId);
        }
    }

    /**
     * @notice Clears the pending rewards flag for a user-validator pair if no rewards remain
     * @dev Should be called after claiming rewards to maintain flag accuracy.
     *      This function is conservative about clearing flags to avoid removing user-validator
     *      relationships when there might still be claimable rewards from removed tokens.
     * @param $ The PlumeStaking storage layout.
     * @param user The user address.
     * @param validatorId The validator ID.
     */
    function clearPendingRewardsFlagIfEmpty(
        PlumeStakingStorage.Layout storage $,
        address user,
        uint16 validatorId
    ) internal {
        if (!$.userHasPendingRewards[user][validatorId]) {
            return; // Already cleared, no action needed.
        }

        // Iterate through EVERY token that has EVER been a reward token.
        address[] storage historicalTokens = $.historicalRewardTokens;
        uint256 userStakedAmount = $.userValidatorStakes[user][validatorId].staked;

        for (uint256 i = 0; i < historicalTokens.length; i++) {
            address token = historicalTokens[i];

            // Check 1: Does the user have any rewards already settled and stored in the mapping?
            if ($.userRewards[user][validatorId][token] > 0) {
                return; // Found stored rewards, user still has pending rewards. Do not clear flag.
            }

            // Check 2: If the user still has an active stake, are there any *unsettled* rewards
            // that can be calculated for this token (even if it's been removed)?
            if (userStakedAmount > 0) {
                (uint256 unsettledRewards,,) =
                    calculateRewardsWithCheckpointsView($, user, validatorId, token, userStakedAmount);
                if (unsettledRewards > 0) {
                    return; // Found calculable rewards, user still has pending rewards. Do not clear flag.
                }
            }
        }

        // If we've looped through every historical token and found no stored and no calculable rewards,
        // it is now safe to clear the pending rewards flag for this user-validator pair.
        $.userHasPendingRewards[user][validatorId] = false;
    }

    /**
     * @notice View-only version of reward calculation that doesn't modify storage
     * @dev Used by earned() and other view functions to calculate rewards without state changes
     * @param $ The PlumeStaking storage layout.
     * @param user The user address.
     * @param validatorId The validator ID.
     * @param token The reward token address.
     * @param userStakedAmount The user's current staked amount with this validator.
     * @return totalUserRewardDelta The calculated reward amount for the user (after commission).
     * @return totalCommissionAmountDelta The calculated commission amount for the validator.
     * @return effectiveTimeDelta The effective time delta for the calculation.
     */
    function calculateRewardsWithCheckpointsView(
        PlumeStakingStorage.Layout storage $,
        address user,
        uint16 validatorId,
        address token,
        uint256 userStakedAmount
    )
        internal
        view
        returns (uint256 totalUserRewardDelta, uint256 totalCommissionAmountDelta, uint256 effectiveTimeDelta)
    {
        // This view function simulates what the state-changing `calculateRewardsWithCheckpoints` does.
        // It must accurately calculate the validator's theoretical cumulative reward per token at the
        // current block timestamp, respecting all historical rate changes.

        // 1. Determine the effective time range for the simulation.
        PlumeStakingStorage.ValidatorInfo storage validator = $.validators[validatorId];
        uint256 effectiveEndTime = block.timestamp;
        uint256 tokenRemovalTime = $.tokenRemovalTimestamps[token];
        if (tokenRemovalTime > 0 && tokenRemovalTime < effectiveEndTime) {
            effectiveEndTime = tokenRemovalTime;
        }
        if (validator.slashedAtTimestamp > 0 && validator.slashedAtTimestamp < effectiveEndTime) {
            effectiveEndTime = validator.slashedAtTimestamp;
        }

        // 2. Start with the last known, stored cumulative value and its timestamp.
        uint256 simulatedCumulativeRPT = $.validatorRewardPerTokenCumulative[validatorId][token];
        uint256 lastUpdateTime = $.validatorLastUpdateTimes[validatorId][token];

        // 3. If time has passed since the last update, simulate the RPT increase segment by segment.
        if (effectiveEndTime > lastUpdateTime) {
            uint256[] memory distinctTimestamps =
                getDistinctTimestamps($, validatorId, token, lastUpdateTime, effectiveEndTime);

            if (distinctTimestamps.length >= 2) {
                for (uint256 k = 0; k < distinctTimestamps.length - 1; ++k) {
                    uint256 segmentStartTime = distinctTimestamps[k];
                    uint256 segmentEndTime = distinctTimestamps[k + 1];
                    uint256 segmentDuration = segmentEndTime - segmentStartTime;

                    if (segmentDuration > 0) {
                        // Rate for the segment is determined by the rate at its beginning.
                        uint256 rateForSegment = getEffectiveRewardRateAt($, token, validatorId, segmentStartTime).rate;
                        if (rateForSegment > 0) {
                            uint256 rptIncreaseInSegment = segmentDuration * rateForSegment;
                            simulatedCumulativeRPT += rptIncreaseInSegment;
                        }
                    }
                }
            }
        }

        // 4. Now that we have the correctly simulated final cumulative RPT, call the core logic.
        return _calculateRewardsCore($, user, validatorId, token, userStakedAmount, simulatedCumulativeRPT);
    }

}

// @audit
=== PlumeEvents.sol ===
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.25;

/**
 * @title PlumeEvents
 * @author Eugene Y. Q. Shen, Alp Guneysel
 * @notice Common events used across Plume contracts
 */

/**
 * @notice Emitted when tokens are staked in the contract
 * @param staker Address of the staker
 * @param validatorId ID of the validator receiving the stake
 * @param amount Amount of tokens staked
 * @param fromCooled Amount of tokens used from cooled tokens
 * @param fromParked Amount of tokens used from parked (withdrawn) tokens
 * @param pendingRewards Amount of tokens staked from pending rewards
 */
event Staked(
    address indexed staker,
    uint16 indexed validatorId,
    uint256 amount,
    uint256 fromCooled,
    uint256 fromParked,
    uint256 pendingRewards
);

/**
 * @notice Emitted when stake is started to cool
 * @param staker Address of the staker
 * @param validatorId ID of the validator
 * @param amount Amount moved to cooling
 * @param cooldownEnd Timestamp when cooldown ends
 */
event CooldownStarted(address indexed staker, uint16 indexed validatorId, uint256 amount, uint256 cooldownEnd);

/**
 * @notice Emitted when tokens are unstaked from the contract (legacy)
 * @param user Address of the user
 * @param validatorId ID of the validator
 * @param amount Amount unstaked
 */
event Unstaked(address indexed user, uint16 indexed validatorId, uint256 amount);

/**
 * @notice Emitted when tokens are withdrawn from the contract
 * @param staker Address of the staker
 * @param amount Amount withdrawn
 */
event Withdrawn(address indexed staker, uint256 amount);

/**
 * @notice Emitted when a reward token is added
 * @param token Address of the token
 */
event RewardTokenAdded(address indexed token);

/**
 * @notice Emitted when a reward token is removed
 * @param token Address of the token
 */
event RewardTokenRemoved(address indexed token);

/**
 * @notice Emitted when reward rates are updated
 * @param tokens Array of token addresses
 * @param rates Array of new rates
 */
event RewardRatesSet(address[] tokens, uint256[] rates);

/**
 * @notice Emitted when a new reward rate checkpoint is created
 * @param token Address of the token
 * @param validatorId ID of the validator
 * @param rate New reward rate
 * @param timestamp Timestamp when the checkpoint was created
 * @param index Index of the checkpoint
 * @param cumulativeIndex Cumulative reward index at this checkpoint
 */
event RewardRateCheckpointCreated(
    address indexed token,
    uint16 indexed validatorId,
    uint256 rate,
    uint256 timestamp,
    uint256 indexed index,
    uint256 cumulativeIndex
);

/**
 * @notice Emitted when the maximum reward rate for a token is updated
 * @param token Address of the token
 * @param newRate New maximum rate
 */
event MaxRewardRateUpdated(address indexed token, uint256 newRate);

/**
 * @notice Emitted when a reward is claimed
 * @param user Address of the user
 * @param token Address of the token
 * @param amount Amount claimed
 */
event RewardClaimed(address indexed user, address indexed token, uint256 amount);

/**
 * @notice Emitted when a reward is claimed from a specific validator
 * @param user Address of the user
 * @param token Address of the token
 * @param validatorId ID of the validator
 * @param amount Amount claimed
 */
event RewardClaimedFromValidator(
    address indexed user, address indexed token, uint16 indexed validatorId, uint256 amount
);

/**
 * @notice Emitted when validator commission is claimed
 * @param validatorId ID of the validator
 * @param token Address of the token
 * @param amount Amount of commission claimed
 */
event ValidatorCommissionClaimed(uint16 indexed validatorId, address indexed token, uint256 amount);

/**
 * @notice Emitted when a validator is added
 * @param validatorId ID of the validator
 * @param commission Commission rate
 * @param l2AdminAddress Admin address
 * @param l2WithdrawAddress Withdrawal address
 * @param l1ValidatorAddress L1 validator address
 * @param l1AccountAddress L1 account address
 * @param l1AccountEvmAddress EVM address of account on L1 (informational)
 */
event ValidatorAdded(
    uint16 indexed validatorId,
    uint256 commission,
    address l2AdminAddress,
    address l2WithdrawAddress,
    string l1ValidatorAddress,
    string l1AccountAddress,
    address l1AccountEvmAddress
);

/**
 * @notice Emitted when a validator is updated
 * @param validatorId ID of the validator
 * @param commission New commission rate
 * @param l2AdminAddress New admin address
 * @param l2WithdrawAddress New withdrawal address
 * @param l1ValidatorAddress New L1 validator address
 * @param l1AccountAddress New L1 account address
 * @param l1AccountEvmAddress New EVM address of account on L1 (informational)
 */
event ValidatorUpdated(
    uint16 indexed validatorId,
    uint256 commission,
    address l2AdminAddress,
    address l2WithdrawAddress,
    string l1ValidatorAddress,
    string l1AccountAddress,
    address l1AccountEvmAddress
);

/**
 * @notice Emitted when a validator is removed from the system
 * @param validatorId ID of the validator removed
 */
event ValidatorRemoved(uint16 indexed validatorId);

/**
 * @notice Emitted when the validator capacity is updated
 * @param validatorId ID of the validator
 * @param oldCapacity Old capacity
 * @param newCapacity New capacity
 */
event ValidatorCapacityUpdated(uint16 indexed validatorId, uint256 oldCapacity, uint256 newCapacity);

/**
 * @notice Emitted when the maximum validator percentage is updated
 * @param oldPercentage Old maximum percentage (in basis points)
 * @param newPercentage New maximum percentage (in basis points)
 */
event MaxValidatorPercentageUpdated(uint256 oldPercentage, uint256 newPercentage);

/**
 * @notice Emitted when a user stakes PLUME on behalf of another user
 * @param sender Address of the sender who initiated the stake
 * @param staker Address of the staker who receives the stake
 * @param validatorId ID of the validator
 * @param amount Amount of $PLUME staked
 */
event StakedOnBehalf(address indexed sender, address indexed staker, uint16 indexed validatorId, uint256 amount);

/**
 * @notice Emitted when admin withdraws tokens from the contract
 * @param token Address of the token withdrawn
 * @param amount Amount withdrawn
 * @param recipient Address receiving the tokens
 */
event AdminWithdraw(address indexed token, uint256 amount, address indexed recipient);

/**
 * @notice Emitted when cooldown interval is set
 * @param interval New cooldown interval in seconds
 */
event CooldownIntervalSet(uint256 interval);

/**
 * @notice Emitted when minimum stake amount is set
 * @param amount New minimum stake amount
 */
event MinStakeAmountSet(uint256 amount);

/**
 * @notice Emitted when stake info is updated by admin
 * @param user Address of the user
 * @param staked Updated staked amount
 * @param cooled Updated cooling amount
 * @param parked Updated parked amount
 * @param cooldownEnd Updated cooldown end timestamp
 * @param lastUpdateTimestamp Last reward update timestamp
 */
event StakeInfoUpdated(
    address indexed user,
    uint256 staked,
    uint256 cooled,
    uint256 parked,
    uint256 cooldownEnd,
    uint256 lastUpdateTimestamp
);

/**
 * @notice Emitted when a vote to slash a validator is cast
 * @param targetValidatorId ID of the validator being voted against
 * @param voterValidatorId ID of the validator casting the vote
 * @param voteExpiration Timestamp when the vote expires
 */
event SlashVoteCast(uint16 indexed targetValidatorId, uint16 indexed voterValidatorId, uint256 voteExpiration);

/**
 * @notice Emitted when a validator is slashed
 * @param validatorId ID of the slashed validator
 * @param slasher Address that triggered the slash
 * @param penaltyAmount Amount of stake potentially burned or redistributed (TBD)
 */
event ValidatorSlashed(uint16 indexed validatorId, address indexed slasher, uint256 penaltyAmount);

/**
 * @notice Emitted when the maximum slash vote duration is set
 * @param duration New maximum duration in seconds
 */
event MaxSlashVoteDurationSet(uint256 duration);

/**
 * @notice Emitted when the treasury address is set
 * @param treasury Address of the new treasury
 */
event TreasurySet(address indexed treasury);

// Treasury Events
event RewardDistributed(address indexed token, uint256 amount, address indexed recipient);

/**
 * @notice Emitted when Plume (native) tokens are received by the treasury
 * @param sender Address of the sender
 * @param amount Amount of Plume received
 */
event PlumeReceived(address indexed sender, uint256 amount);

/**
 * @notice Emitted when a user restakes their rewards
 * @param staker Address of the staker who restaked
 * @param validatorId Validator ID restaked to
 * @param amount Amount of rewards restaked
 */
event RewardsRestaked(address indexed staker, uint16 indexed validatorId, uint256 amount);

// --- Management Facet Events ---
event AdminStakeCorrection(address indexed user, uint256 oldTotalStake, uint256 newTotalStake);

/**
 * @notice Emitted when a validator's active/slashed status is updated
 * @param validatorId ID of the validator
 * @param active The new active status
 * @param slashed The current slashed status
 */
event ValidatorStatusUpdated(uint16 indexed validatorId, bool active, bool slashed);

// Validator Events
event ValidatorCommissionSet(uint16 indexed validatorId, uint256 oldCommission, uint256 newCommission);

event ValidatorAddressesSet(
    uint16 indexed validatorId,
    address oldL2Admin,
    address newL2Admin,
    address oldL2Withdraw,
    address newL2Withdraw,
    string oldL1Validator,
    string newL1Validator,
    string oldL1Account,
    string newL1Account,
    address oldL1AccountEvm,
    address newL1AccountEvm
);

/// @notice Emitted when a new admin is proposed for a validator, starting the two-step ownership transfer.
/// @param validatorId The ID of the validator.
/// @param proposedAdmin The address of the proposed new admin.
event AdminProposed(uint16 indexed validatorId, address indexed proposedAdmin);

// --- Administrative Events ---
event MaxAllowedValidatorCommissionSet(uint256 oldMaxRate, uint256 newMaxRate);

/// @notice Emitted when the maximum number of commission checkpoints per validator is set.
/// @param newLimit The new maximum limit.
event MaxCommissionCheckpointsSet(uint256 newLimit);

// --- Commission Claim Timelock Events ---
event CommissionClaimRequested(
    uint16 indexed validatorId,
    address indexed token,
    address indexed recipient,
    uint256 amount,
    uint256 requestTimestamp
);

event CommissionClaimFinalized(
    uint16 indexed validatorId,
    address indexed token,
    address indexed recipient,
    uint256 amount,
    uint256 finalizeTimestamp
);

/**
 * @notice Emitted when a validator commission rate checkpoint is created.
 * @param validatorId ID of the validator.
 * @param rate The commission rate at this checkpoint.
 * @param timestamp The timestamp of this checkpoint.
 */
event ValidatorCommissionCheckpointCreated(uint16 indexed validatorId, uint256 rate, uint256 timestamp);

/// @notice Emitted when an admin prunes old commission checkpoints for a validator.
/// @param validatorId The ID of the validator.
/// @param count The number of checkpoints that were removed.
event CommissionCheckpointsPruned(uint16 indexed validatorId, uint256 count);

/// @notice Emitted when an admin prunes old reward rate checkpoints for a validator and token.
/// @param validatorId The ID of the validator.
/// @param token The reward token.
/// @param count The number of checkpoints that were removed.
event RewardRateCheckpointsPruned(uint16 indexed validatorId, address indexed token, uint256 count);

// --- NEW SLASH CLEANUP EVENTS ---
/**
 * @notice Emitted when an admin clears a user's active stake record for a slashed validator.
 * @param user The user whose record was cleared.
 * @param slashedValidatorId The ID of the slashed validator.
 * @param amountCleared The amount of active stake that was cleared (considered lost).
 */
event AdminClearedSlashedStake(address indexed user, uint16 indexed slashedValidatorId, uint256 amountCleared);

/**
 * @notice Emitted when an admin clears a user's cooldown record for a slashed validator.
 * @param user The user whose record was cleared.
 * @param slashedValidatorId The ID of the slashed validator.
 * @param amountCleared The amount of cooled funds that were cleared (considered lost).
 */
event AdminClearedSlashedCooldown(address indexed user, uint16 indexed slashedValidatorId, uint256 amountCleared);

/**
 * @notice Emitted when a token is manually added to the historical rewards list by an admin.
 * @param token The address of the token that was added.
 */
event HistoricalRewardTokenAdded(address indexed token);

/**
 * @notice Emitted when a token is manually removed from the historical rewards list by an admin.
 * @dev This is a high-privilege, dangerous operation.
 * @param token The address of the token that was removed.
 */
event HistoricalRewardTokenRemoved(address indexed token);

// @audit
=== PlumeErrors.sol ===
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.25;

/*
 * @title PlumeErrors
 * @author Eugene Y. Q. Shen, Alp Guneysel
 * @notice Common errors used across Plume contracts
 */

// Core errors
/*
 * @notice Thrown when an invalid amount is provided
 * @param amount The invalid amount that was provided
 */
error InvalidAmount(uint256 amount);

error NoActiveStake();

/*
 * @notice Thrown when a zero address is provided for a parameter that cannot be zero
 * @param parameter The name of the parameter that was zero
 */
error ZeroAddress(string parameter);

/*
 * @notice Thrown when trying to perform an operation with a token that doesn't exist in the system
 * @param token The address of the non-existent token
 */
error TokenDoesNotExist(address token);

/*
 * @notice Thrown when a token transfer fails
 */
error TransferError();

// Staking errors
/*
 * @notice Thrown when trying to perform an operation on tokens that are still in cooling period
 */
error TokensInCoolingPeriod();

/*
 * @notice Thrown when trying to withdraw tokens before the cooldown period has ended
 */
error CooldownPeriodNotEnded();

/**
 * @notice Error thrown when stake amount is too small
 * @param providedAmount Amount attempted to stake
 * @param minAmount Minimum required stake amount
 */
error StakeAmountTooSmall(uint256 providedAmount, uint256 minAmount);

/**
 * @notice Error thrown when trying to restake more than available in cooldown
 * @param availableAmount Amount available in cooldown
 * @param requestedAmount Amount requested to restake
 */
error InsufficientCooldownBalance(uint256 availableAmount, uint256 requestedAmount);

/**
 * @notice Error thrown when trying to restake amount exceeds available cooled + parked balance.
 * @param available Total amount available in cooled and parked.
 * @param requested Amount requested to restake.
 */
error InsufficientCooledAndParkedBalance(uint256 available, uint256 requested);

/**
 * @notice Error thrown when trying to restake rewards but there are none available.
 */
error NoRewardsToRestake();

// Validator errors
/*
 * @notice Thrown when trying to interact with a validator that doesn't exist
 * @param validatorId The ID of the non-existent validator
 */
error ValidatorDoesNotExist(uint16 validatorId);

/*
 * @notice Thrown when trying to add a validator with an ID that already exists
 * @param validatorId The ID of the existing validator
 */
error ValidatorAlreadyExists(uint16 validatorId);

/*
 * @notice Thrown when trying to interact with an inactive validator
 * @param validatorId The ID of the inactive validator
 */
error ValidatorInactive(uint16 validatorId);

/*
 * @notice Thrown when a non-admin address tries to perform a validator admin operation
 * @param caller The address of the unauthorized caller
 */
error NotValidatorAdmin(address caller);

/*
 * @notice Thrown when a validator's capacity would be exceeded by an operation
 */
error ValidatorCapacityExceeded();

/*
 * @notice Thrown when a validator's percentage of the total stake would exceed the maximum
 */
error ValidatorPercentageExceeded();

/*
 * @notice Thrown when an operation would affect too many stakers at once
 */
error TooManyStakers();

/// @notice Thrown when a percentage value is invalid (e.g., > 100%).
/// @param percentage The invalid percentage provided (in basis points).
error InvalidPercentage(uint256 percentage);

// Reward errors
/*
 * @notice Thrown when trying to add a token that already exists in the reward token list
 */
error TokenAlreadyExists();

/**
 * @notice Thrown when trying to re-add a token in the same block it was removed.
 * @param token The address of the token.
 */
error CannotReAddTokenInSameBlock(address token);

/*
 * @notice Thrown when array lengths don't match in a function that expects matching arrays
 */
error ArrayLengthMismatch();

/*
 * @notice Thrown when an empty array is provided but a non-empty array is required
 */
error EmptyArray();

/*
 * @notice Thrown when a validator commission exceeds the maximum allowed value
 */
error CommissionTooHigh();

/**
 * @notice Error thrown when commission rate exceeds maximum allowed (100%)
 * @param requested The commission rate requested (scaled by 1e18)
 * @param max The maximum allowed commission rate (1e18)
 */
error CommissionRateTooHigh(uint256 requested, uint256 max);

/*
 * @notice Thrown when a reward rate exceeds the maximum allowed value
 */
error RewardRateExceedsMax();

/*
 * @notice Thrown when a native token transfer fails
 */
error NativeTransferFailed();

/*
 * @notice Thrown when an array index is out of bounds
 * @param index The index that was out of bounds
 * @param length The length of the array
 */
error IndexOutOfRange(uint256 index, uint256 length);

/*
 * @notice Thrown when an index range is invalid
 * @param startIndex The start index
 * @param endIndex The end index
 */
error InvalidIndexRange(uint256 startIndex, uint256 endIndex);

/*
 * @notice Thrown when attempting to add a staker that already exists
 * @param staker The address of the staker that already exists
 */
error StakerExists(address staker);

/*
 * @notice Thrown when attempting to withdraw user funds
 * @param available The amount available for withdrawal
 * @param requested The amount requested for withdrawal
 */
error InsufficientFunds(uint256 available, uint256 requested);

/*
 * @notice Thrown when a native token transfer fails in an admin operation
 */
error AdminTransferFailed();

/*
 * @notice Thrown when an invalid reward rate checkpoint index is provided
 * @param token The token address
 * @param index The invalid index
 */
error InvalidRewardRateCheckpoint(address token, uint256 index);

/*
 * @notice Thrown when a slash vote duration is too long
 */
error SlashVoteDurationTooLong();

// Slashing Errors
error CannotVoteForSelf();
error AlreadyVotedToSlash(uint16 targetValidatorId, uint16 voterValidatorId);
error ValidatorAlreadySlashed(uint16 validatorId);
error UnanimityNotReached(uint256 votes, uint256 required);
error SlashVoteExpired(uint16 targetValidatorId, uint16 voterValidatorId);
error SlashConditionsNotMet(uint16 validatorId);

/// @param admin Address that is already assigned.
error AdminAlreadyAssigned(address admin);

// Treasury Errors
error ZeroAddressToken();
error TokenAlreadyAdded(address token);
error ZeroRecipientAddress();
error ZeroAmount();
error TokenNotRegistered(address token);
error InsufficientPlumeBalance(uint256 requested, uint256 available);
error InsufficientTokenBalance(address token, uint256 requested, uint256 available);
error PlumeTransferFailed(address recipient, uint256 amount);
error VotingPowerProxyCannotBeZero();
error TransferHelperCannotBeZero();
error InsufficientBalance(address token, uint256 available, uint256 required);
error InvalidToken();

/*
 * @dev Thrown when a function call fails to transfer tokens or ETH.
 * @param token The address of the token that failed to transfer, or the zero address for ETH.
 * @param recipient The address of the intended recipient.
 * @param amount The amount that failed to transfer.
 */
error TokenTransferFailed(address token, address recipient, uint256 amount);

/**
 * @dev Thrown when trying to interact with an invalid or unsupported token.
 * @param token The address of the invalid token.
 */
error UnsupportedToken(address token);

/**
 * @dev Thrown when an operation would result in a zero address.
 */
error ZeroAddressProvided();

/**
 * @dev Thrown when trying to withdraw more than the available balance from treasury.
 * @param token The address of the token.
 * @param requested The requested amount.
 * @param available The available amount.
 */
error TreasuryInsufficientBalance(address token, uint256 requested, uint256 available);

/**
 * Validator Errors **
 */

/**
 * @notice Error thrown when trying to create a validator with ID 0 that already exists
 */
error ValidatorIdExists();

/**
 * @notice Error thrown when validator capacity would be exceeded
 * @param validatorId ID of the validator
 * @param currentAmount Current delegated amount
 * @param maxCapacity Maximum capacity of the validator
 * @param requestedAmount Requested amount to add
 */
error ExceedsValidatorCapacity(uint16 validatorId, uint256 currentAmount, uint256 maxCapacity, uint256 requestedAmount);

/**
 * @notice Error thrown when trying to restake from parked/cooled but there is no balance.
 */
error NoWithdrawableBalanceToRestake();

/// @notice Emitted when trying to withdraw but the cooldown period is not complete.
error CooldownNotComplete(uint256 cooldownEnd, uint256 currentTime);

// Core errors
error Unauthorized(address caller, bytes32 requiredRole);
error TreasuryNotSet();
error InternalInconsistency(string message);

// Validator errors
error InvalidUpdateType(uint8 providedType);

// --- New Max Commission Errors ---
error CommissionExceedsMaxAllowed(uint256 requested, uint256 maxAllowed);
error InvalidMaxCommissionRate(uint256 requested, uint256 limit);

// --- Commission Claim Timelock Errors ---
error PendingClaimExists(uint16 validatorId, address token);
error NoPendingClaim(uint16 validatorId, address token);
error ClaimNotReady(uint16 validatorId, address token, uint256 readyTimestamp);

/// @notice Thrown when cooldown interval is too short relative to max slash vote duration.
/// @param newCooldownInterval The proposed cooldown interval.
/// @param currentMaxSlashVoteDuration The current maximum slash vote duration.
error CooldownTooShortForSlashVote(uint256 newCooldownInterval, uint256 currentMaxSlashVoteDuration);

/// @notice Thrown when max slash vote duration is too long relative to cooldown interval.
/// @param newMaxSlashVoteDuration The proposed maximum slash vote duration.
/// @param currentCooldownInterval The current cooldown interval.
error SlashVoteDurationTooLongForCooldown(uint256 newMaxSlashVoteDuration, uint256 currentCooldownInterval);

/// @notice Thrown when slash vote duration is not shorter than the commission claim timelock.
/// @param slashVoteDuration The proposed slash vote duration.
/// @param commissionTimelock The current commission claim timelock.
error SlashVoteDurationExceedsCommissionTimelock(uint256 slashVoteDuration, uint256 commissionTimelock);

/// @notice Thrown when an address that is not the pending admin tries to accept admin role.
/// @param caller The address of the unauthorized caller.
/// @param validatorId The ID of the validator.
error NotPendingAdmin(address caller, uint16 validatorId);

/// @notice Thrown when trying to accept admin role for a validator with no pending admin.
/// @param validatorId The ID of the validator.
error NoPendingAdmin(uint16 validatorId);

/// @notice Thrown when a validator tries to create more commission checkpoints than the allowed limit.
/// @param validatorId The ID of the validator.
/// @param max The maximum number of checkpoints allowed.
error MaxCommissionCheckpointsExceeded(uint16 validatorId, uint256 max);

/// @notice Thrown when attempting to prune all checkpoints from a validator's history, which is not allowed.
error CannotPruneAllCheckpoints();

/// @notice Thrown when an invalid interval is provided (e.g. zero)
/// @param interval The invalid interval.
error InvalidInterval(uint256 interval);

/**
 * @notice Thrown when an action is attempted on a validator that has been slashed.
 * @param validatorId The ID of the slashed validator.
 */
error ActionOnSlashedValidatorError(uint16 validatorId);

/**
 * @notice Thrown when an admin tries to clear records for a validator that isn't actually slashed.
 * @param validatorId The ID of the validator that is not slashed.
 */
error ValidatorNotSlashed(uint16 validatorId);

/**
 * @notice Thrown when a function is not active.
 */
error NotActive();

// @audit
=== PlumeStakingStorage.sol ===
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.25;

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";

/**
 * @title PlumeStakingStorage
 * @author Eugene Y. Q. Shen, Alp Guneysel
 * @notice Storage definitions for PlumeStaking system
 */
library PlumeStakingStorage {

    // --- BEGIN ADDED CONSTANTS ---
    address public constant PLUME_NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
    uint256 public constant REWARD_PRECISION = 1e18;
    // --- END ADDED CONSTANTS ---

    // Storage position for the diamond storage
    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256("plume.staking.storage");

    /**
     * @notice Represents a user's stake information with a specific validator
     */
    struct UserValidatorStake {
        uint256 staked; // Amount currently staked with this validator
    }

    /**
     * @notice Represents a user's global stake information across all validators
     */
    struct StakeInfo {
        uint256 staked; // Total amount staked across all validators
        uint256 cooled; // Total amount in cooling period across all validators
        uint256 parked; // Total amount ready for withdrawal
    }

    /**
     * @notice Represents a cooldown entry for a user with a specific validator
     */
    struct CooldownEntry {
        uint256 amount; // Amount in cooldown
        uint256 cooldownEndTime; // When the cooldown period ends
    }

    /**
     * @notice Represents a rate checkpoint for reward calculations
     */
    struct RateCheckpoint {
        uint256 timestamp; // When this rate was set
        uint256 rate; // The reward rate at this timestamp
        uint256 cumulativeIndex; // Cumulative reward index at this checkpoint
    }

    /**
     * @notice Main storage layout for the staking system
     */
    struct Layout {
        // === Core Staking State ===
        uint256 totalStaked; // Total amount staked across all validators
        uint256 totalCooling; // Total amount in cooling period
        uint256 totalWithdrawable; // Total amount available for withdrawal
        // === Reward Token Management ===
        address[] rewardTokens; // Array of all reward token addresses
        mapping(address => bool) isRewardToken; // token => whether it's an active reward token
        mapping(address => uint256) rewardRates; // token => reward rate
        mapping(address => uint256) maxRewardRates; // token => maximum allowed reward rate
        mapping(address => uint256) totalClaimableByToken; // token => total claimable amount
        // === User State Mappings ===
        mapping(address => StakeInfo) stakeInfo; // user => global stake info
        mapping(address => mapping(uint16 => UserValidatorStake)) userValidatorStakes; // user => validatorId => stake info
        mapping(address => mapping(uint16 => CooldownEntry)) userValidatorCooldowns; // user => validatorId => cooldown info
        mapping(address => uint16[]) userValidators; // user => list of validators they've staked with
        mapping(address => mapping(uint16 => bool)) userHasStakedWithValidator; // user => validatorId => has staked
        mapping(address => mapping(uint16 => uint256)) userValidatorStakeStartTime; // user => validatorId => stake start time
        // === Validator State ===
        mapping(uint16 => ValidatorInfo) validators; // validatorId => validator info
        uint16[] validatorIds; // Array of all validator IDs
        mapping(uint16 => bool) validatorExists; // validatorId => exists
        mapping(uint16 => uint256) validatorTotalStaked; // validatorId => total staked amount
        mapping(uint16 => uint256) validatorTotalCooling; // validatorId => total cooling amount
        mapping(uint16 => address[]) validatorStakers; // validatorId => list of stakers
        mapping(uint16 => mapping(address => bool)) isStakerForValidator; // validatorId => user => is staker
        mapping(address => mapping(uint16 => uint256)) userIndexInValidatorStakers; // user => validatorId => index in stakers array
        // === Reward System ===
        mapping(uint16 => mapping(address => uint256)) validatorAccruedCommission; // validatorId => token => commission amount
        mapping(uint16 => mapping(address => uint256)) validatorRewardPerTokenCumulative; // validatorId => token => cumulative reward per token
        mapping(uint16 => mapping(address => uint256)) validatorLastUpdateTimes; // validatorId => token => last update time
        mapping(address => mapping(uint16 => mapping(address => uint256))) userRewards; // user => validatorId => token => reward amount
        mapping(address => mapping(uint16 => mapping(address => uint256))) userValidatorRewardPerTokenPaid; // user => validatorId => token => last paid rate
        mapping(address => mapping(uint16 => mapping(address => uint256))) userLastCheckpointIndex; // user => validatorId => token => checkpoint index
        mapping(address => mapping(uint16 => mapping(address => uint256))) userValidatorRewardPerTokenPaidTimestamp; // user => validatorId => token => timestamp
        mapping(address => mapping(uint16 => bool)) userHasPendingRewards; // user => validatorId => has pending rewards
        // === Reward Rate Checkpoints ===
        mapping(address => RateCheckpoint[]) rewardRateCheckpoints; // token => rate checkpoints
        mapping(uint16 => mapping(address => RateCheckpoint[])) validatorRewardRateCheckpoints; // validatorId => token => rate checkpoints
        mapping(uint16 => RateCheckpoint[]) validatorCommissionCheckpoints; // validatorId => commission checkpoints
        // === Configuration ===
        uint256 minStakeAmount; // Minimum staking amount
        uint256 cooldownInterval; // Duration of the cooldown period in seconds
        uint256 maxValidatorPercentage; // Maximum percentage of total stake a validator can have (in basis points)
        uint256 maxAllowedValidatorCommission; // Maximum allowed commission for any validator
        // === Access Control ===
        mapping(bytes32 => mapping(address => bool)) hasRole; // role => address => has role
        bool initialized; // Whether the contract has been initialized
        bool accessControlFacetInitialized; // Whether the AccessControlFacet has been initialized
        // === Validator Management ===
        mapping(uint16 => mapping(uint16 => uint256)) slashingVotes; // maliciousValidatorId => votingValidatorId => vote expiration
        uint256 maxSlashVoteDurationInSeconds; // Maximum duration for slash votes
        mapping(uint16 => uint256) slashVoteCounts; // validatorId => active vote count
        mapping(address => uint16) adminToValidatorId; // admin address => validatorId
        mapping(address => bool) isAdminAssigned; // admin address => is assigned to a validator
        // === Commission Claims ===
        mapping(uint16 => mapping(address => PendingCommissionClaim)) pendingCommissionClaims; // validatorId => token => pending claim
        // === Flags ===
        mapping(address => bool) hasPendingRewards; // user => whether they have pending rewards to claim
        // --- NEW VARIABLES APPENDED FOR UPGRADE ---
        uint16 maxCommissionCheckpoints; // Max commission checkpoints per validator
        mapping(uint16 => address) pendingAdmins; // validatorId => pending admin address for ownership transfer
        // === Token Lifecycle Tracking ===
        mapping(address => uint256) tokenAdditionTimestamps; // token => when it was added
        mapping(address => uint256) tokenRemovalTimestamps; // token => when it was removed
        mapping(address => bool) isHistoricalRewardToken; // token => true if it has ever been a reward token
        address[] historicalRewardTokens; // append-only list of all tokens that have ever been rewards
    }

    /**
     * @notice Information about a validator
     */
    struct ValidatorInfo {
        uint16 validatorId; // Validator ID
        bool active; // Whether the validator is currently active
        bool slashed; // Whether the validator has been slashed
        uint256 slashedAtTimestamp; // When the validator was slashed (0 if not slashed)
        uint256 maxCapacity; // Maximum amount that can be staked with this validator (0 = unlimited)
        uint256 delegatedAmount; // Total amount delegated to this validator
        uint256 commission; // Commission rate (using REWARD_PRECISION as base)
        address l2AdminAddress; // Admin address (multisig)
        address l2WithdrawAddress; // Address for validator rewards
        string l1ValidatorAddress; // L1 validator address (for reference)
        string l1AccountAddress; // L1 account address (for reference)
        address l1AccountEvmAddress; // EVM address of account on L1 (for reference)
    }

    /**
     * @notice Pending commission claim information
     */
    struct PendingCommissionClaim {
        uint256 amount; // Amount to be claimed
        uint256 requestTimestamp; // When the claim was requested
        address token; // Token being claimed
        address recipient; // Address to receive the claim
    }

    // Constants
    uint256 constant COMMISSION_CLAIM_TIMELOCK = 7 days;

    /**
     * @notice Returns the storage layout
     */
    function layout() internal pure returns (Layout storage l) {
        bytes32 position = DIAMOND_STORAGE_POSITION;
        assembly {
            l.slot := position
        }
    }

}

// @audit

=== PlumeRoles.sol ===
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.25;

/**
 * @title PlumeRoles
 * @author Eugene Y. Q. Shen, Alp Guneysel
 * @notice Defines role constants used for access control in the PlumeStaking Diamond.
 */
library PlumeRoles {

    // Default admin role (can grant/revoke other roles)
    bytes32 public constant ADMIN_ROLE = keccak256("ADMIN_ROLE");

    // Role for performing diamond upgrades (diamondCut)
    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER_ROLE");

    // Role for managing validator settings
    bytes32 public constant VALIDATOR_ROLE = keccak256("VALIDATOR_ROLE");

    // Role for managing reward settings and distribution
    bytes32 public constant REWARD_MANAGER_ROLE = keccak256("REWARD_MANAGER_ROLE");

    // Role for managing time-locked actions
    bytes32 public constant TIMELOCK_ROLE = keccak256("TIMELOCK_ROLE");

}

// @audit