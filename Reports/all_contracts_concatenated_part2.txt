=== ValidatorFacet.sol ===
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.25;

import {
    AdminAlreadyAssigned,
    AlreadyVotedToSlash,
    CannotVoteForSelf,
    ClaimNotReady,
    CommissionExceedsMaxAllowed,
    CommissionRateTooHigh,
    InvalidAmount,
    InvalidUpdateType,
    NativeTransferFailed,
    NoPendingAdmin,
    NoPendingClaim,
    NotActive,
    NotPendingAdmin,
    NotValidatorAdmin,
    PendingClaimExists,
    SlashConditionsNotMet,
    SlashVoteDurationTooLong,
    SlashVoteExpired,
    TokenDoesNotExist,
    TooManyStakers,
    TreasuryNotSet,
    UnanimityNotReached,
    Unauthorized,
    ValidatorAlreadyExists,
    ValidatorAlreadySlashed,
    ValidatorDoesNotExist,
    ValidatorInactive,
    ZeroAddress
} from "../lib/PlumeErrors.sol";
import {
    AdminProposed,
    CommissionClaimFinalized,
    CommissionClaimRequested,
    SlashVoteCast,
    ValidatorAdded,
    ValidatorAddressesSet,
    ValidatorCapacityUpdated,
    ValidatorCommissionClaimed,
    ValidatorCommissionSet,
    ValidatorSlashed,
    ValidatorStatusUpdated,
    ValidatorUpdated
} from "../lib/PlumeEvents.sol";

import { PlumeRewardLogic } from "../lib/PlumeRewardLogic.sol";
import { PlumeStakingStorage } from "../lib/PlumeStakingStorage.sol";

import { OwnableInternal } from "@solidstate/access/ownable/OwnableInternal.sol";
import { OwnableStorage } from "@solidstate/access/ownable/OwnableStorage.sol";
import { DiamondBaseStorage } from "@solidstate/proxy/diamond/base/DiamondBaseStorage.sol";

import { ReentrancyGuardUpgradeable } from "@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { SafeERC20 } from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import { Address } from "@openzeppelin/contracts/utils/Address.sol";
import { SafeCast } from "@openzeppelin/contracts/utils/math/SafeCast.sol";

import { IAccessControl } from "../interfaces/IAccessControl.sol";

import { IPlumeStakingRewardTreasury } from "../interfaces/IPlumeStakingRewardTreasury.sol";
import { PlumeRoles } from "../lib/PlumeRoles.sol";
import { RewardsFacet } from "./RewardsFacet.sol";
/**
 * @title ValidatorFacet
 * @author Eugene Y. Q. Shen, Alp Guneysel
 * @notice Facet handling validator management: adding, updating, commission, capacity.
 */

contract ValidatorFacet is ReentrancyGuardUpgradeable, OwnableInternal {

    struct ValidatorListData {
        uint16 id;
        uint256 totalStaked;
        uint256 commission;
    }

    using SafeERC20 for IERC20;
    using Address for address payable;
    using PlumeStakingStorage for PlumeStakingStorage.Layout;
    using SafeCast for uint256;

    // Modifier for Validator Admin checks
    modifier onlyValidatorAdmin(
        uint16 validatorId
    ) {
        // Use PlumeStakingStorage.layout() directly
        if (!PlumeStakingStorage.layout().validatorExists[validatorId]) {
            revert ValidatorDoesNotExist(validatorId);
        }
        if (msg.sender != PlumeStakingStorage.layout().validators[validatorId].l2AdminAddress) {
            revert NotValidatorAdmin(msg.sender);
        }
        _;
    }

    // --- Modifiers ---

    /**
     * @dev Modifier to check role using the AccessControlFacet.
     */
    modifier onlyRole(
        bytes32 _role
    ) {
        if (!IAccessControl(address(this)).hasRole(_role, msg.sender)) {
            revert Unauthorized(msg.sender, _role);
        }
        _;
    }

    /**
     * @dev Modifier to check if a validator exists.
     */
    modifier _validateValidatorExists(
        uint16 validatorId
    ) {
        if (!PlumeStakingStorage.layout().validatorExists[validatorId]) {
            revert ValidatorDoesNotExist(validatorId);
        }
        _;
    }

    modifier _validateIsToken(
        address token
    ) {
        if (!PlumeStakingStorage.layout().isRewardToken[token]) {
            revert TokenDoesNotExist(token);
        }
        _;
    }

    // --- Validator Management (Owner/Admin) ---

    /**
     * @notice Add a new validator (Owner only)
     * @param validatorId UUID for the validator
     * @param commission Commission rate (as fraction of REWARD_PRECISION)
     * @param l2AdminAddress Admin address for the validator
     * @param l2WithdrawAddress Withdrawal address for validator rewards
     * @param l1ValidatorAddress Address of validator on L1 (informational)
     * @param l1AccountAddress Address of account on L1 (informational)
     * @param l1AccountEvmAddress EVM address of account on L1 (informational)
     */
    function addValidator(
        uint16 validatorId,
        uint256 commission,
        address l2AdminAddress,
        address l2WithdrawAddress,
        string calldata l1ValidatorAddress,
        string calldata l1AccountAddress,
        address l1AccountEvmAddress,
        uint256 maxCapacity
    ) external onlyRole(PlumeRoles.VALIDATOR_ROLE) {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();

        if ($.validatorExists[validatorId]) {
            revert ValidatorAlreadyExists(validatorId);
        }
        if (l2AdminAddress == address(0)) {
            revert ZeroAddress("l2AdminAddress");
        }
        if (l2WithdrawAddress == address(0)) {
            revert ZeroAddress("l2WithdrawAddress");
        }

        // Check against the system-wide maximum allowed commission.
        // maxAllowedValidatorCommission defaults to 0 if not set by admin.
        // If it's 0, any commission > 0 will fail, forcing admin to set a rate.
        // The setter for maxAllowedValidatorCommission ensures it's <= REWARD_PRECISION / 2 (50%).
        if (commission > $.maxAllowedValidatorCommission) {
            revert CommissionExceedsMaxAllowed(commission, $.maxAllowedValidatorCommission);
        }

        // Check if admin address is already assigned using the dedicated mapping
        if ($.isAdminAssigned[l2AdminAddress]) {
            revert AdminAlreadyAssigned(l2AdminAddress);
        }

        PlumeStakingStorage.ValidatorInfo storage validator = $.validators[validatorId];
        validator.validatorId = validatorId;
        validator.commission = commission;
        validator.delegatedAmount = 0;
        validator.l2AdminAddress = l2AdminAddress;
        validator.l2WithdrawAddress = l2WithdrawAddress;
        validator.l1ValidatorAddress = l1ValidatorAddress;
        validator.l1AccountAddress = l1AccountAddress;
        validator.l1AccountEvmAddress = l1AccountEvmAddress;
        validator.active = true;
        validator.slashed = false;
        validator.maxCapacity = maxCapacity;

        $.validatorIds.push(validatorId);
        $.validatorExists[validatorId] = true;
        // Add admin to ID mapping
        $.adminToValidatorId[l2AdminAddress] = validatorId;
        // Mark admin as assigned in the dedicated mapping
        $.isAdminAssigned[l2AdminAddress] = true;

        // Initialize last update times and create initial checkpoints for all reward tokens
        address[] memory rewardTokens = $.rewardTokens;
        for (uint256 i = 0; i < rewardTokens.length; i++) {
            address token = rewardTokens[i];
            $.validatorLastUpdateTimes[validatorId][token] = block.timestamp;
            // The validator inherits the current global rate for this token.
            uint256 currentGlobalRate = $.rewardRates[token];
            PlumeRewardLogic.createRewardRateCheckpoint($, token, validatorId, currentGlobalRate);
        }

        emit ValidatorAdded(
            validatorId,
            commission,
            l2AdminAddress,
            l2WithdrawAddress,
            l1ValidatorAddress,
            l1AccountAddress,
            l1AccountEvmAddress
        );
    }

    /**
     * @notice Set the maximum capacity for a validator (Owner only)
     * @param validatorId ID of the validator
     * @param maxCapacity New maximum capacity
     */
    function setValidatorCapacity(
        uint16 validatorId,
        uint256 maxCapacity
    ) external onlyRole(PlumeRoles.VALIDATOR_ROLE) _validateValidatorExists(validatorId) {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();
        PlumeStakingStorage.ValidatorInfo storage validator = $.validators[validatorId];

        // Check if validator is active and not slashed
        if (!validator.active || validator.slashed) {
            revert ValidatorInactive(validatorId);
        }

        uint256 oldCapacity = validator.maxCapacity;
        validator.maxCapacity = maxCapacity;

        emit ValidatorCapacityUpdated(validatorId, oldCapacity, maxCapacity);
    }

    /**
     * @notice Set the active/inactive status for a validator
     * @dev Caller must have ADMIN_ROLE.
     * @param validatorId ID of the validator
     * @param newActiveStatus The desired active status (true for active, false for inactive)
     */
    function setValidatorStatus(
        uint16 validatorId,
        bool newActiveStatus
    ) external onlyRole(PlumeRoles.ADMIN_ROLE) _validateValidatorExists(validatorId) {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();
        PlumeStakingStorage.ValidatorInfo storage validator = $.validators[validatorId];

        // Prevent activating an already slashed validator through this function
        if (newActiveStatus && validator.slashed) {
            revert ValidatorAlreadySlashed(validatorId);
        }

        bool currentStatus = validator.active;

        // If status is actually changing
        if (currentStatus != newActiveStatus) {
            address[] memory rewardTokens = $.rewardTokens;

            // If going INACTIVE: settle validator commission and record timestamp
            if (!newActiveStatus && currentStatus) {
                // Settle commission for validator using current rates
                PlumeRewardLogic._settleCommissionForValidatorUpToNow($, validatorId);

                // Record when the validator became inactive (reuse slashedAtTimestamp field)
                // This allows existing reward logic to cap rewards at this timestamp
                validator.slashedAtTimestamp = block.timestamp;

                // Create a zero-rate checkpoint for all reward tokens to signal inactivity start
                for (uint256 i = 0; i < rewardTokens.length; i++) {
                    PlumeRewardLogic.createRewardRateCheckpoint($, rewardTokens[i], validatorId, 0);
                }

                // NOTE: User rewards will be settled naturally when users interact
                // (stake, unstake, claim, etc.) due to the timestamp cap in reward logic
            }

            // Update the status
            validator.active = newActiveStatus;

            // If going ACTIVE: reset timestamps and clear the timestamp cap
            if (newActiveStatus && !currentStatus) {
                // Create a new checkpoint to restore the reward rate, signaling activity resumes
                for (uint256 i = 0; i < rewardTokens.length; i++) {
                    address token = rewardTokens[i];
                    $.validatorLastUpdateTimes[validatorId][token] = block.timestamp;
                    uint256 currentGlobalRate = $.rewardRates[token];
                    PlumeRewardLogic.createRewardRateCheckpoint($, token, validatorId, currentGlobalRate);
                }
                // Clear the timestamp since validator is active again (unless actually slashed)
                if (!validator.slashed) {
                    validator.slashedAtTimestamp = 0;
                }
            }
        }

        emit ValidatorStatusUpdated(validatorId, newActiveStatus, validator.slashed);
    }

    /**
     * @notice Set the commission rate for a specific validator.
     * @dev Caller must be the l2AdminAddress for the validator.
     *      Triggers reward updates for stakers and creates a commission checkpoint.
     * @param validatorId ID of the validator to update.
     * @param newCommission The new commission rate (scaled by 1e18).
     */
    function setValidatorCommission(
        uint16 validatorId,
        uint256 newCommission
    ) external onlyValidatorAdmin(validatorId) {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();
        PlumeStakingStorage.ValidatorInfo storage validator = $.validators[validatorId];

        // Check if validator is active and not slashed
        if (!validator.active || validator.slashed) {
            revert ValidatorInactive(validatorId);
        }

        // Check against the system-wide maximum allowed commission.
        if (newCommission > $.maxAllowedValidatorCommission) {
            revert CommissionExceedsMaxAllowed(newCommission, $.maxAllowedValidatorCommission);
        }

        uint256 oldCommission = validator.commission;

        // If the commission rate is the same, there's nothing to do.
        if (oldCommission == newCommission) {
            return;
        }

        // Settle commissions accrued with the old rate up to this point.
        PlumeRewardLogic._settleCommissionForValidatorUpToNow($, validatorId);

        // Now update the validator's commission rate to the new rate.
        validator.commission = newCommission;

        // Create a checkpoint for the new commission rate.
        // This records the new rate effective from this block.timestamp.
        PlumeRewardLogic.createCommissionRateCheckpoint($, validatorId, newCommission);

        emit ValidatorCommissionSet(validatorId, oldCommission, newCommission);
    }

    /**
     * @notice Set various addresses associated with a validator.
     * @dev Caller must be the l2AdminAddress for the validator.
     *      Updates are optional: pass address(0) or "" to keep the current value.
     * @param validatorId ID of the validator to update.
     * @param newL2AdminAddress The new admin address (or address(0) to keep current).
     * @param newL2WithdrawAddress The new withdraw address (or address(0) to keep current).
     * @param newL1ValidatorAddress The new L1 validator address string (or "" to keep current).
     * @param newL1AccountAddress The new L1 account address string (or "" to keep current).
     * @param newL1AccountEvmAddress The new L1 account EVM address (or address(0) to keep current).
     */
    function setValidatorAddresses(
        uint16 validatorId,
        address newL2AdminAddress,
        address newL2WithdrawAddress,
        string calldata newL1ValidatorAddress,
        string calldata newL1AccountAddress,
        address newL1AccountEvmAddress
    ) external onlyValidatorAdmin(validatorId) {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();
        PlumeStakingStorage.ValidatorInfo storage validator = $.validators[validatorId];

        // Check if validator is active and not slashed
        if (!validator.active || validator.slashed) {
            revert ValidatorInactive(validatorId);
        }

        address oldL2AdminAddress = validator.l2AdminAddress;
        address oldL2WithdrawAddress = validator.l2WithdrawAddress;
        string memory oldL1ValidatorAddress = validator.l1ValidatorAddress;
        string memory oldL1AccountAddress = validator.l1AccountAddress;
        address oldL1AccountEvmAddress = validator.l1AccountEvmAddress;

        // Update L2 Admin Address if provided and different
        if (newL2AdminAddress != address(0) && newL2AdminAddress != validator.l2AdminAddress) {
            // This now becomes a proposal, not a direct change.
            // The check for whether the new admin is already assigned moves to acceptAdmin.
            $.pendingAdmins[validatorId] = newL2AdminAddress;
            emit AdminProposed(validatorId, newL2AdminAddress);
        }

        // Update L2 Withdraw Address if provided and different
        if (newL2WithdrawAddress != address(0) && newL2WithdrawAddress != validator.l2WithdrawAddress) {
            if (newL2WithdrawAddress == address(0)) {
                // Add specific check for zero address
                revert ZeroAddress("newL2WithdrawAddress");
            }
            validator.l2WithdrawAddress = newL2WithdrawAddress;
        }

        // Update L1 Validator Address string if provided
        if (bytes(newL1ValidatorAddress).length > 0) {
            validator.l1ValidatorAddress = newL1ValidatorAddress;
        }

        // Update L1 Account Address string if provided
        if (bytes(newL1AccountAddress).length > 0) {
            validator.l1AccountAddress = newL1AccountAddress;
        }

        // Update L1 Account EVM Address if provided
        // No need to check for zero address here, as address(0) might be valid representation
        if (newL1AccountEvmAddress != address(0)) {
            validator.l1AccountEvmAddress = newL1AccountEvmAddress;
        }

        // Emit the correct event with old and new values
        // Note: The newL2AdminAddress in this event will reflect the *current* admin,
        // as the change is now pending and not yet effective.
        emit ValidatorAddressesSet(
            validatorId,
            oldL2AdminAddress,
            validator.l2AdminAddress, // This remains the old admin until accepted
            oldL2WithdrawAddress,
            validator.l2WithdrawAddress,
            oldL1ValidatorAddress,
            validator.l1ValidatorAddress,
            oldL1AccountAddress,
            validator.l1AccountAddress,
            oldL1AccountEvmAddress,
            validator.l1AccountEvmAddress
        );
    }

    /**
     * @notice Allows a proposed new admin to accept the admin role for a validator.
     * @dev Completes the two-step admin transfer process initiated by `setValidatorAddresses`.
     * @param validatorId The ID of the validator for which to accept the admin role.
     */
    function acceptAdmin(
        uint16 validatorId
    ) external nonReentrant _validateValidatorExists(validatorId) {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();
        address newAdmin = msg.sender;

        // Check 1: There must be a pending admin for this validator.
        address pendingAdmin = $.pendingAdmins[validatorId];
        if (pendingAdmin == address(0)) {
            revert NoPendingAdmin(validatorId);
        }

        // Check 2: The caller must be the designated pending admin.
        if (newAdmin != pendingAdmin) {
            revert NotPendingAdmin(newAdmin, validatorId);
        }

        // Check 3: The new admin cannot already be assigned to another validator.
        if ($.isAdminAssigned[newAdmin]) {
            revert AdminAlreadyAssigned(newAdmin);
        }

        PlumeStakingStorage.ValidatorInfo storage validator = $.validators[validatorId];
        address oldAdmin = validator.l2AdminAddress;

        // Finalize the change
        validator.l2AdminAddress = newAdmin;

        // Update admin tracking mappings
        delete $.adminToValidatorId[oldAdmin];
        $.adminToValidatorId[newAdmin] = validatorId;
        $.isAdminAssigned[oldAdmin] = false;
        $.isAdminAssigned[newAdmin] = true;

        // Clear the pending admin
        delete $.pendingAdmins[validatorId];

        // Emit the final event showing the successful change
        emit ValidatorAddressesSet(
            validatorId,
            oldAdmin,
            newAdmin,
            validator.l2WithdrawAddress, // Unchanged
            validator.l2WithdrawAddress, // Unchanged
            validator.l1ValidatorAddress, // Unchanged
            validator.l1ValidatorAddress, // Unchanged
            validator.l1AccountAddress, // Unchanged
            validator.l1AccountAddress, // Unchanged
            validator.l1AccountEvmAddress, // Unchanged
            validator.l1AccountEvmAddress // Unchanged
        );
    }

    /**
     * @notice Request a commission claim for a validator and token (starts timelock)
     * @dev Only callable by validator admin. Amount is locked at request time.
     */
    function requestCommissionClaim(
        uint16 validatorId,
        address token
    )
        external
        onlyValidatorAdmin(validatorId)
        nonReentrant
        _validateValidatorExists(validatorId)
        _validateIsToken(token)
    {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();
        PlumeStakingStorage.ValidatorInfo storage validator = $.validators[validatorId];

        if (!validator.active || validator.slashed) {
            revert ValidatorInactive(validatorId);
        }

        // Settle commission up to now to ensure accurate amount
        PlumeRewardLogic._settleCommissionForValidatorUpToNow($, validatorId);

        uint256 amount = $.validatorAccruedCommission[validatorId][token];
        if (amount == 0) {
            revert InvalidAmount(0);
        }
        if ($.pendingCommissionClaims[validatorId][token].amount > 0) {
            revert PendingClaimExists(validatorId, token);
        }
        address recipient = validator.l2WithdrawAddress;
        uint256 nowTs = block.timestamp;
        $.pendingCommissionClaims[validatorId][token] = PlumeStakingStorage.PendingCommissionClaim({
            amount: amount,
            requestTimestamp: nowTs,
            token: token,
            recipient: recipient
        });
        // Zero out accrued commission immediately
        $.validatorAccruedCommission[validatorId][token] = 0;

        emit CommissionClaimRequested(validatorId, token, recipient, amount, nowTs);
    }

    /**
     * @notice Finalize a commission claim after timelock expires
     * @dev Only callable by validator admin. Pays out the pending claim if ready.
     */
    function finalizeCommissionClaim(
        uint16 validatorId,
        address token
    ) external onlyValidatorAdmin(validatorId) nonReentrant returns (uint256) {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();
        PlumeStakingStorage.ValidatorInfo storage validator = $.validators[validatorId];

        PlumeStakingStorage.PendingCommissionClaim storage claim = $.pendingCommissionClaims[validatorId][token];

        if (claim.amount == 0) {
            revert NoPendingClaim(validatorId, token);
        }

        uint256 readyTimestamp = claim.requestTimestamp + PlumeStakingStorage.COMMISSION_CLAIM_TIMELOCK;

        // First, check if the timelock has passed from the perspective of the current block.
        if (block.timestamp < readyTimestamp) {
            revert ClaimNotReady(validatorId, token, readyTimestamp);
        }

        // --- REVISED SLASHING CHECK ---
        // If the validator is slashed, the claim is only considered valid if its timelock was
        // fully completed BEFORE the slash occurred. This invalidates any pending claims.
        if (validator.slashed && readyTimestamp >= validator.slashedAtTimestamp) {
            revert ValidatorInactive(validatorId);
        }

        // For a non-slashed validator, simply require it to be active to finalize a claim.
        if (!validator.slashed && !validator.active) {
            revert ValidatorInactive(validatorId);
        }

        uint256 amount = claim.amount;
        address recipient = claim.recipient;
        // Clear pending claim
        delete $.pendingCommissionClaims[validatorId][token];
        // Transfer from treasury
        address treasury = RewardsFacet(address(this)).getTreasury();
        if (treasury == address(0)) {
            revert TreasuryNotSet();
        }
        IPlumeStakingRewardTreasury(treasury).distributeReward(token, amount, recipient);
        emit CommissionClaimFinalized(validatorId, token, recipient, amount, block.timestamp);
        return amount;
    }

    /**
     * @notice Clean up expired votes for a validator and return the current valid vote count
     * @dev This function removes expired votes and updates the vote count accordingly
     * @param validatorId The validator to clean up votes for
     * @return newActiveVoteCount The number of valid (non-expired) votes remaining
     */
    function _cleanupExpiredVotes(
        uint16 validatorId
    ) internal returns (uint256 newActiveVoteCount) {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();

        uint256 voteCount = $.slashVoteCounts[validatorId];
        if (voteCount == 0) {
            return 0; // No votes to clean up
        }

        uint16[] memory allValidatorIds = $.validatorIds;
        uint256 newActiveVoteCount = 0;

        for (uint256 i = 0; i < allValidatorIds.length; i++) {
            uint16 voterValidatorId = allValidatorIds[i];
            if (voterValidatorId == validatorId) {
                continue;
            }

            uint256 voteExpiration = $.slashingVotes[validatorId][voterValidatorId];
            if (voteExpiration > 0) {
                // A vote from this validator exists.
                PlumeStakingStorage.ValidatorInfo storage voterValidator = $.validators[voterValidatorId];
                bool voterIsEligible = voterValidator.active && !voterValidator.slashed;
                bool voteHasExpired = block.timestamp >= voteExpiration;

                if (voterIsEligible && !voteHasExpired) {
                    // Vote is valid and active.
                    newActiveVoteCount++;
                } else {
                    // Vote is invalid (voter ineligible or vote expired). Clean it up.
                    delete $.slashingVotes[validatorId][voterValidatorId];
                }
            }
        }

        // Update the vote count to reflect only the currently valid, active votes.
        $.slashVoteCounts[validatorId] = newActiveVoteCount;
        return newActiveVoteCount;
    }

    /**
     * @notice Vote to slash a malicious validator
     * @dev Caller must be the L2 admin of an *active* validator.
     * @param maliciousValidatorId ID of the malicious validator to vote against
     * @param voteExpiration Timestamp when this vote expires
     */
    function voteToSlashValidator(uint16 maliciousValidatorId, uint256 voteExpiration) external nonReentrant {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();
        address voterAdmin = msg.sender;
        uint16 voterValidatorId = $.adminToValidatorId[voterAdmin];

        // Check 1: Voter is an active validator admin for the ID derived from the mapping
        if ($.validators[voterValidatorId].l2AdminAddress != voterAdmin || !$.validators[voterValidatorId].active) {
            revert NotValidatorAdmin(voterAdmin);
        }

        // Check 2: Target validator exists, not slashed, and is active
        PlumeStakingStorage.ValidatorInfo storage targetValidator = $.validators[maliciousValidatorId];
        if (!$.validatorExists[maliciousValidatorId]) {
            revert ValidatorDoesNotExist(maliciousValidatorId);
        }
        if (targetValidator.slashed) {
            revert ValidatorAlreadySlashed(maliciousValidatorId);
        }
        if (!targetValidator.active) {
            revert ValidatorInactive(maliciousValidatorId);
        }

        // Check 3: Cannot vote for self
        if (voterValidatorId == maliciousValidatorId) {
            revert CannotVoteForSelf();
        }

        // Check 4: Vote expiration validity
        if (
            voteExpiration <= block.timestamp || $.maxSlashVoteDurationInSeconds == 0 // Prevent voting if duration not // set
           || voteExpiration > block.timestamp + $.maxSlashVoteDurationInSeconds
        ) {
            revert SlashVoteDurationTooLong();
        }

        // Check 5: Voter hasn't already voted recently (check existing vote expiration)
        uint256 currentVoteExpiration = $.slashingVotes[maliciousValidatorId][voterValidatorId];
        if (currentVoteExpiration > block.timestamp) {
            revert AlreadyVotedToSlash(maliciousValidatorId, voterValidatorId);
        }

        // Clean up expired votes before processing new vote
        _cleanupExpiredVotes(maliciousValidatorId);

        // Store the vote
        $.slashingVotes[maliciousValidatorId][voterValidatorId] = voteExpiration;

        // Increment vote count (cleanup already ensured accurate count)
        $.slashVoteCounts[maliciousValidatorId]++;

        emit SlashVoteCast(maliciousValidatorId, voterValidatorId, voteExpiration);

        // --- AUTO-SLASH TRIGGER ---
        // After casting the vote, check if the unanimity threshold has been met.
        uint256 activeVoteCount = $.slashVoteCounts[maliciousValidatorId];
        uint256 totalEligibleValidators = _countEligibleValidators(maliciousValidatorId);

        if (activeVoteCount >= totalEligibleValidators && totalEligibleValidators > 0) {
            _performSlash(maliciousValidatorId, msg.sender);
        }
    }

    /**
     * @notice Slash a malicious validator if enough valid votes have been cast.
     * @dev Callable by anyone with ADMIN_ROLE.
     * @param validatorId ID of the validator to potentially slash
     */
    function slashValidator(
        uint16 validatorId
    ) external nonReentrant onlyRole(PlumeRoles.TIMELOCK_ROLE) {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();

        if (!$.validatorExists[validatorId]) {
            revert ValidatorDoesNotExist(validatorId);
        }

        PlumeStakingStorage.ValidatorInfo storage validatorToSlash = $.validators[validatorId];

        if (validatorToSlash.slashed) {
            revert ValidatorAlreadySlashed(validatorId);
        }

        // Clean up expired votes first to get accurate count
        uint256 activeVoteCount = _cleanupExpiredVotes(validatorId);
        uint256 totalEligibleValidators = _countEligibleValidators(validatorId);

        // ALL eligible validators must vote for slashing (unanimous consensus)
        if (activeVoteCount < totalEligibleValidators) {
            revert UnanimityNotReached(activeVoteCount, totalEligibleValidators);
        }

        _performSlash(validatorId, msg.sender);
    }

    /**
     * @notice Manually triggers the settlement of accrued commission for a specific validator.
     * @dev This updates the validator's cumulative reward per token indices (for all reward tokens)
     *      and their accrued commission storage. It uses the validator's current commission rate for settlement.
     *      Can be called for any validator (active, inactive, or slashed) to force settlement.
     * @param validatorId The ID of the validator.
     */
    function forceSettleValidatorCommission(
        uint16 validatorId
    ) external {
        PlumeStakingStorage.Layout storage $s = PlumeStakingStorage.layout();

        // Perform validator existence check directly
        if (!$s.validatorExists[validatorId]) {
            revert ValidatorDoesNotExist(validatorId);
        }

        PlumeRewardLogic._settleCommissionForValidatorUpToNow($s, validatorId);
    }

    /**
     * @notice Manually clean up expired votes for a validator
     * @dev Anyone can call this to clean up expired votes and get accurate vote counts
     * @param validatorId The validator to clean up votes for
     * @return validVoteCount The number of valid (non-expired) votes remaining
     */
    function cleanupExpiredVotes(
        uint16 validatorId
    ) external returns (uint256 validVoteCount) {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();

        if (!$.validatorExists[validatorId]) {
            revert ValidatorDoesNotExist(validatorId);
        }

        return _cleanupExpiredVotes(validatorId);
    }

    // --- Private Helper Functions ---

    /**
     * @notice Internal logic to perform the slash action on a validator.
     * @dev Separated to prevent code duplication between auto-slash and manual slash.
     * @param validatorId The ID of the validator to slash.
     * @param slasher The address that triggered the slash action.
     */
    function _performSlash(uint16 validatorId, address slasher) internal {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();
        PlumeStakingStorage.ValidatorInfo storage validatorToSlash = $.validators[validatorId];

        // This check is important to prevent re-entrancy or double-slashing
        if (validatorToSlash.slashed) {
            return;
        }

        // Record amounts being lost for the event BEFORE any state changes
        uint256 stakeLost = $.validatorTotalStaked[validatorId];
        uint256 cooledLost = $.validatorTotalCooling[validatorId];

        // Mark validator as slashed FIRST
        validatorToSlash.active = false;
        validatorToSlash.slashed = true;
        validatorToSlash.slashedAtTimestamp = block.timestamp;

        // Update global accounting - reduce totals by the amounts being lost
        $.totalStaked -= stakeLost;
        $.totalCooling -= cooledLost;

        // IMPORTANT: Zero out validator totals - slashed funds are lost/burned
        $.validatorTotalStaked[validatorId] = 0;
        $.validatorTotalCooling[validatorId] = 0;
        validatorToSlash.delegatedAmount = 0;

        // Clear the stakers array - slashed validator should show 0 stakers
        delete $.validatorStakers[validatorId];

        // Clear voting records for the slashed validator
        $.slashVoteCounts[validatorId] = 0;
        uint16[] memory validatorIds = $.validatorIds;
        for (uint256 i = 0; i < validatorIds.length; i++) {
            delete $.slashingVotes[validatorId][validatorIds[i]];
        }

        emit ValidatorSlashed(validatorId, slasher, stakeLost + cooledLost);
        emit ValidatorStatusUpdated(validatorId, false, true);
    }

    /**
     * @notice Internal helper to count the number of validators eligible to vote on a slash.
     * @dev An eligible validator is active, not slashed, and not the one being voted on.
     * @param validatorToExclude The ID of the validator being voted on (to exclude from the count).
     * @return The number of eligible voting validators.
     */
    function _countEligibleValidators(
        uint16 validatorToExclude
    ) internal view returns (uint256) {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();
        uint256 totalActive = _countActiveValidators();

        // If the validator being voted on is part of the active set, then the number
        // of eligible voters is one less than the total.
        PlumeStakingStorage.ValidatorInfo storage excludedInfo = $.validators[validatorToExclude];
        if (excludedInfo.active && !excludedInfo.slashed) {
            // Ensure we don't underflow if totalActive is somehow 0, though this is unlikely.
            if (totalActive > 0) {
                return totalActive - 1;
            }
        }

        // If the excluded validator was not active anyway, then the total number of active
        // validators is the correct count of eligible voters.
        return totalActive;
    }

    /**
     * @notice Internal helper to count the total number of active, non-slashed validators.
     * @dev The single source of truth for counting active validators.
     * @return The total number of active and non-slashed validators.
     */
    function _countActiveValidators() internal view returns (uint256) {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();
        uint16[] memory ids = $.validatorIds;
        uint256 count = 0;
        for (uint256 i = 0; i < ids.length; i++) {
            PlumeStakingStorage.ValidatorInfo storage info = $.validators[ids[i]];
            if (info.active && !info.slashed) {
                count++;
            }
        }
        return count;
    }

    // --- View Functions ---

    /**
     * @notice Get information about a validator including total staked amount and staker count
     */
    function getValidatorInfo(
        uint16 validatorId
    )
        external
        view
        returns (PlumeStakingStorage.ValidatorInfo memory info, uint256 totalStaked, uint256 stakersCount)
    {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();
        if (!$.validatorExists[validatorId]) {
            revert ValidatorDoesNotExist(validatorId);
        }
        info = $.validators[validatorId];
        totalStaked = $.validatorTotalStaked[validatorId];
        stakersCount = $.validatorStakers[validatorId].length;

        // Ensure the returned struct has the correct delegated amount.
        info.delegatedAmount = totalStaked;

        return (info, totalStaked, stakersCount);
    }

    /**
     * @notice Get essential statistics about a validator
     */
    function getValidatorStats(
        uint16 validatorId
    ) external view returns (bool active, uint256 commission, uint256 totalStaked, uint256 stakersCount) {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();
        if (!$.validatorExists[validatorId]) {
            revert ValidatorDoesNotExist(validatorId);
        }
        PlumeStakingStorage.ValidatorInfo storage validator = $.validators[validatorId];
        active = validator.active;
        commission = validator.commission;
        totalStaked = $.validatorTotalStaked[validatorId];
        stakersCount = $.validatorStakers[validatorId].length;
        return (active, commission, totalStaked, stakersCount);
    }

    /**
     * @notice Get the list of validators a user has staked with
     */
    function getUserValidators(
        address user
    ) external view returns (uint16[] memory) {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();
        uint16[] storage userAssociatedValidators = $.userValidators[user];
        uint256 associatedCount = userAssociatedValidators.length;

        if (associatedCount == 0) {
            return new uint16[](0);
        }

        uint16[] memory tempNonSlashedValidators = new uint16[](associatedCount); // Max possible size
        uint256 actualCount = 0;

        for (uint256 i = 0; i < associatedCount; i++) {
            uint16 valId = userAssociatedValidators[i];
            if ($.validatorExists[valId] && !$.validators[valId].slashed) {
                // Also check .validatorExists for safety
                tempNonSlashedValidators[actualCount] = valId;
                actualCount++;
            }
        }

        uint16[] memory finalNonSlashedValidators = new uint16[](actualCount);
        for (uint256 i = 0; i < actualCount; i++) {
            finalNonSlashedValidators[i] = tempNonSlashedValidators[i];
        }

        return finalNonSlashedValidators;
    }

    /**
     * @notice Get the amount of commission accrued for a specific token by a validator but not yet claimed.
     * @return The total accrued commission for the specified token.
     */
    function getAccruedCommission(uint16 validatorId, address token) public view returns (uint256) {
        PlumeStakingStorage.Layout storage $s = PlumeStakingStorage.layout();
        if (!$s.validatorExists[validatorId]) {
            revert ValidatorDoesNotExist(validatorId);
        }
        if (!$s.isRewardToken[token]) {
            revert TokenDoesNotExist(token);
        }

        return $s.validatorAccruedCommission[validatorId][token];
    }

    /**
     * @notice Returns a list of all validators with their basic data.
     * @return list An array of ValidatorListData structs.
     */
    function getValidatorsList() external view virtual returns (ValidatorFacet.ValidatorListData[] memory list) {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();
        uint16[] memory ids = $.validatorIds;
        uint256 numValidators = ids.length;
        list = new ValidatorFacet.ValidatorListData[](numValidators);

        for (uint256 i = 0; i < numValidators; i++) {
            uint16 id = ids[i];
            PlumeStakingStorage.ValidatorInfo storage info = $.validators[id];
            list[i] = ValidatorFacet.ValidatorListData({
                id: id,
                totalStaked: $.validatorTotalStaked[id],
                commission: info.commission
            });
        }
    }

    /**
     * @notice Returns the number of currently active validators.
     * @dev An active validator is one that is marked as active and has not been slashed.
     */
    function getActiveValidatorCount() external view returns (uint256 count) {
        return _countActiveValidators();
    }

    /**
     * @notice Get the number of valid (non-expired) votes for a validator
     * @param validatorId The ID of the validator
     * @return validVoteCount The number of valid (non-expired) votes
     */
    function getSlashVoteCount(
        uint16 validatorId
    ) external view returns (uint256) {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();

        if (!$.validatorExists[validatorId]) {
            revert ValidatorDoesNotExist(validatorId);
        }

        // Count only valid (non-expired) votes from eligible validators
        uint256 validVoteCount = 0;
        uint256 currentTime = block.timestamp;

        for (uint256 i = 0; i < $.validatorIds.length; i++) {
            uint16 voterValidatorId = $.validatorIds[i];

            if (voterValidatorId == validatorId) {
                continue;
            }

            uint256 voteExpiration = $.slashingVotes[validatorId][voterValidatorId];
            if (voteExpiration > 0) {
                // Check if the voting validator is eligible (active and not slashed)
                PlumeStakingStorage.ValidatorInfo storage voterValidator = $.validators[voterValidatorId];
                bool voterIsEligible = voterValidator.active && !voterValidator.slashed;
                
                // Check if vote has not expired (align with _cleanupExpiredVotes logic)
                bool voteHasNotExpired = currentTime < voteExpiration;

                if (voterIsEligible && voteHasNotExpired) {
                    validVoteCount++;
                }
            }
        }

        return validVoteCount;
    }

    /**
     * @notice Returns the list of commission checkpoints for a validator.
     * @dev Primarily for testing and off-chain tooling.
     * @param validatorId The ID of the validator.
     * @return An array of RateCheckpoint structs.
     */
    function getValidatorCommissionCheckpoints(
        uint16 validatorId
    ) external view returns (PlumeStakingStorage.RateCheckpoint[] memory) {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();
        if (!$.validatorExists[validatorId]) {
            revert ValidatorDoesNotExist(validatorId);
        }
        return $.validatorCommissionCheckpoints[validatorId];
    }

}

// @audit
=== StakingFacet.sol ===
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.25;

import {
    ActionOnSlashedValidatorError,
    CooldownNotComplete,
    CooldownPeriodNotEnded,
    ExceedsValidatorCapacity,
    InsufficientCooldownBalance,
    InsufficientCooledAndParkedBalance,
    InsufficientFunds,
    InternalInconsistency,
    InvalidAmount,
    NativeTransferFailed,
    NoActiveStake,
    NoRewardsToRestake,
    NoWithdrawableBalanceToRestake,
    NotActive,
    StakeAmountTooSmall,
    TokenDoesNotExist,
    TooManyStakers,
    TransferError,
    ValidatorCapacityExceeded,
    ValidatorDoesNotExist,
    ValidatorInactive,
    ValidatorPercentageExceeded,
    ZeroAddress,
    ZeroRecipientAddress,
    TreasuryNotSet
} from "../lib/PlumeErrors.sol";

import {
    CooldownStarted,
    RewardClaimedFromValidator,
    RewardsRestaked,
    Staked,
    StakedOnBehalf,
    Unstaked,
    Withdrawn
} from "../lib/PlumeEvents.sol";

import { PlumeRewardLogic } from "../lib/PlumeRewardLogic.sol";
import { PlumeStakingStorage } from "../lib/PlumeStakingStorage.sol";
import { PlumeValidatorLogic } from "../lib/PlumeValidatorLogic.sol";

import { ReentrancyGuardUpgradeable } from "@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { SafeERC20 } from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import { Address } from "@openzeppelin/contracts/utils/Address.sol";
import { IPlumeStakingRewardTreasury } from "../interfaces/IPlumeStakingRewardTreasury.sol";

using PlumeRewardLogic for PlumeStakingStorage.Layout;

interface IRewardsGetter {

    function getPendingRewardForValidator(
        address user,
        uint16 validatorId,
        address token
    ) external returns (uint256 pendingReward);

    function getTreasury() external view returns (address);
}

/**
 * @title StakingFacet
 * @author Eugene Y. Q. Shen, Alp Guneysel
 * @notice Facet containing core user staking, unstaking, and withdrawal functions.
 */
contract StakingFacet is ReentrancyGuardUpgradeable {

    using SafeERC20 for IERC20;
    using Address for address payable;

    function _checkValidatorSlashedAndRevert(
        uint16 validatorId
    ) internal view {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();
        if ($.validatorExists[validatorId] && $.validators[validatorId].slashed) {
            revert ActionOnSlashedValidatorError(validatorId);
        }
    }

    /**
     * @dev Validates that a validator exists and is active (not slashed)
     * @param validatorId The validator ID to validate
     */
    function _validateValidatorForStaking(
        uint16 validatorId
    ) internal view {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();
        if (!$.validatorExists[validatorId]) {
            revert ValidatorDoesNotExist(validatorId);
        }
        _checkValidatorSlashedAndRevert(validatorId);
        if (!$.validators[validatorId].active) {
            revert ValidatorInactive(validatorId);
        }
    }

    /**
     * @dev Validates that a stake amount meets minimum requirements
     * @param amount The amount to validate
     */
    function _validateStakeAmount(
        uint256 amount
    ) internal view {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();
        if (amount == 0) {
            revert InvalidAmount(0);
        }
        if (amount < $.minStakeAmount) {
            revert StakeAmountTooSmall(amount, $.minStakeAmount);
        }
    }

    /**
     * @dev Combined validation for staking operations
     * @param validatorId The validator ID to validate
     * @param amount The amount to validate
     */
    function _validateStaking(uint16 validatorId, uint256 amount) internal view {
        _validateValidatorForStaking(validatorId);
        _validateStakeAmount(amount);
    }

    /**
     * @dev Validates that validator capacity limits are not exceeded
     * @param validatorId The validator ID to check
     * @param stakeAmount The amount being staked (for error reporting)
     */
    function _validateValidatorCapacity(uint16 validatorId, uint256 stakeAmount) internal view {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();

        // Check if exceeding validator capacity
        uint256 newDelegatedAmount = $.validators[validatorId].delegatedAmount;
        uint256 maxCapacity = $.validators[validatorId].maxCapacity;
        if (maxCapacity > 0 && newDelegatedAmount > maxCapacity) {
            revert ExceedsValidatorCapacity(validatorId, newDelegatedAmount, maxCapacity, stakeAmount);
        }
    }

    /**
     * @dev Validates that validator percentage limits are not exceeded
     * @param validatorId The validator ID to check
     */
    function _validateValidatorPercentage(
        uint16 validatorId, uint256 stakeAmount
    ) internal view {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();

        uint256 previousTotalStaked = $.totalStaked - stakeAmount;

        // Check if exceeding validator percentage limit
        if (previousTotalStaked > 0 && $.maxValidatorPercentage > 0) {
            uint256 newDelegatedAmount = $.validators[validatorId].delegatedAmount;
            uint256 validatorPercentage = (newDelegatedAmount * 10_000) / $.totalStaked;
            if (validatorPercentage > $.maxValidatorPercentage) {
                revert ValidatorPercentageExceeded();
            }
        }
    }

    /**
     * @dev Performs both capacity and percentage validation checks
     * @param validatorId The validator ID to check
     * @param stakeAmount The amount being staked (for error reporting)
     */
    function _validateCapacityLimits(uint16 validatorId, uint256 stakeAmount) internal view {
        _validateValidatorCapacity(validatorId, stakeAmount);
        _validateValidatorPercentage(validatorId, stakeAmount);
    }

    /**
     * @dev Validates that a validator exists and is not slashed (for unstaking operations)
     * @param validatorId The validator ID to validate
     */
    function _validateValidatorForUnstaking(
        uint16 validatorId
    ) internal view {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();
        if (!$.validatorExists[validatorId]) {
            revert ValidatorDoesNotExist(validatorId);
        }
        _checkValidatorSlashedAndRevert(validatorId);
    }

    /**
     * @dev Performs all common staking setup and validation for new stakes
     * @param user The user performing the stake
     * @param validatorId The validator to stake to
     * @param stakeAmount The amount being staked
     * @return isNewStake Whether this is a new stake for this user-validator pair
     */
    function _performStakeSetup(
        address user,
        uint16 validatorId,
        uint256 stakeAmount
    ) internal returns (bool isNewStake) {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();

        // Use consolidated validation
        _validateStaking(validatorId, stakeAmount);

        // Check if this is a new stake for this specific validator
        isNewStake = $.userValidatorStakes[user][validatorId].staked == 0;

        if (!isNewStake) {
            // If user is adding to an existing stake with this validator, settle their current rewards first
            PlumeRewardLogic.updateRewardsForValidator($, user, validatorId);
        } else {
            // Initialize reward state for new stakes BEFORE updating stake amounts
            // This ensures that commission calculations use the old totalStaked amount (before this user's stake)
            _initializeRewardStateForNewStake(user, validatorId);
        }

        // Update stake amount AFTER reward state initialization
        _updateStakeAmounts(user, validatorId, stakeAmount);

        // Validate capacity limits
        _validateCapacityLimits(validatorId, stakeAmount);

        // Add user to validator's staker list
        PlumeValidatorLogic.addStakerToValidator($, user, validatorId);
    }

    /**
     * @dev Performs common restaking workflow from cooled/parked funds
     * @param user The user performing the restake
     * @param validatorId The validator to restake to
     * @param amount The amount to restake
     * @param fromSource Description of fund source for events
     */
    function _performRestakeWorkflow(
        address user,
        uint16 validatorId,
        uint256 amount,
        string memory fromSource
    ) internal {
        // Use consolidated validation
        _validateStaking(validatorId, amount);

        // Update rewards before any balance changes
        PlumeRewardLogic.updateRewardsForValidator(PlumeStakingStorage.layout(), user, validatorId);

        // Update stake amounts
        _updateStakeAmounts(user, validatorId, amount);

        // Ensure staker is properly listed for the validator
        PlumeValidatorLogic.addStakerToValidator(PlumeStakingStorage.layout(), user, validatorId);
    }

    /**
     * @notice Stake PLUME to a specific validator using only wallet funds
     * @param validatorId ID of the validator to stake to
     */
    function stake(
        uint16 validatorId
    ) external payable returns (uint256) {
        uint256 stakeAmount = msg.value;

        // Perform all common staking setup
        bool isNewStake = _performStakeSetup(msg.sender, validatorId, stakeAmount);

        // Emit stake event
        emit Staked(msg.sender, validatorId, stakeAmount, 0, 0, stakeAmount);

        return stakeAmount;
    }

    /**
     * @notice Restake PLUME that is currently in cooldown or parked for a specific validator.
     * Prioritizes cooldown funds first, then parked funds. Performs full validation including
     * capacity limits and reward state initialization for new stakes.
     * @param validatorId ID of the validator to restake to.
     * @param amount Amount of PLUME to restake.
     */
    function restake(uint16 validatorId, uint256 amount) external nonReentrant {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();
        address user = msg.sender;

        if (amount == 0) {
            revert InvalidAmount(0);
        }

        // --- SAFE VALIDATION (Check-Then-Act) ---
        // 1. Atomically process matured cooldowns to update parked balance. This provides a clean state.
        _processMaturedCooldowns(user);

        // 2. Now calculate total available funds from this clean state.
        // Available funds = currently parked + any UNMATURED cooldown from the target validator.
        uint256 parkedAmount = $.stakeInfo[user].parked;
        uint256 unmaturedCooldownFromTarget = $.userValidatorCooldowns[user][validatorId].amount;
        uint256 totalAvailable = parkedAmount + unmaturedCooldownFromTarget;

        if (totalAvailable < amount) {
            revert InsufficientCooledAndParkedBalance(totalAvailable, amount);
        }

        // --- EXECUTION (Act) ---
        // 3. SETUP & EXECUTE RESTAKE
        _performStakeSetup(user, validatorId, amount);

        uint256 fromCooled = 0;
        uint256 fromParked = 0;
        uint256 remaining = amount;

        // Priority 1: Use from unmatured cooldown of the target validator.
        if (remaining > 0 && unmaturedCooldownFromTarget > 0) {
            uint256 useAmount = remaining > unmaturedCooldownFromTarget ? unmaturedCooldownFromTarget : remaining;
            fromCooled = useAmount;
            remaining -= useAmount;
            _removeCoolingAmounts(user, validatorId, useAmount);
        }

        // Priority 2: Use from parked amount if needed
        if (remaining > 0) {
            uint256 currentParked = $.stakeInfo[user].parked;
            if (remaining > currentParked) {
                // This should not be reachable if the initial validation was correct.
                revert InternalInconsistency("Insufficient parked funds for restake allocation");
            }
            fromParked = remaining;
            _removeParkedAmounts(user, fromParked);
        }

        emit Staked(user, validatorId, amount, fromCooled, fromParked, 0);
    }

    /**
     * @notice Unstake PLUME from a specific validator (full amount)
     * @param validatorId ID of the validator to unstake from
     * @return amount Amount of PLUME unstaked
     */
    function unstake(
        uint16 validatorId
    ) external returns (uint256 amount) {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();
        PlumeStakingStorage.UserValidatorStake storage userStake = $.userValidatorStakes[msg.sender][validatorId];

        if (userStake.staked > 0) {
            return _unstake(validatorId, userStake.staked);
        }
        revert NoActiveStake();
    }

    /**
     * @notice Unstake a specific amount of PLUME from a specific validator
     * @param validatorId ID of the validator to unstake from
     * @param amount Amount of PLUME to unstake
     * @return amountUnstaked The amount actually unstaked
     */
    function unstake(uint16 validatorId, uint256 amount) external returns (uint256 amountUnstaked) {
        if (amount == 0) {
            revert InvalidAmount(0);
        }
        return _unstake(validatorId, amount);
    }

    /**
     * @notice Internal logic for unstaking, handles moving stake to cooling or parked.
     * @param validatorId ID of the validator to unstake from.
     * @param amount The amount of PLUME to unstake. If 0, unstakes all.
     * @return amountToUnstake The actual amount that was unstaked.
     */
    function _unstake(uint16 validatorId, uint256 amount) internal returns (uint256 amountToUnstake) {
        PlumeStakingStorage.Layout storage $s = PlumeStakingStorage.layout();

        // Validate unstaking conditions
        _validateValidatorForUnstaking(validatorId);
        if (amount == 0) {
            revert InvalidAmount(amount);
        }
        if ($s.userValidatorStakes[msg.sender][validatorId].staked < amount) {
            revert InsufficientFunds($s.userValidatorStakes[msg.sender][validatorId].staked, amount);
        }

        // Update rewards before balance changes
        PlumeRewardLogic.updateRewardsForValidator($s, msg.sender, validatorId);

        // Update stake amounts
        _updateUnstakeAmounts(msg.sender, validatorId, amount);

        // Process cooldown logic and cleanup
        uint256 newCooldownEndTimestamp = _processCooldownLogic(msg.sender, validatorId, amount);
        _handlePostUnstakeCleanup(msg.sender, validatorId);

        emit CooldownStarted(msg.sender, validatorId, amount, newCooldownEndTimestamp);
        return amount;
    }

    /**
     * @notice Withdraw all PLUME that is available in the parked balance (matured cooldowns)
     */
    function withdraw() external {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();
        address user = msg.sender;


        // Process matured cooldowns into parked balance
        _processMaturedCooldowns(user);

        uint256 amountToWithdraw = $.stakeInfo[user].parked;
        if (amountToWithdraw == 0) {
            revert InvalidAmount(0);
        }

        // Remove from parked and transfer
        _removeParkedAmounts(user, amountToWithdraw);

        // Clean up validator relationships for validators where user has no remaining involvement
        _cleanupValidatorRelationships(user);

        emit Withdrawn(user, amountToWithdraw);

        (bool success,) = user.call{ value: amountToWithdraw }("");
        if (!success) {
            revert NativeTransferFailed();
        }
    }

    /**
     * @notice Stake PLUME to a specific validator on behalf of another user
     * @param validatorId ID of the validator to stake to
     * @param staker Address of the staker to stake on behalf of
     * @return Amount of PLUME staked
     */
    function stakeOnBehalf(uint16 validatorId, address staker) external payable returns (uint256) {
        if (staker == address(0)) {
            revert ZeroRecipientAddress();
        }

        uint256 stakeAmount = msg.value;

        // Perform all common staking setup for the beneficiary
        bool isNewStake = _performStakeSetup(staker, validatorId, stakeAmount);

        // Emit events
        emit Staked(staker, validatorId, stakeAmount, 0, 0, stakeAmount);
        emit StakedOnBehalf(msg.sender, staker, validatorId, stakeAmount);

        return stakeAmount;
    }

    /**
     * @notice Restakes the user's entire pending native PLUME rewards to a specific validator.
     * Also processes any matured cooldowns into the user's parked balance.
     * @param validatorId ID of the validator to stake the rewards to.
     * @return amountRestaked The total amount of pending rewards successfully restaked.
     */
    function restakeRewards(
        uint16 validatorId
    ) external nonReentrant returns (uint256 amountRestaked) {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();
        address user = msg.sender;

        // Process matured cooldowns first
        _processMaturedCooldowns(user);

        // Verify target validator and calculate rewards
        _validateValidatorForStaking(validatorId);
        address tokenToRestake = PlumeStakingStorage.PLUME_NATIVE;
        if (!$.isRewardToken[tokenToRestake]) {
            revert TokenDoesNotExist(tokenToRestake);
        }

        // Calculate and claim all pending rewards with proper cleanup
        amountRestaked = _calculateAndClaimAllRewardsWithCleanup(user, tokenToRestake);

        // Validate restake amount
        if (amountRestaked == 0) {
            revert NoRewardsToRestake();
        }
        if (amountRestaked < $.minStakeAmount) {
            revert StakeAmountTooSmall(amountRestaked, $.minStakeAmount);
        }

        
        // Transfer the rewards from the treasury TO DIAMOND PROXY to back the new stake.
        _transferRewardFromTreasury(tokenToRestake, amountRestaked, address(this));
        

        // Use proper stake setup instead of restake workflow - this handles:
        // 1. New stake reward state initialization
        // 2. Existing stake reward settlement
        // 3. Capacity validation
        // 4. Validator relationship management
        bool isNewStake = _performStakeSetup(user, validatorId, amountRestaked);

        // Emit events
        emit Staked(user, validatorId, amountRestaked, 0, 0, amountRestaked);
        emit RewardsRestaked(user, validatorId, amountRestaked);

        return amountRestaked;
    }

    // --- View Functions ---

    /**
     * @notice Returns the amount of PLUME currently staked by the caller
     */
    function amountStaked() external view returns (uint256 amount) {
        return PlumeStakingStorage.layout().stakeInfo[msg.sender].staked;
    }

    /**
     * @notice Returns the amount of PLUME currently in cooling period for the caller.
     * This now dynamically calculates funds in active, non-matured cooldowns.
     */
    function amountCooling() external view returns (uint256 activelyCoolingAmount) {
        return _calculateActivelyCoolingAmount(msg.sender);
    }

    /**
     * @notice Returns the amount of PLUME that is withdrawable for the caller.
     * This includes already parked funds plus any funds in matured cooldowns.
     * For slashed validators, cooled funds are only considered withdrawable if their
     * cooldownEndTime was *before* the validator's slashedAtTimestamp.
     */
    function amountWithdrawable() external view returns (uint256 totalWithdrawableAmount) {
        return _calculateTotalWithdrawableAmount(msg.sender);
    }

    /**
     * @notice Get staking information for a user (global stake info)
     */
    function stakeInfo(
        address user
    ) external view returns (PlumeStakingStorage.StakeInfo memory) {
        return PlumeStakingStorage.layout().stakeInfo[user];
    }

    /**
     * @notice Get the total amount of PLUME staked in the contract.
     * @return amount Total amount of PLUME staked.
     */
    function totalAmountStaked() external view returns (uint256 amount) {
        return PlumeStakingStorage.layout().totalStaked;
    }

    /**
     * @notice Get the total amount of PLUME cooling in the contract.
     * @return amount Total amount of PLUME cooling.
     */
    function totalAmountCooling() external view returns (uint256 amount) {
        return PlumeStakingStorage.layout().totalCooling;
    }

    /**
     * @notice Get the total amount of PLUME withdrawable in the contract.
     * @return amount Total amount of PLUME withdrawable.
     */
    function totalAmountWithdrawable() external view returns (uint256 amount) {
        return PlumeStakingStorage.layout().totalWithdrawable;
    }

    /**
     * @notice Get the total amount of a specific token claimable across all users.
     * @param token Address of the token to check.
     * @return amount Total amount of the token claimable.
     */
    function totalAmountClaimable(
        address token
    ) external view returns (uint256 amount) {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();

        // Check if token is a reward token using the mapping
        require($.isRewardToken[token], "Token is not a reward token");

        // Return the total claimable amount
        return $.totalClaimableByToken[token];
    }

    /**
     * @notice Get the staked amount for a specific user on a specific validator.
     * @param user The address of the user.
     * @param validatorId The ID of the validator.
     * @return The staked amount.
     */
    function getUserValidatorStake(address user, uint16 validatorId) external view returns (uint256) {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();
        return $.userValidatorStakes[user][validatorId].staked;
    }

    struct CooldownView {
        // Define struct for the return type
        uint16 validatorId;
        uint256 amount;
        uint256 cooldownEndTime;
    }

    /**
     * @notice Get all active cooldown entries for a specific user.
     * @param user The address of the user.
     * @return An array of CooldownView structs.
     */
    function getUserCooldowns(
        address user
    ) external view returns (CooldownView[] memory) {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();
        uint16[] storage userAssociatedValidators = $.userValidators[user];

        uint256 activeCooldownCount = _countActiveCooldowns(user);
        CooldownView[] memory cooldowns = new CooldownView[](activeCooldownCount);
        uint256 currentIndex = 0;

        // Populate the array
        for (uint256 i = 0; i < userAssociatedValidators.length; i++) {
            uint16 validatorId_iterator = userAssociatedValidators[i];
            // Remove the check for `!slashed`. Cooldowns from slashed validators should be visible.
            if ($.validatorExists[validatorId_iterator]) {
                PlumeStakingStorage.CooldownEntry storage entry = $.userValidatorCooldowns[user][validatorId_iterator];
                if (entry.amount > 0) {
                    // Prevent array out-of-bounds if _countActiveCooldowns logic differs.
                    if (currentIndex < activeCooldownCount) {
                        cooldowns[currentIndex] = CooldownView({
                            validatorId: validatorId_iterator,
                            amount: entry.amount,
                            cooldownEndTime: entry.cooldownEndTime
                        });
                        currentIndex++;
                    }
                }
            }
        }
        return cooldowns;
    }

    /**
     * @dev Updates all stake-related storage when adding stake to a validator
     * @param user The user address
     * @param validatorId The validator ID
     * @param amount The amount being staked
     */
    function _updateStakeAmounts(address user, uint16 validatorId, uint256 amount) internal {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();

        $.userValidatorStakes[user][validatorId].staked += amount;
        $.stakeInfo[user].staked += amount;
        $.validators[validatorId].delegatedAmount += amount;
        $.validatorTotalStaked[validatorId] += amount;
        $.totalStaked += amount;
    }

    /**
     * @dev Updates all stake-related storage when removing stake from a validator
     * @param user The user address
     * @param validatorId The validator ID
     * @param amount The amount being unstaked
     */
    function _updateUnstakeAmounts(address user, uint16 validatorId, uint256 amount) internal {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();

        $.userValidatorStakes[user][validatorId].staked -= amount;
        $.stakeInfo[user].staked -= amount;
        $.validators[validatorId].delegatedAmount -= amount;
        $.validatorTotalStaked[validatorId] -= amount;
        $.totalStaked -= amount;
    }

    /**
     * @dev Updates cooling-related storage when moving funds to cooling state
     * @param user The user address
     * @param validatorId The validator ID
     * @param amount The amount being moved to cooling
     */
    function _updateCoolingAmounts(address user, uint16 validatorId, uint256 amount) internal {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();

        $.stakeInfo[user].cooled += amount;
        $.totalCooling += amount;
        $.validatorTotalCooling[validatorId] += amount;
    }

    /**
     * @dev Removes cooling amounts from both global and validator-specific state
     * @param user The user address
     * @param validatorId The validator ID to remove cooling amounts from
     * @param amount The amount being removed from cooling
     */
    function _removeCoolingAmounts(address user, uint16 validatorId, uint256 amount) internal {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();

        bool isSlashed = $.validators[validatorId].slashed;

        // Update user's global cooling amounts - this always happens
        if ($.stakeInfo[user].cooled >= amount) {
            $.stakeInfo[user].cooled -= amount;
        } else {
            $.stakeInfo[user].cooled = 0;
        }

        // Only update global and validator totals if the validator was NOT slashed
        // because these totals were already decremented during the slash event.
        if (!isSlashed) {
            // Update global total cooling
            if ($.totalCooling >= amount) {
                $.totalCooling -= amount;
            } else {
                $.totalCooling = 0;
            }
            // Update validator total cooling
            if ($.validatorTotalCooling[validatorId] >= amount) {
                $.validatorTotalCooling[validatorId] -= amount;
            } else {
                $.validatorTotalCooling[validatorId] = 0;
            }
        }

        // Update user's specific cooldown entry for the validator - this always happens
        PlumeStakingStorage.CooldownEntry storage entry = $.userValidatorCooldowns[user][validatorId];
        if (entry.amount >= amount) {
            entry.amount -= amount;
            if (entry.amount == 0) {
                entry.cooldownEndTime = 0;
            }
        } else {
            entry.amount = 0;
            entry.cooldownEndTime = 0;
        }
    }

    /**
     * @dev Updates parked amounts for withdrawal
     * @param user The user address
     * @param amount The amount to move to parked state
     */
    function _updateParkedAmounts(address user, uint256 amount) internal {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();
        $.stakeInfo[user].parked += amount;
        $.totalWithdrawable += amount;
    }

    /**
     * @dev Updates withdrawal amounts after a successful withdrawal
     * @param user The user address
     * @param amount The amount being withdrawn
     */
    function _updateWithdrawalAmounts(address user, uint256 amount) internal {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();
        $.stakeInfo[user].parked = 0;
        if ($.totalWithdrawable >= amount) {
            $.totalWithdrawable -= amount;
        } else {
            $.totalWithdrawable = 0;
        }
    }

    /**
     * @dev Updates reward claim tracking when rewards are claimed
     * @param user The user address
     * @param validatorId The validator ID
     * @param token The reward token address
     * @param amount The reward amount being claimed
     */
    function _updateRewardClaim(address user, uint16 validatorId, address token, uint256 amount) internal {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();

        // Reset stored accumulated reward
        $.userRewards[user][validatorId][token] = 0;

        // Update user's last processed timestamp to current time
        $.userValidatorRewardPerTokenPaidTimestamp[user][validatorId][token] = block.timestamp;
        $.userValidatorRewardPerTokenPaid[user][validatorId][token] =
            $.validatorRewardPerTokenCumulative[validatorId][token];

        // Update total claimable tracking
        if ($.totalClaimableByToken[token] >= amount) {
            $.totalClaimableByToken[token] -= amount;
        } else {
            $.totalClaimableByToken[token] = 0;
        }
    }

    /**
     * @dev Updates commission claim tracking when commission is claimed
     * @param validatorId The validator ID
     * @param token The reward token address
     * @param amount The commission amount being claimed
     * @param recipient The recipient address
     */
    function _updateCommissionClaim(uint16 validatorId, address token, uint256 amount, address recipient) internal {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();

        $.pendingCommissionClaims[validatorId][token] = PlumeStakingStorage.PendingCommissionClaim({
            amount: amount,
            requestTimestamp: block.timestamp,
            token: token,
            recipient: recipient
        });

        // Zero out accrued commission immediately
        $.validatorAccruedCommission[validatorId][token] = 0;
    }

    /**
     * @dev Removes parked (withdrawable) amounts
     * @param user The user address
     * @param amount The amount being removed from parked state
     */
    function _removeParkedAmounts(address user, uint256 amount) internal {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();
        $.stakeInfo[user].parked -= amount;
        $.totalWithdrawable -= amount;
    }

    // ====================================================================================
    // ============================= COMPLEX LOGIC FUNCTIONS ===========================
    // ====================================================================================

    /**
     * @dev Processes cooldown logic for unstaking operations
     * @param user The user address
     * @param validatorId The validator ID
     * @param amount The amount being unstaked
     * @return newCooldownEndTime The timestamp when the new cooldown ends
     */
    function _processCooldownLogic(
        address user,
        uint16 validatorId,
        uint256 amount
    ) internal returns (uint256 newCooldownEndTime) {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();
        PlumeStakingStorage.CooldownEntry storage cooldownEntrySlot = $.userValidatorCooldowns[user][validatorId];

        uint256 currentCooledAmountInSlot = cooldownEntrySlot.amount;
        uint256 currentCooldownEndTimeInSlot = cooldownEntrySlot.cooldownEndTime;

        uint256 finalNewCooledAmountForSlot;
        newCooldownEndTime = block.timestamp + $.cooldownInterval;

        if (currentCooledAmountInSlot > 0 && block.timestamp >= currentCooldownEndTimeInSlot) {
            // Previous cooldown for this slot has matured - move to parked and start new cooldown
            _updateParkedAmounts(user, currentCooledAmountInSlot);
            _removeCoolingAmounts(user, validatorId, currentCooledAmountInSlot);
            _updateCoolingAmounts(user, validatorId, amount);
            finalNewCooledAmountForSlot = amount;
        } else {
            // No matured cooldown - add to existing cooldown
            _updateCoolingAmounts(user, validatorId, amount);
            finalNewCooledAmountForSlot = currentCooledAmountInSlot + amount;
        }

        cooldownEntrySlot.amount = finalNewCooledAmountForSlot;
        cooldownEntrySlot.cooldownEndTime = newCooldownEndTime;

        return newCooldownEndTime;
    }

    /**
     * @dev Processes matured cooldowns and moves them to parked balance
     * @param user The user address
     * @return amountMovedToParked Total amount moved from cooled to parked
     */
    function _processMaturedCooldowns(
        address user
    ) internal returns (uint256 amountMovedToParked) {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();
        amountMovedToParked = 0;

        // Make a copy to avoid iteration issues when removeStakerFromValidator is called
        uint16[] memory userAssociatedValidators = $.userValidators[user];

        for (uint256 i = 0; i < userAssociatedValidators.length; i++) {
            uint16 validatorId = userAssociatedValidators[i];
            PlumeStakingStorage.CooldownEntry memory cooldownEntry = $.userValidatorCooldowns[user][validatorId];

            if (cooldownEntry.amount == 0) {
                continue;
            }


            bool canRecoverFromThisCooldown = _canRecoverFromCooldown(user, validatorId, cooldownEntry);

            if (canRecoverFromThisCooldown) {
                uint256 amountInThisCooldown = cooldownEntry.amount;
                amountMovedToParked += amountInThisCooldown;

                _removeCoolingAmounts(user, validatorId, amountInThisCooldown);
                delete $.userValidatorCooldowns[user][validatorId];

                // Remove staker if they have no remaining stake with this validator
                if ($.userValidatorStakes[user][validatorId].staked == 0) {
                    PlumeValidatorLogic.removeStakerFromValidator($, user, validatorId);
                }
            }
        }

        if (amountMovedToParked > 0) {
            _updateParkedAmounts(user, amountMovedToParked);
        }

        return amountMovedToParked;
    }

    /**
     * @dev Determines if a cooldown can be recovered (considering slashing)
     * @param user The user address
     * @param validatorId The validator ID
     * @param cooldownEntry The cooldown entry to check
     * @return canRecover True if the cooldown can be recovered
     */
    function _canRecoverFromCooldown(
        address user,
        uint16 validatorId,
        PlumeStakingStorage.CooldownEntry memory cooldownEntry
    ) internal view returns (bool canRecover) {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();

        if (!$.validatorExists[validatorId]) {
            return false;
        }

        if ($.validators[validatorId].slashed) {
            // Validator is slashed - check if cooldown ended BEFORE the slash
            uint256 slashTs = $.validators[validatorId].slashedAtTimestamp;
            return (cooldownEntry.cooldownEndTime < slashTs && block.timestamp >= cooldownEntry.cooldownEndTime);
        } else {
            // Validator is not slashed - check if cooldown matured normally
            return (block.timestamp >= cooldownEntry.cooldownEndTime);
        }
    }

    /**
     * @dev Processes reward state initialization for new stakes
     * @param user The user address
     * @param validatorId The validator ID
     */
    function _initializeRewardStateForNewStake(address user, uint16 validatorId) internal {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();

        $.userValidatorStakeStartTime[user][validatorId] = block.timestamp;

        address[] memory rewardTokens = $.rewardTokens;
        for (uint256 i = 0; i < rewardTokens.length; i++) {
            address token = rewardTokens[i];
            if ($.isRewardToken[token]) {
                PlumeRewardLogic.updateRewardPerTokenForValidator($, token, validatorId);

                $.userValidatorRewardPerTokenPaid[user][validatorId][token] =
                    $.validatorRewardPerTokenCumulative[validatorId][token];
                $.userValidatorRewardPerTokenPaidTimestamp[user][validatorId][token] = block.timestamp;
            }
        }
    }

    /**
     * @dev Calculates and claims all pending rewards for a user across all validators with proper cleanup
     * @param user The user address
     * @param targetToken The token to calculate rewards for
     * @return totalRewards Total rewards claimed
     */
    function _calculateAndClaimAllRewardsWithCleanup(
        address user,
        address targetToken
    ) internal returns (uint256 totalRewards) {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();
        totalRewards = 0;

        // Make a copy to avoid iteration issues
        uint16[] memory currentUserValidators = $.userValidators[user];

        // Track validators that might need cleanup after claiming
        uint16[] memory validatorsToCheck = new uint16[](currentUserValidators.length);
        uint256 checkCount = 0;

        for (uint256 i = 0; i < currentUserValidators.length; i++) {
            uint16 userValidatorId = currentUserValidators[i];

            uint256 existingRewards = $.userRewards[user][userValidatorId][targetToken];
            uint256 rewardDelta =
                IRewardsGetter(address(this)).getPendingRewardForValidator(user, userValidatorId, targetToken);
            uint256 totalValidatorReward = existingRewards + rewardDelta;

            if (totalValidatorReward > 0) {
                totalRewards += totalValidatorReward;
                PlumeRewardLogic.updateRewardsForValidator($, user, userValidatorId);
                $.userRewards[user][userValidatorId][targetToken] = 0;

                if ($.totalClaimableByToken[targetToken] >= totalValidatorReward) {
                    $.totalClaimableByToken[targetToken] -= totalValidatorReward;
                } else {
                    $.totalClaimableByToken[targetToken] = 0;
                }

                emit RewardClaimedFromValidator(user, targetToken, userValidatorId, totalValidatorReward);

                // Clear pending rewards flag for this validator and track for cleanup
                PlumeRewardLogic.clearPendingRewardsFlagIfEmpty($, user, userValidatorId);

                // Track this validator for potential relationship cleanup
                validatorsToCheck[checkCount] = userValidatorId;
                checkCount++;
            }
        }

        // Clean up validator relationships for validators where user has no remaining involvement
        for (uint256 i = 0; i < checkCount; i++) {
            PlumeValidatorLogic.removeStakerFromValidator($, user, validatorsToCheck[i]);
        }

        return totalRewards;
    }

    /**
     * @dev Handles post-unstake validator relationship cleanup
     * @param user The user address
     * @param validatorId The validator ID
     */
    function _handlePostUnstakeCleanup(address user, uint16 validatorId) internal {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();

        if ($.userValidatorStakes[user][validatorId].staked == 0) {
            PlumeValidatorLogic.removeStakerFromValidator($, user, validatorId);
        }
    }

    /**
     * @dev Counts active cooldowns for a user (used by view functions)
     * @param user The user address
     * @return count Number of active cooldowns
     */
    function _countActiveCooldowns(
        address user
    ) internal view returns (uint256 count) {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();
        uint16[] storage userAssociatedValidators = $.userValidators[user];
        count = 0;

        for (uint256 i = 0; i < userAssociatedValidators.length; i++) {
            uint16 validatorId = userAssociatedValidators[i];
            // Remove the check for `!slashed`. View functions should report the state as-is.
            if ($.validatorExists[validatorId] && $.userValidatorCooldowns[user][validatorId].amount > 0) {
                count++;
            }
        }

        return count;
    }

    /**
     * @dev Calculates actively cooling amount for a user
     * @param user The user address
     * @return activelyCoolingAmount Total amount in active cooldowns
     */
    function _calculateActivelyCoolingAmount(
        address user
    ) internal view returns (uint256 activelyCoolingAmount) {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();
        uint16[] storage userAssociatedValidators = $.userValidators[user];
        activelyCoolingAmount = 0;

        for (uint256 i = 0; i < userAssociatedValidators.length; i++) {
            uint16 validatorId = userAssociatedValidators[i];
            // Remove the check for `!slashed`. View functions should report the state as-is.
            if ($.validatorExists[validatorId]) {
                PlumeStakingStorage.CooldownEntry storage cooldownEntry = $.userValidatorCooldowns[user][validatorId];
                if (cooldownEntry.amount > 0 && block.timestamp < cooldownEntry.cooldownEndTime) {
                    activelyCoolingAmount += cooldownEntry.amount;
                }
            }
        }

        return activelyCoolingAmount;
    }

    /**
     * @dev Calculates total withdrawable amount for a user (including matured cooldowns)
     * @param user The user address
     * @return totalWithdrawableAmount Total amount available for withdrawal
     */
    function _calculateTotalWithdrawableAmount(
        address user
    ) internal view returns (uint256 totalWithdrawableAmount) {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();
        uint16[] storage userAssociatedValidators = $.userValidators[user];

        totalWithdrawableAmount = $.stakeInfo[user].parked;

        for (uint256 i = 0; i < userAssociatedValidators.length; i++) {
            uint16 validatorId = userAssociatedValidators[i];
            PlumeStakingStorage.CooldownEntry storage cooldownEntry = $.userValidatorCooldowns[user][validatorId];

            if (cooldownEntry.amount > 0 && block.timestamp >= cooldownEntry.cooldownEndTime) {
                if ($.validatorExists[validatorId] && $.validators[validatorId].slashed) {
                    // Only withdrawable if cooldown ended before slash
                    if (cooldownEntry.cooldownEndTime < $.validators[validatorId].slashedAtTimestamp) {
                        totalWithdrawableAmount += cooldownEntry.amount;
                    }
                } else if ($.validatorExists[validatorId] && !$.validators[validatorId].slashed) {
                    totalWithdrawableAmount += cooldownEntry.amount;
                }
            }
        }

        return totalWithdrawableAmount;
    }

    /**
     * @dev Cleans up validator relationships for validators where user has no remaining involvement
     * @param user The user address
     */
    function _cleanupValidatorRelationships(
        address user
    ) internal {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();
        PlumeValidatorLogic.removeStakerFromAllValidators($, user);
    }

    /**
     * @dev Calculates and claims all pending rewards for a user across all validators
     * @param user The user address
     * @param targetToken The token to calculate rewards for
     * @return totalRewards Total rewards claimed
     */
    function _calculateAndClaimAllRewards(address user, address targetToken) internal returns (uint256 totalRewards) {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();
        totalRewards = 0;

        // Make a copy to avoid iteration issues
        uint16[] memory currentUserValidators = $.userValidators[user];

        for (uint256 i = 0; i < currentUserValidators.length; i++) {
            uint16 userValidatorId = currentUserValidators[i];

            uint256 existingRewards = $.userRewards[user][userValidatorId][targetToken];
            uint256 rewardDelta =
                IRewardsGetter(address(this)).getPendingRewardForValidator(user, userValidatorId, targetToken);
            uint256 totalValidatorReward = existingRewards + rewardDelta;

            if (totalValidatorReward > 0) {
                totalRewards += totalValidatorReward;
                PlumeRewardLogic.updateRewardsForValidator($, user, userValidatorId);
                $.userRewards[user][userValidatorId][targetToken] = 0;

                if ($.totalClaimableByToken[targetToken] >= totalValidatorReward) {
                    $.totalClaimableByToken[targetToken] -= totalValidatorReward;
                } else {
                    $.totalClaimableByToken[targetToken] = 0;
                }

                emit RewardClaimedFromValidator(user, targetToken, userValidatorId, totalValidatorReward);
            }
        }

        return totalRewards;
    }

    function _transferRewardFromTreasury(address token, uint256 amount, address recipient) internal {
        address treasury = IRewardsGetter(address(this)).getTreasury();
        if (treasury == address(0)) {
            revert TreasuryNotSet();
        }

        // Make the treasury send the rewards directly to the recipient
        IPlumeStakingRewardTreasury(treasury).distributeReward(token, amount, recipient);
    }

}

// @audit

=== RewardsFacet.sol ===
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.25;

import {
    ArrayLengthMismatch,
    CannotReAddTokenInSameBlock,
    EmptyArray,
    InsufficientBalance,
    InternalInconsistency,
    InvalidAmount,
    InvalidRewardRateCheckpoint,
    NativeTransferFailed,
    NotActive,
    RewardRateExceedsMax,
    TokenAlreadyExists,
    TokenDoesNotExist,
    TreasuryNotSet,
    Unauthorized,
    ValidatorDoesNotExist,
    ValidatorInactive,
    ZeroAddress
} from "../lib/PlumeErrors.sol";

import {
    MaxRewardRateUpdated,
    RewardClaimed,
    RewardClaimedFromValidator,
    RewardRateCheckpointCreated,
    RewardRatesSet,
    RewardTokenAdded,
    RewardTokenRemoved,
    Staked,
    TreasurySet
} from "../lib/PlumeEvents.sol";

import { IPlumeStakingRewardTreasury } from "../interfaces/IPlumeStakingRewardTreasury.sol";
import { PlumeRewardLogic } from "../lib/PlumeRewardLogic.sol";
import { PlumeStakingStorage } from "../lib/PlumeStakingStorage.sol";
import { PlumeValidatorLogic } from "../lib/PlumeValidatorLogic.sol";

import { OwnableStorage } from "@solidstate/access/ownable/OwnableStorage.sol";
import { DiamondBaseStorage } from "@solidstate/proxy/diamond/base/DiamondBaseStorage.sol";

import { ReentrancyGuardUpgradeable } from "@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { SafeERC20 } from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import { Address } from "@openzeppelin/contracts/utils/Address.sol";

import { IAccessControl } from "../interfaces/IAccessControl.sol";
import { PlumeRoles } from "../lib/PlumeRoles.sol";
import { OwnableInternal } from "@solidstate/access/ownable/OwnableInternal.sol";

using PlumeRewardLogic for PlumeStakingStorage.Layout;

/**
 * @title RewardsFacet
 * @author Eugene Y. Q. Shen, Alp Guneysel
 * @notice Facet handling reward token management, rate setting, reward calculation, and claiming.
 */
contract RewardsFacet is ReentrancyGuardUpgradeable, OwnableInternal {

    using SafeERC20 for IERC20;
    using Address for address payable;

    // --- Constants ---
    uint256 internal constant BASE = 1e18;
    uint256 internal constant MAX_REWARD_RATE = 3171 * 1e9;

    // --- Storage Access ---
    bytes32 internal constant TREASURY_STORAGE_POSITION = keccak256("plume.storage.RewardTreasury");

    function getTreasuryAddress() internal view returns (address) {
        bytes32 position = TREASURY_STORAGE_POSITION;
        address treasuryAddress;
        assembly {
            treasuryAddress := sload(position)
        }
        return treasuryAddress;
    }

    function setTreasuryAddress(
        address _treasury
    ) internal {
        bytes32 position = TREASURY_STORAGE_POSITION;
        assembly {
            sstore(position, _treasury)
        }
    }

    modifier onlyRole(
        bytes32 _role
    ) {
        if (!IAccessControl(address(this)).hasRole(_role, msg.sender)) {
            revert Unauthorized(msg.sender, _role);
        }
        _;
    }

    // --- Internal View Function (_earned) ---
    function _earned(address user, address token, uint16 validatorId) internal returns (uint256 rewards) {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();
        uint256 userStakedAmount = $.userValidatorStakes[user][validatorId].staked;
        if (userStakedAmount == 0) {
            return $.userRewards[user][validatorId][token];
        }

        (uint256 userRewardDelta,,) =
            PlumeRewardLogic.calculateRewardsWithCheckpoints($, user, validatorId, token, userStakedAmount);
        rewards = $.userRewards[user][validatorId][token] + userRewardDelta;

        return rewards;
    }

    /**
     * @dev Calculates total earned rewards for a user across all validators for a specific token
     * @param user The user to calculate rewards for
     * @param token The reward token
     * @return totalEarned The total earned amount across all validators
     */
    function _calculateTotalEarned(address user, address token) internal returns (uint256 totalEarned) {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();
        uint16[] memory validatorIds = $.userValidators[user];

        // Sum across all validators
        for (uint256 i = 0; i < validatorIds.length; i++) {
            uint16 validatorId = validatorIds[i];

            // _earned correctly handles all validator states (active, inactive, slashed)
            // by calling calculateRewardsWithCheckpoints, which respects the slashedAtTimestamp.
            totalEarned += _earned(user, token, validatorId);
        }

        return totalEarned;
    }

    // --- Admin Functions ---

    /**
     * @notice Sets the treasury address
     * @dev Only callable by ADMIN role
     * @param _treasury Address of the PlumeStakingRewardTreasury contract
     */
    function setTreasury(
        address _treasury
    ) external onlyRole(PlumeRoles.TIMELOCK_ROLE) {
        if (_treasury == address(0)) {
            revert ZeroAddress("treasury");
        }
        setTreasuryAddress(_treasury);
        emit TreasurySet(_treasury);
    }

    function addRewardToken(
        address token,
        uint256 initialRate,
        uint256 maxRate
    ) external onlyRole(PlumeRoles.REWARD_MANAGER_ROLE) {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();
        if (token == address(0)) {
            revert ZeroAddress("token");
        }
        if ($.isRewardToken[token]) {
            revert TokenAlreadyExists();
        }
        if (initialRate > maxRate) {
            revert RewardRateExceedsMax();
        }

        // Prevent re-adding a token in the same block it was removed to avoid checkpoint overwrites.
        if ($.tokenRemovalTimestamps[token] == block.timestamp) {
            revert CannotReAddTokenInSameBlock(token);
        }

        // Add to historical record if it's the first time seeing this token.
        if (!$.isHistoricalRewardToken[token]) {
            $.isHistoricalRewardToken[token] = true;
            $.historicalRewardTokens.push(token);
        }

        uint256 additionTimestamp = block.timestamp;

        // Clear any previous removal timestamp to allow re-adding
        $.tokenRemovalTimestamps[token] = 0;

        $.rewardTokens.push(token);
        $.isRewardToken[token] = true;
        $.maxRewardRates[token] = maxRate;
        $.rewardRates[token] = initialRate; // Set initial global rate
        $.tokenAdditionTimestamps[token] = additionTimestamp;

        // Create a historical record that the rate starts at initialRate for all validators
        uint16[] memory validatorIds = $.validatorIds;
        for (uint256 i = 0; i < validatorIds.length; i++) {
            uint16 validatorId = validatorIds[i];
            PlumeRewardLogic.createRewardRateCheckpoint($, token, validatorId, initialRate);
        }

        emit RewardTokenAdded(token);
        if (maxRate > 0) {
            emit MaxRewardRateUpdated(token, maxRate);
        }
    }

    /**
     * @notice Remove a reward token from the contract.
     *   This also prevents any users from claiming existing rewards for this token.
     * @dev Only callable by REWARD_MANAGER_ROLE
     * @param token Address of the token to remove
     */
    function removeRewardToken(
        address token
    ) external onlyRole(PlumeRoles.REWARD_MANAGER_ROLE) {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();
        if (!$.isRewardToken[token]) {
            revert TokenDoesNotExist(token);
        }

        // Find the index of the token in the array
        uint256 tokenIndex = _getTokenIndex(token);

        // Store removal timestamp to prevent future accrual
        uint256 removalTimestamp = block.timestamp;
        $.tokenRemovalTimestamps[token] = removalTimestamp;

        // Update validators (bounded by number of validators, not users)
        for (uint256 i = 0; i < $.validatorIds.length; i++) {
            uint16 validatorId = $.validatorIds[i];

            // Final update to current time to settle all rewards up to this point
            PlumeRewardLogic.updateRewardPerTokenForValidator($, token, validatorId);

            // Create a final checkpoint with a rate of 0 to stop further accrual definitively.
            PlumeRewardLogic.createRewardRateCheckpoint($, token, validatorId, 0);
        }

        // Set rate to 0 to prevent future accrual. This is now redundant but harmless.
        $.rewardRates[token] = 0;
        // DO NOT delete global checkpoints. Historical data is needed for claims.
        // delete $.rewardRateCheckpoints[token];

        // Update the array
        $.rewardTokens[tokenIndex] = $.rewardTokens[$.rewardTokens.length - 1];
        $.rewardTokens.pop();

        // Update the mapping
        $.isRewardToken[token] = false;

        delete $.maxRewardRates[token];
        emit RewardTokenRemoved(token);
    }

    function setRewardRates(
        address[] calldata tokens,
        uint256[] calldata rewardRates_
    ) external onlyRole(PlumeRoles.REWARD_MANAGER_ROLE) {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();

        if (tokens.length == 0) {
            revert EmptyArray();
        }
        if (tokens.length != rewardRates_.length) {
            revert ArrayLengthMismatch();
        }
        uint16[] memory validatorIds = $.validatorIds;
        for (uint256 i = 0; i < tokens.length; i++) {
            address token_loop = tokens[i];
            uint256 rate_loop = rewardRates_[i];

            if (!$.isRewardToken[token_loop]) {
                revert TokenDoesNotExist(token_loop);
            }
            uint256 maxRate = $.maxRewardRates[token_loop] > 0 ? $.maxRewardRates[token_loop] : MAX_REWARD_RATE;
            if (rate_loop > maxRate) {
                revert RewardRateExceedsMax();
            }

            for (uint256 j = 0; j < validatorIds.length; j++) {
                uint16 validatorId_for_crrc = validatorIds[j];

                PlumeRewardLogic.createRewardRateCheckpoint($, token_loop, validatorId_for_crrc, rate_loop);
            }
            $.rewardRates[token_loop] = rate_loop;
        }
        emit RewardRatesSet(tokens, rewardRates_);
    }

    function setMaxRewardRate(address token, uint256 newMaxRate) external onlyRole(PlumeRoles.REWARD_MANAGER_ROLE) {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();
        if (!$.isRewardToken[token]) {
            revert TokenDoesNotExist(token);
        }

        // If the current global rate exceeds the new max rate, enforce the new max.
        if ($.rewardRates[token] > newMaxRate) {
            $.rewardRates[token] = newMaxRate;

            // Create new checkpoints for all validators to apply the new, capped rate.
            uint16[] memory validatorIds = $.validatorIds;
            for (uint256 i = 0; i < validatorIds.length; i++) {
                PlumeRewardLogic.createRewardRateCheckpoint($, token, validatorIds[i], newMaxRate);
            }
        }

        $.maxRewardRates[token] = newMaxRate;
        emit MaxRewardRateUpdated(token, newMaxRate);
    }

    // --- Claim Functions ---

    function claim(address token, uint16 validatorId) external nonReentrant returns (uint256) {
        // Validate inputs
        _validateTokenForClaim(token, msg.sender);
        _validateValidatorForClaim(validatorId);

        // Process rewards for this specific validator
        uint256 reward = _processValidatorRewards(msg.sender, validatorId, token);

        // Finalize claim if there are rewards
        if (reward > 0) {
            _finalizeRewardClaim(token, reward, msg.sender);
        }

        // Clear pending flags for this validator
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();
        PlumeRewardLogic.clearPendingRewardsFlagIfEmpty($, msg.sender, validatorId);

        // Clean up validator relationship if no remaining involvement
        PlumeValidatorLogic.removeStakerFromValidator($, msg.sender, validatorId);

        return reward;
    }

    function claim(
        address token
    ) external nonReentrant returns (uint256) {
        // Validate token
        _validateTokenForClaim(token, msg.sender);

        // Process rewards from all active validators
        uint256 totalReward = _processAllValidatorRewards(msg.sender, token);

        // Finalize claim if there are rewards
        if (totalReward > 0) {
            _finalizeRewardClaim(token, totalReward, msg.sender);
            emit RewardClaimed(msg.sender, token, totalReward);
        }

        // Clear pending flags for all validators
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();
        uint16[] memory validatorIds = $.userValidators[msg.sender];
        _clearPendingRewardFlags(msg.sender, validatorIds);

        // Clean up validator relationships for validators with no remaining involvement
        PlumeValidatorLogic.removeStakerFromAllValidators($, msg.sender);

        return totalReward;
    }

    function claimAll() external nonReentrant returns (uint256[] memory) {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();
        address[] memory tokens = $.rewardTokens;
        uint256[] memory claims = new uint256[](tokens.length);

        // Process each token
        for (uint256 i = 0; i < tokens.length; i++) {
            address token = tokens[i];

            // Process rewards from all active validators for this token
            uint256 totalReward = _processAllValidatorRewards(msg.sender, token);

            // Finalize claim if there are rewards
            if (totalReward > 0) {
                _finalizeRewardClaim(token, totalReward, msg.sender);
                claims[i] = totalReward;
                emit RewardClaimed(msg.sender, token, totalReward);
            }
        }

        // Clear pending flags for all validators after claiming all tokens
        uint16[] memory validatorIds = $.userValidators[msg.sender];
        _clearPendingRewardFlags(msg.sender, validatorIds);

        // Clean up validator relationships for validators with no remaining involvement
        PlumeValidatorLogic.removeStakerFromAllValidators($, msg.sender);

        return claims;
    }

    // --- Internal Functions ---

    /**
     * @dev Validates that a token can be claimed by checking if it's active or has existing rewards
     * @param token The token to validate
     * @param user The user attempting to claim
     * @return isActive Whether the token is currently active
     */
    function _validateTokenForClaim(address token, address user) internal view returns (bool isActive) {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();

        isActive = $.isRewardToken[token];

        if (!isActive) {
            // If token is not active, check if there are previously earned/stored rewards
            // or pending rewards that can still be calculated
            uint16[] memory validatorIds = $.userValidators[user];
            bool hasRewards = false;

            for (uint256 i = 0; i < validatorIds.length; i++) {
                uint16 validatorId = validatorIds[i];

                // Check stored rewards
                if ($.userRewards[user][validatorId][token] > 0) {
                    hasRewards = true;
                    break;
                }

                // Check pending (calculable) rewards for removed tokens
                uint256 userStakedAmount = $.userValidatorStakes[user][validatorId].staked;
                if (userStakedAmount > 0) {
                    (uint256 userRewardDelta,,) = PlumeRewardLogic.calculateRewardsWithCheckpointsView(
                        $, user, validatorId, token, userStakedAmount
                    );
                    if (userRewardDelta > 0) {
                        hasRewards = true;
                        break;
                    }
                }
            }

            if (!hasRewards) {
                revert TokenDoesNotExist(token);
            }
        }
    }

    /**
     * @dev Validates that a validator can be used for claiming
     * @param validatorId The validator to validate
     */
    function _validateValidatorForClaim(
        uint16 validatorId
    ) internal view {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();

        if (!$.validatorExists[validatorId]) {
            revert ValidatorDoesNotExist(validatorId);
        }
        // Allow claims from slashed validators - users should be able to claim preserved rewards
        // Only reject if validator doesn't exist
    }

    /**
     * @dev Calculates and processes rewards for a single user-validator-token combination
     * @param user The user claiming rewards
     * @param validatorId The validator to claim from
     * @param token The token to claim
     * @return reward The amount of rewards processed
     */
    function _processValidatorRewards(
        address user,
        uint16 validatorId,
        address token
    ) internal returns (uint256 reward) {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();

        // Settle pending rewards for this specific user/validator/token combination.
        // This updates both $.userRewards and $.totalClaimableByToken consistently.
        PlumeRewardLogic.updateRewardsForValidatorAndToken($, user, validatorId, token);

        // Now that rewards are settled, the full claimable amount is in storage.
        reward = $.userRewards[user][validatorId][token];

        if (reward > 0) {
            // This function will now only *reset* the user's reward to 0, since it's being claimed.
            _updateUserRewardState(user, validatorId, token);
            emit RewardClaimedFromValidator(user, token, validatorId, reward);
        }
    }

    /**
     * @dev Updates user reward state after claiming
     * @param user The user who claimed
     * @param validatorId The validator claimed from
     * @param token The token claimed
     */
    function _updateUserRewardState(address user, uint16 validatorId, address token) internal {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();

        // Reset stored accumulated reward to zero since it's being claimed.
        // The "paid" pointers are updated by the settlement logic (updateRewardsForValidatorAndToken).
        $.userRewards[user][validatorId][token] = 0;
    }

    /**
     * @dev Updates global reward tracking and transfers rewards to user
     * @param token The token being claimed
     * @param totalAmount The total amount being claimed
     * @param recipient The recipient of the rewards
     */
    function _finalizeRewardClaim(address token, uint256 totalAmount, address recipient) internal {
        if (totalAmount == 0) {
            return;
        }

        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();

        // Update global tracking
        if ($.totalClaimableByToken[token] >= totalAmount) {
            $.totalClaimableByToken[token] -= totalAmount;
        } else {
            $.totalClaimableByToken[token] = 0;
        }

        // Transfer rewards from treasury
        _transferRewardFromTreasury(token, totalAmount, recipient);
    }

    /**
     * @dev Clears pending reward flags for validators that no longer have rewards
     * @param user The user to check flags for
     * @param validatorIds Array of validator IDs to check
     */
    function _clearPendingRewardFlags(address user, uint16[] memory validatorIds) internal {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();

        for (uint256 i = 0; i < validatorIds.length; i++) {
            PlumeRewardLogic.clearPendingRewardsFlagIfEmpty($, user, validatorIds[i]);
        }
    }

    /**
     * @dev Processes rewards for all active validators for a specific token
     * @param user The user claiming rewards
     * @param token The token to claim
     * @return totalReward The total amount of rewards processed
     */
    function _processAllValidatorRewards(address user, address token) internal returns (uint256 totalReward) {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();

        uint16[] memory validatorIds = $.userValidators[user];

        for (uint256 i = 0; i < validatorIds.length; i++) {
            uint16 validatorId = validatorIds[i];

            // The underlying reward processing logic correctly handles all validator states
            // (active, inactive, slashed) by respecting the relevant timestamps

            uint256 rewardFromValidator = _processValidatorRewards(user, validatorId, token);
            totalReward += rewardFromValidator;
        }

        return totalReward;
    }

    /**
     * @notice Transfer reward from treasury to recipient
     * @dev Internal function to handle reward transfers from treasury
     * @param token Token to transfer
     * @param amount Amount to transfer
     * @param recipient Recipient address
     */
    function _transferRewardFromTreasury(address token, uint256 amount, address recipient) internal {
        address treasury = getTreasuryAddress();
        if (treasury == address(0)) {
            revert TreasuryNotSet();
        }

        // Make the treasury send the rewards directly to the user
        IPlumeStakingRewardTreasury(treasury).distributeReward(token, amount, recipient);
    }

    function _isRewardToken(
        address token
    ) internal view returns (bool) {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();
        return $.isRewardToken[token];
    }

    function _getTokenIndex(
        address token
    ) internal view returns (uint256) {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();

        // First check if the token is a reward token
        if (!$.isRewardToken[token]) {
            revert TokenDoesNotExist(token);
        }

        // Find the index in the array
        address[] memory rewardTokens = $.rewardTokens;
        for (uint256 i = 0; i < rewardTokens.length; i++) {
            if (rewardTokens[i] == token) {
                return i;
            }
        }

        // This should never happen if isRewardToken is properly maintained
        revert InternalInconsistency("Reward token map/array mismatch");
    }

    // --- Public View Functions ---

    // --- View-only helper functions ---
    function _earnedView(address user, address token, uint16 validatorId) internal view returns (uint256 rewards) {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();
        uint256 userStakedAmount = $.userValidatorStakes[user][validatorId].staked;

        if (userStakedAmount == 0) {
            return $.userRewards[user][validatorId][token];
        }

        (uint256 userRewardDelta,,) =
            PlumeRewardLogic.calculateRewardsWithCheckpointsView($, user, validatorId, token, userStakedAmount);

        rewards = $.userRewards[user][validatorId][token] + userRewardDelta;
        return rewards;
    }

    function _calculateTotalEarnedView(address user, address token) internal view returns (uint256 totalEarned) {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();
        uint16[] memory validatorIds = $.userValidators[user];

        for (uint256 i = 0; i < validatorIds.length; i++) {
            uint16 validatorId = validatorIds[i];

            // _earnedView correctly handles all validator states (active, inactive, slashed)
            // by calling calculateRewardsWithCheckpointsView, which respects the slashedAtTimestamp.
            totalEarned += _earnedView(user, token, validatorId);
        }

        return totalEarned;
    }

    function earned(address user, address token) external view returns (uint256) {
        return _calculateTotalEarnedView(user, token);
    }

    function getClaimableReward(address user, address token) external view returns (uint256) {
        return _calculateTotalEarnedView(user, token);
    }

    function getRewardTokens() external view returns (address[] memory) {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();
        return $.rewardTokens;
    }

    /**
     * @notice Checks if a token is an active reward token.
     * @param token The address of the token to check.
     * @return True if the token is currently an active reward token.
     */
    function isRewardToken(address token) external view returns (bool) {
        return PlumeStakingStorage.layout().isRewardToken[token];
    }

    /**
     * @notice Get the maximum reward rate for a specific token.
     * @param token Address of the token to check.
     * @return The maximum reward rate for the token.
     */
    function getMaxRewardRate(
        address token
    ) external view returns (uint256) {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();

        // Check if token exists in current rewardTokens mapping
        if (!$.isRewardToken[token]) {
            revert TokenDoesNotExist(token);
        }

        return $.maxRewardRates[token] > 0 ? $.maxRewardRates[token] : MAX_REWARD_RATE;
    }

    /**
     * @notice Get the current reward rate for a specific token.
     * @param token Address of the token to check.
     * @return The current reward rate for the token.
     */
    function getRewardRate(
        address token
    ) external view returns (uint256) {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();
        return $.rewardRates[token];
    }

    /**
     * @notice Get detailed reward information for a specific token.
     * @param token Address of the token to check.
     * @return rewardRate Current reward rate for the token.
     * @return lastUpdateTime Most recent timestamp when any validator's reward was updated for this token.
     */
    function tokenRewardInfo(
        address token
    ) external view returns (uint256 rewardRate, uint256 lastUpdateTime) {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();
        rewardRate = $.rewardRates[token];

        // Return the most recent validator update time for this token
        uint16[] memory validatorIds = $.validatorIds;
        lastUpdateTime = 0;
        for (uint256 i = 0; i < validatorIds.length; i++) {
            uint256 validatorUpdateTime = $.validatorLastUpdateTimes[validatorIds[i]][token];
            if (validatorUpdateTime > lastUpdateTime) {
                lastUpdateTime = validatorUpdateTime;
            }
        }
    }

    function getRewardRateCheckpointCount(
        address token
    ) external view returns (uint256) {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();
        return $.rewardRateCheckpoints[token].length;
    }

    function getValidatorRewardRateCheckpointCount(uint16 validatorId, address token) external view returns (uint256) {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();
        return $.validatorRewardRateCheckpoints[validatorId][token].length;
    }

    /**
     * @notice Calculates the last reward rate checkpoint index relevant to a user's settled rewards.
     * @dev This function derives the index on-the-fly by searching the checkpoints array.
     *      It is always accurate, even after checkpoints have been pruned.
     * @param user The user address.
     * @param validatorId The validator ID.
     * @param token The reward token address.
     * @return The index of the last relevant checkpoint. Returns 0 if no relevant checkpoint is found.
     */
    function getUserLastCheckpointIndex(
        address user,
        uint16 validatorId,
        address token
    ) external view returns (uint256) {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();

        // The user's last settled state is "as of" this timestamp.
        uint256 lastUpdateTimestamp = $.userValidatorRewardPerTokenPaidTimestamp[user][validatorId][token];

        // If the user has never had a reward interaction, there is no relevant checkpoint.
        if (lastUpdateTimestamp == 0) {
            return 0;
        }

        PlumeStakingStorage.RateCheckpoint[] storage checkpoints = $.validatorRewardRateCheckpoints[validatorId][token];
        uint256 len = checkpoints.length;

        if (len == 0) {
            return 0; // No checkpoints exist for this validator/token.
        }

        // Binary search to find the latest checkpoint with timestamp <= lastUpdateTimestamp
        uint256 low = 0;
        uint256 high = len - 1;
        uint256 resultIndex = 0;
        bool found = false;

        while (low <= high) {
            uint256 mid = low + (high - low) / 2;
            if (checkpoints[mid].timestamp <= lastUpdateTimestamp) {
                // This is a potential candidate. Store it and search for a later one.
                resultIndex = mid;
                found = true;
                low = mid + 1;
            } else {
                // This checkpoint is too recent. Search earlier.
                if (mid == 0) {
                    // All checkpoints are after the user's last update.
                    break;
                }
                high = mid - 1;
            }
        }

        // If a suitable checkpoint was found, return its index. Otherwise, return 0.
        return found ? resultIndex : 0;
    }

    function getRewardRateCheckpoint(
        address token,
        uint256 index
    ) external view returns (uint256 timestamp, uint256 rate, uint256 cumulativeIndex) {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();
        if (index >= $.rewardRateCheckpoints[token].length) {
            revert InvalidRewardRateCheckpoint(token, index);
        }
        PlumeStakingStorage.RateCheckpoint memory checkpoint = $.rewardRateCheckpoints[token][index];
        return (checkpoint.timestamp, checkpoint.rate, checkpoint.cumulativeIndex);
    }

    function getValidatorRewardRateCheckpoint(
        uint16 validatorId,
        address token,
        uint256 index
    ) external view returns (uint256 timestamp, uint256 rate, uint256 cumulativeIndex) {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();
        if (index >= $.validatorRewardRateCheckpoints[validatorId][token].length) {
            revert InvalidRewardRateCheckpoint(token, index);
        }
        PlumeStakingStorage.RateCheckpoint memory checkpoint =
            $.validatorRewardRateCheckpoints[validatorId][token][index];
        return (checkpoint.timestamp, checkpoint.rate, checkpoint.cumulativeIndex);
    }

    /**
     * @notice Get the treasury address.
     * @return The address of the treasury contract.
     */
    function getTreasury() external view returns (address) {
        return getTreasuryAddress();
    }

    /**
     * @notice Calculates the pending reward for a specific user, validator, and token.
     * @dev Calls the internal PlumeRewardLogic.calculateRewardsWithCheckpoints function.
     * @param user The user address.
     * @param validatorId The validator ID.
     * @param token The reward token address.
     * @return pendingReward The calculated reward amount for the user (after commission).
     */
    function getPendingRewardForValidator(
        address user,
        uint16 validatorId,
        address token
    ) external returns (uint256 pendingReward) {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();

        // Required inputs for the internal logic function
        uint256 userStakedAmount = $.userValidatorStakes[user][validatorId].staked;
        // uint256 validatorCommission = $.validators[validatorId].commission; // Not needed for the 5-arg call

        // Call the internal logic function - only need the first return value
        (uint256 userRewardDelta,,) =
            PlumeRewardLogic.calculateRewardsWithCheckpoints($, user, validatorId, token, userStakedAmount);

        return userRewardDelta;
    }
    // --- END NEW PUBLIC WRAPPER ---

}

// @audit

=== ManagementFacet.sol ===
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.25;

import {
    AdminTransferFailed,
    CannotPruneAllCheckpoints,
    CooldownTooShortForSlashVote,
    EmptyArray,
    InsufficientFunds,
    InvalidAmount,
    InvalidIndexRange,
    InvalidInterval,
    InvalidMaxCommissionRate,
    InvalidPercentage,
    MaxCommissionCheckpointsExceeded,
    SlashVoteDurationExceedsCommissionTimelock,
    SlashVoteDurationTooLongForCooldown,
    TokenDoesNotExist,
    TokenAlreadyExists,
    Unauthorized,
    ValidatorDoesNotExist,
    ValidatorNotSlashed,
    ZeroAddress
} from "../lib/PlumeErrors.sol";
import {
    AdminClearedSlashedCooldown,
    AdminClearedSlashedStake,
    AdminStakeCorrection,
    AdminWithdraw,
    CommissionCheckpointsPruned,
    CooldownIntervalSet,
    MaxAllowedValidatorCommissionSet,
    MaxCommissionCheckpointsSet,
    MaxSlashVoteDurationSet,
    MaxValidatorPercentageUpdated,
    MinStakeAmountSet,
    HistoricalRewardTokenAdded,
    HistoricalRewardTokenRemoved,
    RewardRateCheckpointsPruned,
    StakeInfoUpdated,
    ValidatorCommissionSet
} from "../lib/PlumeEvents.sol";

import { PlumeRewardLogic } from "../lib/PlumeRewardLogic.sol";
import { PlumeStakingStorage } from "../lib/PlumeStakingStorage.sol";
import { PlumeValidatorLogic } from "../lib/PlumeValidatorLogic.sol";

import { OwnableStorage } from "@solidstate/access/ownable/OwnableStorage.sol";
import { DiamondBaseStorage } from "@solidstate/proxy/diamond/base/DiamondBaseStorage.sol";

import { ReentrancyGuardUpgradeable } from "@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { SafeERC20 } from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import { Address } from "@openzeppelin/contracts/utils/Address.sol";
import { OwnableInternal } from "@solidstate/access/ownable/OwnableInternal.sol"; // For inherited onlyOwner

import { PlumeRoles } from "../lib/PlumeRoles.sol";

import { IAccessControl } from "../interfaces/IAccessControl.sol";
import { ValidatorFacet } from "./ValidatorFacet.sol";

/**
 * @title ManagementFacet
 * @author Eugene Y. Q. Shen, Alp Guneysel
 * @notice Facet handling administrative functions like setting parameters and managing contract funds.
 */
contract ManagementFacet is ReentrancyGuardUpgradeable, OwnableInternal {

    using SafeERC20 for IERC20;
    using Address for address payable;

    // --- Modifiers ---

    /**
     * @dev Modifier to check role using the AccessControlFacet.
     * Assumes AccessControlFacet is deployed and added to the diamond.
     */
    modifier onlyRole(
        bytes32 _role
    ) {
        if (!IAccessControl(address(this)).hasRole(_role, msg.sender)) {
            revert Unauthorized(msg.sender, _role);
        }
        _;
    }

    /**
     * @notice Update the minimum stake amount required
     * @dev Requires ADMIN_ROLE.
     * @param _minStakeAmount New minimum stake amount
     */
    function setMinStakeAmount(
        uint256 _minStakeAmount
    ) external onlyRole(PlumeRoles.ADMIN_ROLE) {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();
        uint256 oldAmount = $.minStakeAmount;
        if (_minStakeAmount == 0) {
            revert InvalidAmount(_minStakeAmount);
        }
        $.minStakeAmount = _minStakeAmount;
        emit MinStakeAmountSet(_minStakeAmount);
    }

    /**
     * @notice Update the cooldown interval for unstaking
     * @dev Requires ADMIN_ROLE.
     * @param interval New cooldown interval in seconds
     */
    function setCooldownInterval(
        uint256 interval
    ) external onlyRole(PlumeRoles.ADMIN_ROLE) {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();
        if (interval == 0) {
            revert InvalidInterval(interval);
        }
        // New check against maxSlashVoteDuration
        if ($.maxSlashVoteDurationInSeconds != 0 && interval <= $.maxSlashVoteDurationInSeconds) {
            revert CooldownTooShortForSlashVote(interval, $.maxSlashVoteDurationInSeconds);
        }
        $.cooldownInterval = interval;
        emit CooldownIntervalSet(interval);
    }

    // --- Admin Fund Management (Roles) ---

    /**
     * @notice Allows admin to withdraw ERC20 or native PLUME tokens from the contract balance
     * @dev Primarily for recovering accidentally sent tokens or managing excess reward funds.
     * Requires TIMELOCK_ROLE.
     * @param token Address of the token to withdraw (use PLUME address for native token)
     * @param amount Amount to withdraw
     * @param recipient Address to send the withdrawn tokens to
     */
    function adminWithdraw(
        address token,
        uint256 amount,
        address recipient
    ) external onlyRole(PlumeRoles.TIMELOCK_ROLE) nonReentrant {
        // Validate inputs
        if (token == address(0)) {
            revert ZeroAddress("token");
        }
        if (recipient == address(0)) {
            revert ZeroAddress("recipient");
        }
        if (amount == 0) {
            revert InvalidAmount(amount);
        }

        if (token == PlumeStakingStorage.PLUME_NATIVE) {
            // Native PLUME withdrawal
            uint256 balance = address(this).balance;
            if (amount > balance) {
                revert InsufficientFunds(balance, amount);
            }
            (bool success,) = payable(recipient).call{ value: amount }("");
            if (!success) {
                revert AdminTransferFailed();
            }
        } else {
            // ERC20 withdrawal
            IERC20 erc20Token = IERC20(token);
            uint256 balance = erc20Token.balanceOf(address(this));
            if (amount > balance) {
                revert InsufficientFunds(balance, amount);
            }
            erc20Token.safeTransfer(recipient, amount);
        }

        emit AdminWithdraw(token, amount, recipient);
    }

    // --- Global State Update Functions (Roles) ---

    /**
     * @notice Gets the current minimum stake amount.
     */
    function getMinStakeAmount() external view returns (uint256) {
        return PlumeStakingStorage.layout().minStakeAmount;
    }

    /**
     * @notice Gets the current cooldown interval.
     */
    function getCooldownInterval() external view returns (uint256) {
        return PlumeStakingStorage.layout().cooldownInterval;
    }

    /**
     * @notice Set the maximum duration for slashing votes (ADMIN_ROLE only).
     * @param duration The new duration in seconds.
     */
    function setMaxSlashVoteDuration(
        uint256 duration
    ) external onlyRole(PlumeRoles.ADMIN_ROLE) {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();
        if (duration == 0) {
            revert InvalidInterval(duration);
        }
        // New check against cooldownInterval
        if ($.cooldownInterval != 0 && duration >= $.cooldownInterval) {
            revert SlashVoteDurationTooLongForCooldown(duration, $.cooldownInterval);
        }

        // NEW CHECK: Ensure slash duration is shorter than commission claim timelock
        if (duration >= PlumeStakingStorage.COMMISSION_CLAIM_TIMELOCK) {
            revert SlashVoteDurationExceedsCommissionTimelock(duration, PlumeStakingStorage.COMMISSION_CLAIM_TIMELOCK);
        }

        $.maxSlashVoteDurationInSeconds = duration;
        emit MaxSlashVoteDurationSet(duration);
    }

    /**
     * @notice Set the system-wide maximum allowed commission rate for any validator.
     * @dev Requires TIMELOCK_ROLE. Max rate cannot exceed 50%.
     * @param newMaxRate The new maximum commission rate (e.g., 50e16 for 50%).
     */
    function setMaxAllowedValidatorCommission(
        uint256 newMaxRate
    ) external onlyRole(PlumeRoles.TIMELOCK_ROLE) {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();

        // Max rate cannot be more than 50% (REWARD_PRECISION / 2)
        if (newMaxRate > PlumeStakingStorage.REWARD_PRECISION / 2) {
            revert InvalidMaxCommissionRate(newMaxRate, PlumeStakingStorage.REWARD_PRECISION / 2);
        }

        uint256 oldMaxRate = $.maxAllowedValidatorCommission;
        $.maxAllowedValidatorCommission = newMaxRate;

        emit MaxAllowedValidatorCommissionSet(oldMaxRate, newMaxRate);

        // Enforce the new max commission on all existing validators
        uint16[] memory validatorIds = $.validatorIds;
        for (uint256 i = 0; i < validatorIds.length; i++) {
            uint16 validatorId = validatorIds[i];
            PlumeStakingStorage.ValidatorInfo storage validator = $.validators[validatorId];

            if (validator.commission > newMaxRate) {
                uint256 oldCommission = validator.commission;

                // Settle commissions accrued with the old rate up to this point.
                PlumeRewardLogic._settleCommissionForValidatorUpToNow($, validatorId);

                // Update the validator's commission rate to the new max rate.
                validator.commission = newMaxRate;

                // Create a checkpoint for the new commission rate.
                PlumeRewardLogic.createCommissionRateCheckpoint($, validatorId, newMaxRate);

                emit ValidatorCommissionSet(validatorId, oldCommission, newMaxRate);
            }
        }
    }

    /**
     * @notice Sets the maximum number of commission checkpoints a single validator can have.
     * @dev Protects against gas-exhaustion griefing attacks. Requires ADMIN_ROLE.
     * @param newLimit The new maximum number of checkpoints.
     */
    function setMaxCommissionCheckpoints(
        uint16 newLimit
    ) external onlyRole(PlumeRoles.ADMIN_ROLE) {
        if (newLimit < 10) {
            // Enforce a minimum reasonable limit
            revert InvalidAmount(newLimit);
        }
        PlumeStakingStorage.layout().maxCommissionCheckpoints = newLimit;
        emit MaxCommissionCheckpointsSet(newLimit);
    }

    /**
     * @notice Sets the maximum percentage of total stake a single validator can hold.
     * @dev A value of 0 disables the check. Requires ADMIN_ROLE.
     * @param newPercentage The new percentage in basis points (e.g., 2000 for 20%).
     */
    function setMaxValidatorPercentage(
        uint256 newPercentage
    ) external onlyRole(PlumeRoles.ADMIN_ROLE) {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();

        // A percentage must not exceed 100% (10,000 basis points).
        if (newPercentage > 10_000) {
            revert InvalidPercentage(newPercentage);
        }

        uint256 oldPercentage = $.maxValidatorPercentage;
        $.maxValidatorPercentage = newPercentage;

        emit MaxValidatorPercentageUpdated(oldPercentage, newPercentage);
    }

    // --- Checkpoint Pruning Functions ---

    /**
     * @notice Admin function to prune old commission checkpoints for a validator.
     * @dev DANGEROUS: This operation is gas-intensive and can break reward calculations if checkpoints
     *      are removed that are still needed by users who have not claimed rewards recently.
     *      The administrator is responsible for ensuring this is called safely.
     *      Removes the `count` oldest checkpoints. Requires ADMIN_ROLE.
     * @param validatorId The ID of the validator whose checkpoints will be pruned.
     * @param count The number of old checkpoints to remove.
     */
    function pruneCommissionCheckpoints(uint16 validatorId, uint256 count) external onlyRole(PlumeRoles.ADMIN_ROLE) {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();

        if (!$.validatorExists[validatorId]) {
            revert ValidatorDoesNotExist(validatorId);
        }
        if (count == 0) {
            revert InvalidAmount(count);
        }

        PlumeStakingStorage.RateCheckpoint[] storage checkpoints = $.validatorCommissionCheckpoints[validatorId];
        uint256 len = checkpoints.length;

        if (count >= len) {
            // Cannot remove all checkpoints. At least one must remain to define the current rate.
            revert CannotPruneAllCheckpoints();
        }

        // This is a gas-intensive operation. It shifts all elements to the left.
        for (uint256 i = 0; i < len - count; i++) {
            checkpoints[i] = checkpoints[i + count];
        }

        // Pop the now-duplicate elements from the end.
        for (uint256 i = 0; i < count; i++) {
            checkpoints.pop();
        }

        emit CommissionCheckpointsPruned(validatorId, count);
    }

    /**
     * @notice Admin function to prune old reward rate checkpoints for a validator and token.
     * @dev DANGEROUS: Similar to pruneCommissionCheckpoints, this is gas-intensive and can break
     *      reward calculations. Use with extreme caution. Requires ADMIN_ROLE.
     * @param validatorId The ID of the validator.
     * @param token The address of the reward token.
     * @param count The number of old checkpoints to remove.
     */
    function pruneRewardRateCheckpoints(
        uint16 validatorId,
        address token,
        uint256 count
    ) external onlyRole(PlumeRoles.ADMIN_ROLE) {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();

        if (!$.validatorExists[validatorId]) {
            revert ValidatorDoesNotExist(validatorId);
        }
        // Allow pruning for both active and removed reward tokens, as both may have legacy checkpoints.
        if (!$.isRewardToken[token] && $.tokenAdditionTimestamps[token] == 0) {
            revert TokenDoesNotExist(token);
        }
        if (count == 0) {
            revert InvalidAmount(count);
        }

        PlumeStakingStorage.RateCheckpoint[] storage checkpoints = $.validatorRewardRateCheckpoints[validatorId][token];
        uint256 len = checkpoints.length;

        if (count >= len) {
            revert CannotPruneAllCheckpoints();
        }

        for (uint256 i = 0; i < len - count; i++) {
            checkpoints[i] = checkpoints[i + count];
        }

        for (uint256 i = 0; i < count; i++) {
            checkpoints.pop();
        }

        emit RewardRateCheckpointsPruned(validatorId, token, count);
    }

    // --- NEW ADMIN SLASH CLEANUP FUNCTION ---
    /**
     * @notice Admin function to clear a user's stale records associated with a slashed validator.
     * @dev This is used because a 100% slash means the user has no funds to recover via a user-facing function.
     *      This function cleans up their internal tracking for that validator.
     *      Requires caller to have ADMIN_ROLE.
     * @param user The address of the user whose records need cleanup.
     * @param slashedValidatorId The ID of the validator that was slashed.
     */
    function adminClearValidatorRecord(
        address user,
        uint16 slashedValidatorId
    ) external onlyRole(PlumeRoles.ADMIN_ROLE) {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();

        if (user == address(0)) {
            revert ZeroAddress("user");
        }
        if (!$.validatorExists[slashedValidatorId]) {
            revert ValidatorDoesNotExist(slashedValidatorId);
        }
        if (!$.validators[slashedValidatorId].slashed) {
            revert ValidatorNotSlashed(slashedValidatorId);
        }

        uint256 userActiveStakeToClear = $.userValidatorStakes[user][slashedValidatorId].staked;
        PlumeStakingStorage.CooldownEntry storage cooldownEntry = $.userValidatorCooldowns[user][slashedValidatorId];
        uint256 userCooledAmountToClear = cooldownEntry.amount;

        bool recordChanged = false;

        if (userActiveStakeToClear > 0) {
            $.userValidatorStakes[user][slashedValidatorId].staked = 0;
            // Decrement user's global stake
            if ($.stakeInfo[user].staked >= userActiveStakeToClear) {
                $.stakeInfo[user].staked -= userActiveStakeToClear;
            } else {
                $.stakeInfo[user].staked = 0; // Should not happen if state is consistent
            }
            emit AdminClearedSlashedStake(user, slashedValidatorId, userActiveStakeToClear);
            recordChanged = true;
        }

        if (userCooledAmountToClear > 0) {
            // This function should only clear funds considered lost to the slash.
            // A cooldown is lost if it did NOT mature before the slash timestamp.
            uint256 slashTimestamp = $.validators[slashedValidatorId].slashedAtTimestamp;
            bool cooldownIsLost = cooldownEntry.cooldownEndTime >= slashTimestamp;

            if (cooldownIsLost) {
                delete $.userValidatorCooldowns[user][slashedValidatorId];
                // Decrement user's global cooled amount
                if ($.stakeInfo[user].cooled >= userCooledAmountToClear) {
                    $.stakeInfo[user].cooled -= userCooledAmountToClear;
                } else {
                    $.stakeInfo[user].cooled = 0; // Should not happen
                }
                emit AdminClearedSlashedCooldown(user, slashedValidatorId, userCooledAmountToClear);
                recordChanged = true;
            }
        }

        if ($.userHasStakedWithValidator[user][slashedValidatorId] || recordChanged) {
            PlumeValidatorLogic.removeStakerFromValidator($, user, slashedValidatorId);
        }
    }

    /**
     * @notice Admin function to clear stale records for multiple users associated with a single slashed validator.
     * @dev This iterates through a list of users and calls the single-user cleanup logic.
     *      Due to gas limits, this should be called with reasonably sized batches of users.
     *      Requires caller to have ADMIN_ROLE.
     * @param users Array of user addresses whose records need cleanup for the given validator.
     * @param slashedValidatorId The ID of the validator that was slashed.
     */
    function adminBatchClearValidatorRecords(
        address[] calldata users,
        uint16 slashedValidatorId
    ) external onlyRole(PlumeRoles.ADMIN_ROLE) {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();

        if (!$.validatorExists[slashedValidatorId]) {
            revert ValidatorDoesNotExist(slashedValidatorId);
        }
        if (!$.validators[slashedValidatorId].slashed) {
            revert ValidatorNotSlashed(slashedValidatorId);
        }
        if (users.length == 0) {
            revert EmptyArray();
        }

        uint256 slashTimestamp = $.validators[slashedValidatorId].slashedAtTimestamp;

        for (uint256 i = 0; i < users.length; i++) {
            address user = users[i];
            if (user != address(0)) {
                uint256 userActiveStakeToClear = $.userValidatorStakes[user][slashedValidatorId].staked;
                PlumeStakingStorage.CooldownEntry storage cooldownEntry =
                    $.userValidatorCooldowns[user][slashedValidatorId];
                uint256 userCooledAmountToClear = cooldownEntry.amount;
                bool recordActuallyChangedForThisUser = false;

                if (userActiveStakeToClear > 0) {
                    $.userValidatorStakes[user][slashedValidatorId].staked = 0;
                    // Decrement user's global stake
                    if ($.stakeInfo[user].staked >= userActiveStakeToClear) {
                        $.stakeInfo[user].staked -= userActiveStakeToClear;
                    } else {
                        $.stakeInfo[user].staked = 0;
                    }
                    emit AdminClearedSlashedStake(user, slashedValidatorId, userActiveStakeToClear);
                    recordActuallyChangedForThisUser = true;
                }

                if (userCooledAmountToClear > 0) {
                    bool cooldownIsLost = cooldownEntry.cooldownEndTime >= slashTimestamp;
                    if (cooldownIsLost) {
                        delete $.userValidatorCooldowns[user][slashedValidatorId];
                        // Decrement user's global cooled amount
                        if ($.stakeInfo[user].cooled >= userCooledAmountToClear) {
                            $.stakeInfo[user].cooled -= userCooledAmountToClear;
                        } else {
                            $.stakeInfo[user].cooled = 0;
                        }
                        emit AdminClearedSlashedCooldown(user, slashedValidatorId, userCooledAmountToClear);
                        recordActuallyChangedForThisUser = true;
                    }
                }

                if ($.userHasStakedWithValidator[user][slashedValidatorId] || recordActuallyChangedForThisUser) {
                    PlumeValidatorLogic.removeStakerFromValidator($, user, slashedValidatorId);
                }
            }
        }
    }
    // --- END NEW ADMIN SLASH CLEANUP FUNCTION ---

    // --- HISTORICAL REWARD TOKEN MANAGEMENT ---

    /**
     * @notice Admin function to manually add a token to the historical rewards list.
     * @dev This is for administrative correction, e.g., after a data migration. It does not make
     *      the token an *active* reward token. Requires ADMIN_ROLE.
     * @param token The address of the token to add to the historical list.
     */
    function addHistoricalRewardToken(address token) external onlyRole(PlumeRoles.ADMIN_ROLE) {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();
        if (token == address(0)) {
            revert ZeroAddress("token");
        }
        if ($.isHistoricalRewardToken[token]) {
            // Revert if it's already in the historical list to prevent duplicates.
            revert TokenAlreadyExists();
        }

        $.isHistoricalRewardToken[token] = true;
        $.historicalRewardTokens.push(token);

        emit HistoricalRewardTokenAdded(token);
    }

    /**
     * @notice Admin function to manually remove a token from the historical rewards list.
     * @dev DANGEROUS: This operation can lead to PERMANENT LOSS OF USER FUNDS if there are any
     *      unclaimed or unsettled rewards for this token. The responsibility for ensuring safety
     *      lies entirely with the caller of this function. Requires ADMIN_ROLE.
     * @param token The address of the token to remove from the historical list.
     */
    function removeHistoricalRewardToken(address token) external onlyRole(PlumeRoles.ADMIN_ROLE) {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();
        if (token == address(0)) {
            revert ZeroAddress("token");
        }

        // CRITICAL CHECK: The token MUST NOT be an active reward token.
        // It must be "soft removed" via the standard `removeRewardToken` function first.
        if ($.isRewardToken[token]) {
            revert TokenAlreadyExists(); // Re-using error for "token is currently active"
        }

        // Find and remove the token from the historical array
        address[] storage historicalTokens = $.historicalRewardTokens;
        uint256 tokenIndex = type(uint256).max;
        for (uint256 i = 0; i < historicalTokens.length; i++) {
            if (historicalTokens[i] == token) {
                tokenIndex = i;
                break;
            }
        }

        // Revert if the token was not found in the historical list
        if (tokenIndex == type(uint256).max) {
            revert TokenDoesNotExist(token);
        }

        // Swap and pop to remove the element
        historicalTokens[tokenIndex] = historicalTokens[historicalTokens.length - 1];
        historicalTokens.pop();

        // Update the mapping
        $.isHistoricalRewardToken[token] = false;

        emit HistoricalRewardTokenRemoved(token);
    }

    // --- HISTORICAL REWARD TOKEN VIEW FUNCTIONS ---

    /**
     * @notice Checks if a token has ever been a reward token.
     * @param token The address of the token to check.
     * @return True if the token is in the historical list, false otherwise.
     */
    function isHistoricalRewardToken(address token) external view returns (bool) {
        return PlumeStakingStorage.layout().isHistoricalRewardToken[token];
    }

    /**
     * @notice Returns the complete list of all tokens that have ever been reward tokens.
     * @return An array of token addresses.
     */
    function getHistoricalRewardTokens() external view returns (address[] memory) {
        return PlumeStakingStorage.layout().historicalRewardTokens;
    }

    // --- MIGRATION-SPECIFIC FUNCTION ---

    /**
     * @notice Admin function to manually create a historical reward rate checkpoint for a validator.
     * @dev DANGEROUS: This is a special-purpose migration function. It bypasses normal settlement logic
     *      and should only be used to back-fill historical data during an upgrade.
     *      Requires ADMIN_ROLE.
     * @param validatorId The ID of the validator to create the checkpoint for.
     * @param token The address of the reward token.
     * @param timestamp The historical timestamp for the checkpoint.
     * @param rate The historical rate for the checkpoint.
     */
    function adminCreateHistoricalRewardCheckpoint(
        uint16 validatorId,
        address token,
        uint256 timestamp,
        uint256 rate
    ) external onlyRole(PlumeRoles.ADMIN_ROLE) {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();

        // Basic validation
        if (!$.validatorExists[validatorId]) {
            revert ValidatorDoesNotExist(validatorId);
        }
        if (!$.isHistoricalRewardToken[token]) {
            // Check historical list, as this is for migrating historical data
            revert TokenDoesNotExist(token);
        }

        // Directly create the checkpoint. We assume cumulativeIndex is not needed for this migration,
        // as the new reward logic will calculate it based on this new baseline.
        PlumeStakingStorage.RateCheckpoint memory checkpoint = PlumeStakingStorage.RateCheckpoint({
            timestamp: timestamp,
            rate: rate,
            cumulativeIndex: 0 // Explicitly set to 0 for migrated checkpoints
         });

        $.validatorRewardRateCheckpoints[validatorId][token].push(checkpoint);

        // Note: No event is emitted here as this is a background migration action.
    }

    /**
     * @notice Admin function to manually set the addition timestamp for a historical token.
     * @dev DANGEROUS: This is a special-purpose migration function intended to be used with
     *      `adminCreateHistoricalRewardCheckpoint`. It should only be used to back-fill
     *      historical data during an upgrade. Requires ADMIN_ROLE.
     * @param token The address of the historical reward token.
     * @param timestamp The historical timestamp when the token was originally added.
     */
    function adminSetTokenAdditionTimestamp(
        address token,
        uint256 timestamp
    ) external onlyRole(PlumeRoles.ADMIN_ROLE) {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();

        // Basic validation
        if (token == address(0)) {
            revert ZeroAddress("token");
        }
        if (timestamp == 0) {
            revert InvalidAmount(timestamp);
        }
        if (!$.isHistoricalRewardToken[token]) {
            revert TokenDoesNotExist(token);
        }

        // Set the timestamp.
        $.tokenAdditionTimestamps[token] = timestamp;

        // No event is emitted as this is a background migration action.
    }
}

// @audit

=== AccessControlFacet.sol ===
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.25;

// SolidState Access Control
import { AccessControlInternal } from "@solidstate/access/access_control/AccessControlInternal.sol";
import { AccessControlStorage } from "@solidstate/access/access_control/AccessControlStorage.sol";

// Plume Roles & Interface
import { IAccessControl } from "../interfaces/IAccessControl.sol";
import { PlumeRoles } from "../lib/PlumeRoles.sol";
import { PlumeStakingStorage } from "../lib/PlumeStakingStorage.sol"; // For potential shared init flag

/**
 * @title AccessControlFacet
 * @notice Facet for managing roles using SolidState's AccessControl logic.
 * @dev Uses the storage slot defined in SolidState's AccessControlStorage.
 */
contract AccessControlFacet is IAccessControl, AccessControlInternal {

    // Define all roles locally for clarity and direct access
    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;
    bytes32 public constant ADMIN_ROLE = PlumeRoles.ADMIN_ROLE;
    bytes32 public constant UPGRADER_ROLE = PlumeRoles.UPGRADER_ROLE;
    bytes32 public constant VALIDATOR_ROLE = PlumeRoles.VALIDATOR_ROLE;
    bytes32 public constant REWARD_MANAGER_ROLE = PlumeRoles.REWARD_MANAGER_ROLE;
    bytes32 public constant TIMELOCK_ROLE = PlumeRoles.TIMELOCK_ROLE;
    /**
     * @notice Initializes the AccessControl facet, setting up all roles and their admins.
     * @dev Can only be called once, typically by the diamond owner after cutting the facet.
     * Sets up the complete role hierarchy with DEFAULT_ADMIN_ROLE and ADMIN_ROLE at the top.
     */

    function initializeAccessControl() external {
        PlumeStakingStorage.Layout storage $ = PlumeStakingStorage.layout();
        require(!$.accessControlFacetInitialized, "ACF: init");

        // Grant the essential DEFAULT_ADMIN_ROLE to the caller
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);

        // Grant ADMIN_ROLE to the caller
        _grantRole(ADMIN_ROLE, msg.sender);

        // Set up role hierarchy
        // Make ADMIN_ROLE the admin for all other roles (including itself)
        _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);
        _setRoleAdmin(TIMELOCK_ROLE, ADMIN_ROLE);
        _setRoleAdmin(UPGRADER_ROLE, ADMIN_ROLE);
        _setRoleAdmin(VALIDATOR_ROLE, ADMIN_ROLE);
        _setRoleAdmin(REWARD_MANAGER_ROLE, ADMIN_ROLE);

        // Grant initial roles to the caller
        _grantRole(UPGRADER_ROLE, msg.sender);
        _grantRole(REWARD_MANAGER_ROLE, msg.sender);

        $.accessControlFacetInitialized = true;
    }

    // --- External Functions ---

    /// @inheritdoc IAccessControl
    function hasRole(bytes32 role, address account) external view override returns (bool) {
        return _hasRole(role, account);
    }

    /// @inheritdoc IAccessControl
    function getRoleAdmin(
        bytes32 role
    ) external view override returns (bytes32) {
        return _getRoleAdmin(role);
    }

    /**
     * @inheritdoc IAccessControl
     * @dev Requires the caller to have the admin role for the role being granted.
     */
    function grantRole(bytes32 role, address account) external override onlyRole(_getRoleAdmin(role)) {
        _grantRole(role, account);
    }

    /**
     * @inheritdoc IAccessControl
     * @dev Requires the caller to have the admin role for the role being revoked.
     */
    function revokeRole(bytes32 role, address account) external override onlyRole(_getRoleAdmin(role)) {
        _revokeRole(role, account);
    }

    /**
     * @inheritdoc IAccessControl
     * @dev Allows an account to renounce their own role.
     */
    function renounceRole(bytes32 role, address account) external override {
        require(account == msg.sender, "AccessControl: can only renounce roles for self");
        _renounceRole(role);
    }

    /**
     * @inheritdoc IAccessControl
     * @dev Requires the caller to have the ADMIN_ROLE to change role admins.
     */
    function setRoleAdmin(bytes32 role, bytes32 adminRole) external override onlyRole(ADMIN_ROLE) {
        _setRoleAdmin(role, adminRole);
    }

}

// @audit